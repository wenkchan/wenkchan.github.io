<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenk.Chan的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-06T03:49:35.541Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenk.Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合(一) — HashMap</title>
    <link href="http://yoursite.com/2019/11/06/Java%E9%9B%86%E5%90%88(%E4%B8%80)%20%E2%80%94%20HashMap/"/>
    <id>http://yoursite.com/2019/11/06/Java集合(一) — HashMap/</id>
    <published>2019-11-06T03:49:13.907Z</published>
    <updated>2019-11-06T03:49:35.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/15693063662970.jpg" alt=""></p><h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>HashMap是一个<code>关联数组、哈希表</code>，其中数组被称为<code>哈希桶</code>，每个<code>桶里放的是单链表或红黑树</code>，每个<code>节点</code>就是哈希表中的<code>元素</code>。</p><p>特点是</p><ol><li>线程不安全(线程安全可使用<code>ConcurrentHashMap</code>)</li><li>遍历无序</li><li>允许单个null的key和多个null的值</li></ol><p><code>JDK1.8后</code>，新增了<code>红黑树</code>，当单个链表的元素达到<code>8</code>，就会转换成红黑树，提高查询和插入的效率，避免链表过长的问题</p><p>需要关注的问题</p><ol><li>hash表，涉及到<code>碰撞解决</code></li><li>数组，涉及到<code>扩容机制</code></li></ol><blockquote><h2 id="Hash知识补充"><a href="#Hash知识补充" class="headerlink" title="Hash知识补充"></a>Hash知识补充</h2><p>Hash就是把任意长度的消息(<code>预映射:pre-image</code>)通过哈希算法压缩成<code>固定长度</code>的消息输出,输出的值就是<code>Hash值</code>。<code>不同的输入</code>可能有<code>同样的输出</code>,所以用Hash值<code>得不到唯一值</code>,同样的输出<br>称为<code>碰撞</code>需要进行<code>碰撞处理</code>:一般有:<br><code>拉链法(open hashing)</code>、<code>开放定址法(closed hashing)</code>、<code>再哈希法</code>、<code>建立公共溢出区</code></p></blockquote><h1 id="二、碰撞解决"><a href="#二、碰撞解决" class="headerlink" title="二、碰撞解决"></a>二、碰撞解决</h1><p>从源码可知，HashMap中非常重要的一个字段， <code>Node[] table</code>，即<code>Hash桶数组</code>，Node的数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//用于定位索引</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">//链表的下一个Node</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了<code>Map.Entry</code>接口，本质是就是一个<code>键值对</code>。每一个<code>节点存储的就是一个Node</code></p><p>HashMap使用的是Hash表存储，并且使用<code>拉链法</code>解决碰撞。简单来说，就是数组加链表的结合.<br>当数据被Hash后，得到<code>数组下标</code>，把数据放在<code>对应下标元素的链表</code>。如果发生了碰撞，就会把数据插到对应链表的<code>尾部</code>(JDK1.7是插到头部，插到尾部避免了逆序，环形链表,后文会讲到)</p><p> <img src="/media/15692013445358.jpg" alt="-w541"></p><h1 id="三、扩容机制"><a href="#三、扩容机制" class="headerlink" title="三、扩容机制"></a>三、扩容机制</h1><p> 理解扩容机制之前需要看一下几个重要的参数<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容量默认为16,且必须为2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//负载默认因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">int</span> threshold;            </span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    </span><br><span class="line"><span class="comment">//结构变化次数</span></span><br><span class="line"><span class="keyword">int</span> modCount; </span><br><span class="line"><span class="comment">//实际存储的键值对</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>threshold</code>是HashMap所能容纳的最大数据量,计算公式是<code>threshold = length * loadFactor</code><br>当存储个数<code>size</code>大于<code>threshold</code>,容量扩大为<code>原来的两倍</code></p></li><li><p><code>modCount</code>用来记录HashMap<code>内部结构发生变化的次数</code>,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value<code>被覆盖不属于结构变化</code></p></li><li><p><code>loadFactor 负载因子</code>默认值是<code>0.75</code>,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重</p></li><li><p><code>DEFAULT_INITIAL_CAPACITY 初始容量</code>为<code>16</code>,且为<code>2的幂</code>,采用这种<code>非常规</code>设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p></li></ul><p>下面来分析一下<code>resize</code>的源码，鉴于红黑树比较复杂，这里先看JDK1.7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   </span><br><span class="line">     <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     Entry[] oldTable = table;    </span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;        </span><br><span class="line">     <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了 </span></span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; </span><br><span class="line">         <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 </span></span><br><span class="line">         threshold = Integer.MAX_VALUE; </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//！！将数据转移到新的Entry数组里  </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line">   <span class="comment">//HashMap的table属性引用新的Entry数组                        </span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//修改阈值                          </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//释放旧Entry数组的对象引用，防止对象游离</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">//标记</span></span><br><span class="line">                 e.next = newTable[i];</span><br><span class="line">                 <span class="comment">//将元素放在数组上 </span></span><br><span class="line">                 newTable[i] = e;</span><br><span class="line">                 <span class="comment">//访问下一个Entry链上的元素      </span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>e的引用复制给了newTable[i],也就是说这里使用了单链表的<code>头插法</code>，而且需要<code>重新计算</code>每个元素的<code>hash值</code>，这两点与JDK1.8有区别,</p><p>下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为<code>原来的2倍</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure></p><p>所以，元素的位置要么是在<code>原位置</code>，要么是在<code>原位置再移动2次幂</code>的位置，下图就可以看的出来<br><img src="/media/15692961900375.jpg" alt=""><br>a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化<br><img src="/media/15692963388249.jpg" alt=""></p><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是<code>0的话索引没变</code>，是<code>1的话索引变成&quot;原索引+oldCap&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e</span><br></pre></td></tr></table></figure><p>下图为16扩充为32的resize示意图<br><img src="/media/15692963846956.jpg" alt=""></p><p>这样，既<code>省去了重新计算hash值的时间</code>，同时，由于新增的1bit可以认为是<code>随机的</code>，因此resize的过程，<code>均匀地</code>把之前的冲突的节点分散到新的bucket了。</p><blockquote><h2 id="JDK1-7的环形链表死循环问题"><a href="#JDK1-7的环形链表死循环问题" class="headerlink" title="JDK1.7的环形链表死循环问题"></a>JDK1.7的环形链表死循环问题</h2><p>扩容时，当线程A运行到<code>Entry&lt;K,V&gt; next = e.next</code>被挂起，线程B完成了扩容操作后，会出现<br>主要原因是新链表<code>头插</code>操作,导致<code>逆序</code>,JDK1.8之后改用<code>尾插</code>修复，但是仍然是线程不安全</p></blockquote><p>下面是JDK1.8扩容的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果原容量的两倍小于最大容量，且元容量大于默认容量</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              <span class="comment">//新容量为原容量的两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//遍历旧数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="comment">// 原索引</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、操作方法"><a href="#四、操作方法" class="headerlink" title="四、操作方法"></a>四、操作方法</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p><img src="/media/15692055428965.jpg" alt=""></p><ol><li>如果table为null则创建</li><li>根据hash计算出元素index(<code>length - 1 &amp; hash</code>效果等同于取模,效率提高),并处理null值</li><li>如果key存在,直接覆盖Value</li><li>判断是否为红黑树</li><li>判断是否为链表</li><li>判断是否需要扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//对key进行hash操作</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//1、如果table为null则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">//2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//3、如果key存在,直接覆盖Value</span></span><br><span class="line">         <span class="keyword">if</span> (p。hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">//4、判断是否为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">//5、判断是否为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//链表大于阈值则转换为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//key存在直接覆盖</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.alue;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">//6、判断是否需要扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Java 8系列之重新认识HashMap</code> <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br><code>HashMap在JDK7和JDK8中的区别</code> <a href="https://zhuanlan.zhihu.com/p/59250175" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59250175</a><br><code>Map 综述（一）：彻头彻尾理解 HashMap</code> <a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/62893086</a><br><code>面试必备：HashMap源码解析（JDK8）</code> <a href="https://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="noopener">https://blog.csdn.net/zxt0601/article/details/77413921</a><br><code>解决哈希冲突的常用方法分析</code> <a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">https://www.jianshu.com/p/4d3cb99d7580</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/15693063662970.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、概要&quot;&gt;&lt;a href=&quot;#一、概要&quot; class=&quot;headerlink&quot; title=&quot;一、概要&quot;&gt;&lt;/a&gt;一、概要&lt;/h1&gt;&lt;p&gt;HashMap是一个
      
    
    </summary>
    
      <category term="Java集合" scheme="http://yoursite.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(十一) — 序列化</title>
    <link href="http://yoursite.com/2019/11/06/Java%E5%9F%BA%E7%A1%80(%E5%8D%81%E4%B8%80)%20%E2%80%94%20%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/06/Java基础(十一) — 序列化/</id>
    <published>2019-11-06T03:47:25.322Z</published>
    <updated>2019-11-06T03:49:35.530Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(十) — 引用</title>
    <link href="http://yoursite.com/2019/11/06/Java%E5%9F%BA%E7%A1%80(%E5%8D%81)%20%E2%80%94%20%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/11/06/Java基础(十) — 引用/</id>
    <published>2019-11-06T03:44:34.425Z</published>
    <updated>2019-11-06T03:45:13.379Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(九) — 注解</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%B9%9D)%20%E2%80%94%20%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(九) — 注解/</id>
    <published>2019-11-04T04:33:30.879Z</published>
    <updated>2019-11-04T04:33:46.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(八) — 克隆</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E5%85%AB)%20%E2%80%94%20%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(八) — 克隆/</id>
    <published>2019-11-04T04:32:45.667Z</published>
    <updated>2019-11-06T03:43:31.645Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(七) — 反射</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%B8%83)%20%E2%80%94%20%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(七) — 反射/</id>
    <published>2019-11-04T03:48:49.848Z</published>
    <updated>2019-11-04T03:49:16.339Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(六) — 泛型</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E5%85%AD)%20%E2%80%94%20%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(六) — 泛型/</id>
    <published>2019-11-04T03:48:21.248Z</published>
    <updated>2019-11-06T03:27:47.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>“泛型”简单的意思就是泛指的类型(<code>参数化类型</code>)。主要作用是限制只能往集合中添加<code>一种类型</code>的数据，让错误在<code>编译期</code>暴露，避免运行时异常的发生，提升代码的健壮性。</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类定义时只需在类名后面加上<code>类型参数</code>，当然也可以添加多个参数，类似于&lt;T,S&gt;。这样就可以在类里面使用定义的类型参数。</p><h2 id="2、泛型方法"><a href="#2、泛型方法" class="headerlink" title="2、泛型方法"></a>2、泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;I&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法声明的方式就是在权限修饰符和返回值之间加上<code>&lt;I&gt;</code>或者任意其他的标识,而里面的<code>I</code>跟类<code>T</code>就算是用一样的标识，也不会是同一个类型，两者作用域不一样。</p><h2 id="3、泛型接口"><a href="#3、泛型接口" class="headerlink" title="3、泛型接口"></a>3、泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口在实现时，需要将实参传入，并且接口中使用了参数对应的地方类型也要与传入实参一致</p><h1 id="三、类型擦除"><a href="#三、类型擦除" class="headerlink" title="三、类型擦除"></a>三、类型擦除</h1><h2 id="1、描述"><a href="#1、描述" class="headerlink" title="1、描述"></a>1、描述</h2><p>泛型在设计时，为了兼容旧版本，Java使用了<code>类型擦除机制</code>。即泛型的参数类型只存在于编译期，运行期获取不到任何已经声明的类型信息,但是会保证类和参数内部参数类型一致。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class1.equals(class2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>泛型参数会被擦除到它的<code>第一边界</code>,如果没有边界。类型将被<code>擦除到Object</code><br>边界可以有多个，使用<code>extends</code>参数可以给参数类型添加一个边界<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line">    T desc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(T desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.descj = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> extends关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到Color类型。</p><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>在编译过程中，类型变量信息还能获取到，所以<code>set的时可以做类型检查</code>，非法类型不能通过编译<br>为了”还原”返回结果的类型，编译器在<code>get之后添加了类型转换</code></p><h2 id="3、缺陷与补救"><a href="#3、缺陷与补救" class="headerlink" title="3、缺陷与补救"></a>3、缺陷与补救</h2><p>泛型不能显示地运用在运行时类型的操作中，类似于转型、instance of和new，当然也有相应的方法替换</p><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>使用时，把类型参数的Class对象记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        classType=type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classType.isInstance(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GenericType&lt;A&gt; genericType=<span class="keyword">new</span> GenericType&lt;&gt;(A.class);</span><br><span class="line">System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> A()));</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> B()));</span><br></pre></td></tr></table></figure><h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p>使用工厂模式和泛型方法来创建实例对象。代码变动的话，添加新的工厂即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creater</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    instance=f.create();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer integer=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Creater&lt;Integer&gt; creater=<span class="keyword">new</span> Creater&lt;&gt;();</span><br><span class="line">System.out.println(creater.newInstance(<span class="keyword">new</span> IntegerFactory()));</span><br></pre></td></tr></table></figure><h1 id="四、泛型通配符"><a href="#四、泛型通配符" class="headerlink" title="四、泛型通配符"></a>四、泛型通配符</h1><h2 id="1、上界通配符"><a href="#1、上界通配符" class="headerlink" title="1、上界通配符"></a>1、上界通配符</h2><p><code>&lt;? extends C&gt;</code>这种形式的通配符，可以实现泛型的<code>向上转型</code>,以ArrayList为例，可以包含的元素就是<code>C</code>的一种子类型(包含C),称为<code>子类型边界</code></p><p>其中能使用的方法有<code>contains、indexOf</code>等形参为<code>Object</code>的方法，<br>还有<code>get</code>是可以，但是只能当做是<code>Object</code>处理<br>但是<code>add(T t)</code>就不行,因为不清楚集合里面的元素是什么类型，所以无法加入任何对象</p><h2 id="2、下界通配符"><a href="#2、下界通配符" class="headerlink" title="2、下界通配符"></a>2、下界通配符</h2><p><code>&lt;? super C&gt;</code>这种形式的通配符,以ArrayList为例，可以包含的元素就是<code>C</code>(包含C)的<code>超类型</code>,即从当前类的父类直至Object类,称为<code>超类型边界</code></p><p>而能使用的方法只是<code>add</code>,能插入的元素要么是A，要么是A的父类，<code>如果B和C继承于A,且A有一个父类D,那么D也是A和B的父类</code></p><p>不能<code>get</code>，因为不能确定操作的数据是属于哪种类型,除非拿出来当做<code>Object</code>处理</p><p>结合上下界通配符，可以这样写入元素,来自<code>Collectoins#copy</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; destination, List&lt;? extends T&gt; source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destination.size() &lt; source.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"destination.size() &lt; source.size(): "</span> +</span><br><span class="line">                destination.size() + <span class="string">" &lt; "</span> + source.size());</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;? extends T&gt; srcIt = source.iterator();</span><br><span class="line">    ListIterator&lt;? <span class="keyword">super</span> T&gt; destIt = destination.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (srcIt.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            destIt.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> AssertionError?</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source size "</span> + source.size() +</span><br><span class="line">                    <span class="string">" does not fit into destination"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        destIt.set(srcIt.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。<br>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;“泛型”简单的意思就是泛指的类型(&lt;code&gt;参数化类型&lt;/code&gt;)。主要作用是限制只能往集合中添加&lt;code&gt;一种类型
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(五) — 异常</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%BA%94)%20%E2%80%94%20%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(五) — 异常/</id>
    <published>2019-11-04T03:46:59.700Z</published>
    <updated>2019-11-05T02:21:27.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、异常分类"><a href="#一、异常分类" class="headerlink" title="一、异常分类"></a>一、异常分类</h1><h2 id="1、继承关系分类"><a href="#1、继承关系分类" class="headerlink" title="1、继承关系分类"></a>1、继承关系分类</h2><p><img src="/media/15572859400020.jpg" alt="15572859400020"></p><ul><li><code>Throwable</code>:所有异常的<code>基类</code>,指出了代码中可以用通过异常传播机制传输Java程序任何问题的<code>共性</code></li><li><code>Error</code>:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止</li><li><code>Exception</code>:程序本身可以处理的错误，Exception还有一个重要的子类<code>RunTimeException</code>,<code>RunTimeException及其子类</code>用来表示<code>JVM常用操作</code>引发的错误(NullPointerException、ArithmeticException)</li></ul><h2 id="2、可查和不可查"><a href="#2、可查和不可查" class="headerlink" title="2、可查和不可查"></a>2、可查和不可查</h2><p>包含Exception和Error在内，Java异常可分为<code>可查异常</code>和<code>不可查异常</code></p><ul><li><code>可查异常</code>:在程序正常运行中允许发生的异常，并且<code>必须进行处理</code>，否则Java编译器不会通过.</li><li><code>不可查异常</code>:包含<code>RunTimeException及其子类</code>和<code>Error</code></li></ul><h2 id="3、运行时和非运行时"><a href="#3、运行时和非运行时" class="headerlink" title="3、运行时和非运行时"></a>3、运行时和非运行时</h2><ul><li><code>运行时异常</code>:都是<code>RunTimeException及其子类</code>,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException</li><li><code>非运行时异常(编译异常)</code>:RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException</li></ul><h1 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h1><h2 id="1、异常处理机制"><a href="#1、异常处理机制" class="headerlink" title="1、异常处理机制"></a>1、异常处理机制</h2><ul><li><code>抛出异常</code>:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中<code>包括异常类型和异常信息</code></li><li><code>捕获异常</code>:在抛出异常后，运行时系统就开始寻找合适的<code>异常处理器(exception handler)</code>,寻找的地方就是依次留在调用<code>方法栈中的方法的集合</code>,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止</li></ul><h2 id="2、异常的处理方式"><a href="#2、异常的处理方式" class="headerlink" title="2、异常的处理方式"></a>2、异常的处理方式</h2><ul><li>RunTimeException:由运行时系统抛出，可以忽略，</li><li>Error:属于不允许发生情况，所以不捕捉</li><li>可查异常:必须捕捉、或者声明抛出</li></ul><h2 id="3、捕捉处理异常语句"><a href="#3、捕捉处理异常语句" class="headerlink" title="3、捕捉处理异常语句"></a>3、捕捉处理异常语句</h2><p>try-catch-finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally</li><li>catch:用于处理捕捉到的异常</li><li>finally:无论是否捕捉到异常,都会执行,<code>如果try或者catch中有返回语句，那么finally会在返回之前执行</code></li></ul><p>以下四种情况finally不会被执行</p><ul><li>finally出现异常</li><li>前面代码使用System.exit()退出程序</li><li>程序所有线程死亡</li><li>关闭CPU</li></ul><h2 id="4、抛出异常-throws"><a href="#4、抛出异常-throws" class="headerlink" title="4、抛出异常 throws"></a>4、抛出异常 throws</h2><p>如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用<code>throws</code>抛出异常，给上一层处理</p><h3 id="抛出规则"><a href="#抛出规则" class="headerlink" title="抛出规则"></a>抛出规则</h3><ul><li>对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出</li><li>可查异常，要么try-catch捕获，要么使用<code>throws</code>声明抛出</li><li>抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、异常分类&quot;&gt;&lt;a href=&quot;#一、异常分类&quot; class=&quot;headerlink&quot; title=&quot;一、异常分类&quot;&gt;&lt;/a&gt;一、异常分类&lt;/h1&gt;&lt;h2 id=&quot;1、继承关系分类&quot;&gt;&lt;a href=&quot;#1、继承关系分类&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(四) — 枚举</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E5%9B%9B)%20%E2%80%94%20%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(四) — 枚举/</id>
    <published>2019-11-04T03:46:42.388Z</published>
    <updated>2019-11-06T03:49:35.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><p>Enum实际上是一种特殊的类，编译后会转换成正常的类，如下简单定义一个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    WHITE,BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译后就会转换成一下的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变成了final类并继承与Enum</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">//前面定义的2种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color WHITE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        WHITE = <span class="keyword">new</span> Color(<span class="string">"WHITE"</span>, <span class="number">0</span>);</span><br><span class="line">        BLACK = <span class="keyword">new</span> Color(<span class="string">"BLACK"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</span><br><span class="line">            WHITE, BLACK</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Color[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(Color, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、常见方法"><a href="#二、常见方法" class="headerlink" title="二、常见方法"></a>二、常见方法</h1><table><thead><tr><th style="text-align:center">返回类型</th><th style="text-align:center">方法名称</th><th style="text-align:center">方法说明</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">compareTo(E o)</td><td style="text-align:center">比较此枚举与指定对象的顺序</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">equals(Object other)</td><td style="text-align:center">当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td style="text-align:center">Class&lt;?&gt;</td><td style="text-align:center">getDeclaringClass()</td><td style="text-align:center">返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">name()</td><td style="text-align:center">返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">ordinal()</td><td style="text-align:center">返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">toString()</td><td style="text-align:center">返回枚举常量的名称，它包含在声明中</td></tr><tr><td style="text-align:center">static&lt;T extends Enum<t>&gt; T</t></td><td style="text-align:center">static valueOf(Class<t> enumType, String name)</t></td><td style="text-align:center">返回带指定名称的指定枚举类型的枚举常量</td></tr></tbody></table><p>值得注意的是Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的</p><h1 id="三、进阶用法"><a href="#三、进阶用法" class="headerlink" title="三、进阶用法"></a>三、进阶用法</h1><h2 id="1、结合抽象方法"><a href="#1、结合抽象方法" class="headerlink" title="1、结合抽象方法"></a>1、结合抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    WHITE&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是白色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,BLACK &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是黑色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        String color = Color.WHITE.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、结合接口"><a href="#2、结合接口" class="headerlink" title="2、结合接口"></a>2、结合接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> DeepColor implements Color&#123;</span><br><span class="line">        DEEP_BLUE,DEEP_GREEN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> LightColor implements Color&#123;</span><br><span class="line">       LIGHT_BLUE,LIGHT_GREEN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Color color = Color.DeepColor.DEEP_BLUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、辅助类"><a href="#四、辅助类" class="headerlink" title="四、辅助类"></a>四、辅助类</h1><h2 id="1、EnumMap"><a href="#1、EnumMap" class="headerlink" title="1、EnumMap"></a>1、EnumMap</h2><p>key为Enum类型的Map</p><h2 id="2、EnumSet"><a href="#2、EnumSet" class="headerlink" title="2、EnumSet"></a>2、EnumSet</h2><p>元素只能为Enum的Set</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、原理&quot;&gt;&lt;a href=&quot;#一、原理&quot; class=&quot;headerlink&quot; title=&quot;一、原理&quot;&gt;&lt;/a&gt;一、原理&lt;/h1&gt;&lt;p&gt;Enum实际上是一种特殊的类，编译后会转换成正常的类，如下简单定义一个枚举类&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(三) — 字符串</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%B8%89)%20%E2%80%94%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(三) — 字符串/</id>
    <published>2019-11-04T03:46:14.670Z</published>
    <updated>2019-11-06T03:49:35.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、String的不可变性"><a href="#一、String的不可变性" class="headerlink" title="一、String的不可变性"></a>一、String的不可变性</h1><p>咱们先来看一下String类中一些关键的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    /` The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    /` Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>从上面代码中,首先知道的是String实际上内部维护的是<code>char数组</code>。这个数组和String一样，都用<code>final</code>修饰，证明String是不可变的和不可被继承的。也就是说,一旦String对象被创建，那么内部的<code>成员变量的值</code>包括<code>基本数据类型</code>都不能被改变,不能指向其他对象，指向的<code>对象的状态</code>也不能被改变。</p><p>那么这样设计的好处有什么呢?原因有以下</p><ol><li>只有当String是不可变时，<code>String常量池</code>才有可能实现,并且为heap节省了空间</li><li><code>网络安全</code>,否则黑客可以改变String指向的对象的值而造成安全漏洞问题</li><li><code>线程安全</code>,可以被多个线程共享</li><li><code>性能</code>,因为String不可变，所以String创建时的<code>hashcode也具有唯一性</code>，作为Map的键时比其他键对象快</li></ol><h1 id="二、常量池"><a href="#二、常量池" class="headerlink" title="二、常量池"></a>二、常量池</h1><blockquote><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即<code>String Constant Pool(字符串常量池)</code></p></blockquote><p><code>常量池底层</code>方法是 <code>String#intern()</code> 使用StringTable数据结构保存字符串引用。StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中<code>HashMap</code>相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， <code>String#intern()</code> 的性能由O(1)退化到O(n)。</p><blockquote><p>深入解析String#intern<br><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote><p>在<code>JDK6</code>的版本中，String Pool使用固定容量的<code>HashMap</code>实现并存储在<code>永久代</code>中的，后面变为可配置，因为永久带内存有限，所以在<code>JDK7</code>开始就移动到<code>heap(堆内存)</code>中,这就意味着你可以通过调整堆大小来调整应用程序,通过<code>JVM参数-XX:StringTableSize</code>可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好</p><hr><p>创建字符串对象的方式有两种</p><ol><li>通过字面常量赋值</li><li>通过new关键字新建字符串对象</li></ol><p>这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么</p><h2 id="1、字面常量赋值"><a href="#1、字面常量赋值" class="headerlink" title="1、字面常量赋值"></a>1、字面常量赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"ab"</span>+<span class="string">"c"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的<br>String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”;</p></blockquote><p>采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的<code>s1和s2</code>指向的都是同一个对象，用 <code>==</code> 比较就会返回<code>true</code>,我们也可以通过<code>字节码</code>来进一步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt; </span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当调用<code>ldc #2</code>,如果 <code>#2</code> 的symbol还没解析，则会调用C++底层的 <code>StringTable::intern</code> 方法生成char数组，并将引用保存在 <code>StringTable和常量池中</code>，当下次调用 <code>ldc #2</code>,通过将常量池中 <code>#2</code>对应的字符串推送到栈顶获取到 <code>&quot;abc&quot;</code>，避免再次到StringTable中查找。<code>astore_1</code> 将 <code>&quot;abc&quot;</code> 保存到 <code>局部变量</code></p><h2 id="2、使用new关键字新建"><a href="#2、使用new关键字新建" class="headerlink" title="2、使用new关键字新建"></a>2、使用new关键字新建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们来分析一下发生了什么<br>①因为”abc”是用<code>字面常量</code>定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入<br>②由于使用了<code>new</code>，所以JVM会在 <code>heap(堆)</code> 中创建一个内容相同的String对象，然后返回堆中String对象的引用</p><p>下面是new String(“abc”)字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 ldc #3 &lt;abc&gt;  </span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>所以<code>s3</code>指向的是<code>堆</code>中的对象，<code>s4</code>指向的是<code>常量池</code>中的对象,虽然内容相同，但是<code>==</code>比较的是对象，所以为<code>false</code></p><h2 id="3、使用变量连接的情况"><a href="#3、使用变量连接的情况" class="headerlink" title="3、使用变量连接的情况"></a>3、使用变量连接的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>重点在s6,因为s5是一个变量，即使我们知道这个值，但是JVM仍然认为这是一个变量，所以在<code>编译期</code>，这个值是<code>未知</code>的。在运行期，JVM就在 <code>heap(堆)</code> 中创建了一个内容为”abc”的对象并返回给s6<br>而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现.</p><p>下面是字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;ab&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> 3 new #3 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">14 ldc #6 &lt;c&gt;</span><br><span class="line">16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>从字节码中也可以看出来，字符串变量的<code>连接</code>动作，在编译期会被转化成<code>StringBuilder的append操作</code></p><h2 id="4、使用final关键字修饰String"><a href="#4、使用final关键字修饰String" class="headerlink" title="4、使用final关键字修饰String"></a>4、使用final关键字修饰String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String s7 = <span class="string">"ab"</span>;</span><br><span class="line">String s8 = s7 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>在这种情况下,<code>final</code>修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc”</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;ab&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #3 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><h1 id="三、StringBuilder和StringBuffer"><a href="#三、StringBuilder和StringBuffer" class="headerlink" title="三、StringBuilder和StringBuffer"></a>三、StringBuilder和StringBuffer</h1><ol><li>String是字符串 <code>常量</code>，而 StringBuilder和StringBuffer都是字符串 <code>变量</code></li><li>StringBuilder是 <code>线程不安全</code> 的，而StringBuffer是 <code>线程安全</code> 的(append方法使用了synchronized修饰)，所以StringBuilder的效率比StringBuffer高</li><li>String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认<code>16个字节数组</code>的大小。扩容就<code>原来的大小 x 2 + 2</code>,可以考虑初始化StringBuilder的大小来提高代码的效率。</li></ol><h1 id="四、一些题目"><a href="#四、一些题目" class="headerlink" title="四、一些题目"></a>四、一些题目</h1><p>下面程序运行的结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//false String的equals有对参数进行instance of String判断</span></span><br><span class="line"></span><br><span class="line">StringBuffer s3 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s3.equals(<span class="string">"abc"</span>));  <span class="comment">//StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是</span></span><br><span class="line">System.out.println(s3.toString().equals(<span class="string">"abc"</span>)); <span class="comment">//true 比较的是值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">0</span>));   <span class="comment">//true,如果subString的index是0，直接返回对象</span></span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">1</span>));   <span class="comment">//false,不为0就new一个sub之后的对象返回</span></span><br></pre></td></tr></table></figure></p><p>除此之外,<code>toLowerCase</code>和<code>toUpperCase</code>都是new一个对象返回</p><hr><p>下面语句一共创建了多少个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure></p><p>这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是<code>两个</code>,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、String的不可变性&quot;&gt;&lt;a href=&quot;#一、String的不可变性&quot; class=&quot;headerlink&quot; title=&quot;一、String的不可变性&quot;&gt;&lt;/a&gt;一、String的不可变性&lt;/h1&gt;&lt;p&gt;咱们先来看一下String类中一些关键的代码&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(二) — 基本数据类型.md</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%BA%8C)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(二) — 基本数据类型/</id>
    <published>2019-11-04T03:45:52.262Z</published>
    <updated>2019-11-06T03:49:35.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h2><p>以下是八大基本数据类型大小、取值、默认值、对应包装类信息</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">大小</th><th style="text-align:center">封装类</th><th style="text-align:center">默认值</th><th style="text-align:center">可表示数据范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Byte</td><td style="text-align:center">0</td><td style="text-align:center">-128~127(2^7)</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Short</td><td style="text-align:center">0</td><td style="text-align:center">-32768~32767(2^15)</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Integer</td><td style="text-align:center">0</td><td style="text-align:center">-2147483648 ~ 2147483647(2^31)</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Long</td><td style="text-align:center">0L</td><td style="text-align:center">-9223372036854775808 ~ 9223372036854775807 (2^63)</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Float</td><td style="text-align:center">0F</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Double</td><td style="text-align:center">0D</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Character</td><td style="text-align:center">空</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Boolean</td><td style="text-align:center">false</td><td style="text-align:center">true或false</td></tr></tbody></table><blockquote><p>包装类有对应最小值、最大值和大小的常量,如:<br><code>Integer.MIN_VALUE</code><br><code>Integer.MAX_VALUE</code><br><code>Integer.SIZE</code></p></blockquote><p>进一步可以分为以下<code>四类</code></p><ul><li>整型：byte(字节型)、short(短整型)、int(整型)、long(长整型)</li><li>浮点型：float(单精度浮点型)、double(双精度浮点型) </li><li>逻辑型：boolean(布尔型)</li><li>字符型：char(字符型)</li></ul><h2 id="二、数据类型转换"><a href="#二、数据类型转换" class="headerlink" title="二、数据类型转换"></a>二、数据类型转换</h2><p>根据<code>取值范围的大小</code>将数据类型排序,数据类型的转换也跟这个排序有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">short</span> -&gt; <span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>数据类型之间的转换分为两种<code>自动转换</code>和 <code>强制转换</code></p><h3 id="1、自动转换"><a href="#1、自动转换" class="headerlink" title="1、自动转换"></a>1、自动转换</h3><p>在表达式中,当较”小”的数据与较”大”的数据一起进行运算时，系统会自动将”小”的数据转换成”大”的数据再进行运算<br>在调用方式时,如果<code>实参比形参&quot;小&quot;</code>,也会将”小”的数据转换成”大”的数据</p><p>在表达式中，数据类型会出现<code>自动提升</code>，规则如下</p><ol><li>所有的byte,short,char的值将被提升为int</li><li>如果有一个操作数是long，计算结果是long</li><li>如果有一个操作数是float，计算结果是float</li><li>如果有一个操作数是double，计算结果是double</li></ol><h3 id="2、强制转换"><a href="#2、强制转换" class="headerlink" title="2、强制转换"></a>2、强制转换</h3><p>将”大”数据转换成”小”数据时，就需要强制转换,并且会损失精度</p><h2 id="三、包装类"><a href="#三、包装类" class="headerlink" title="三、包装类"></a>三、包装类</h2><p>java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在<code>栈中分配空间</code>,存储数值<br>包装类是对象，需要在<code>堆内存中分配空间</code>,栈中存放着对应的堆空间地址</p><p>在JDK1.5以后，提供了<code>自动装箱</code>和<code>自动拆箱</code>功能这样的”语法糖”</p><h3 id="1、自动装箱"><a href="#1、自动装箱" class="headerlink" title="1、自动装箱"></a>1、自动装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自动装箱</span></span><br><span class="line">Integer i = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//转换成了</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException</span></span><br></pre></td></tr></table></figure><p>从字节码看出也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> iconst_1</span><br><span class="line"> 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">9</span> astore_2</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="2、自动拆箱"><a href="#2、自动拆箱" class="headerlink" title="2、自动拆箱"></a>2、自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="comment">//后面一句转换成了</span></span><br><span class="line"><span class="keyword">int</span> j = i.intValue();</span><br></pre></td></tr></table></figure><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> aload_1</span><br><span class="line"> 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"> <span class="number">9</span> istore_2</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"><span class="number">14</span> istore_3</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>由此也可以看出，自动拆装箱属于<code>编译特性</code></p><h3 id="3、缓存池"><a href="#3、缓存池" class="headerlink" title="3、缓存池"></a>3、缓存池</h3><p>在包装类中,为了<code>避免频繁地创建和销毁对象</code>，就有缓存池的出现，下面是各个包装类对应缓存池的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>根据代码可以得知包装类的缓存池规则</p><ul><li><code>Byte</code>都是用缓存池里面的值</li><li><code>Short、Integer、Long</code>会缓存 <code>-128~127</code></li><li><code>Float和Double</code>则直接返回，因为精度数不能每次都一样，所以缓存没有意义</li><li><code>Character</code>则是缓存 <code>&lt;=127</code></li><li><code>Boolean</code>,只有两个值，直接就用常量的形式表示出来</li></ul><h2 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h2><ul><li>double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是<code>false</code>,所以在进行带精度计算时，需要用到<code>BigDecimal</code></li><li>switch中只能用byte、char、short、int，JDK1.7后可用String</li><li>Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型</li><li>两边都是包装类的<code>equals</code>比较值，<code>==</code> 比较引用，其中一边是表达式的，<code>==</code> 就是比较值</li><li>char存储的是<code>unicode编码字符</code>，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(<a href="https://blog.csdn.net/BuquTianya/article/details/80685437" target="_blank" rel="noopener">拓展资料</a>)</li></ul><h2 id="五、题目"><a href="#五、题目" class="headerlink" title="五、题目"></a>五、题目</h2><p>下面语句做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>; <span class="comment">//valueOf()自动装箱成Integer类型</span></span><br><span class="line">i+=<span class="number">1</span>;<span class="comment">//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer</span></span><br></pre></td></tr></table></figure></p><hr><p>下面程序语句有什么问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;  <span class="comment">//编译不通过、需要强转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s2 =<span class="number">1</span>;</span><br><span class="line">s2 += <span class="number">1</span>;  <span class="comment">//正常编译,自动做了类型转换</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//NullPointException</span></span><br></pre></td></tr></table></figure></p><hr><p>下面程序的运行结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//false 比较了对象</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//true 缓存了-128~127</span></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="number">1f</span>;</span><br><span class="line">Float f2 = <span class="number">1f</span>;</span><br><span class="line">System.out.println(f1 == f2) <span class="comment">//false 始终new新对象</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本信息&quot;&gt;&lt;a href=&quot;#一、基本信息&quot; class=&quot;headerlink&quot; title=&quot;一、基本信息&quot;&gt;&lt;/a&gt;一、基本信息&lt;/h2&gt;&lt;p&gt;以下是八大基本数据类型大小、取值、默认值、对应包装类信息&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;

      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础(一) — 语法</title>
    <link href="http://yoursite.com/2019/11/04/Java%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E2%80%94%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/04/Java基础(一) — 语法/</id>
    <published>2019-11-04T03:45:24.520Z</published>
    <updated>2019-11-06T03:49:35.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、面向对象的四大特性"><a href="#一、面向对象的四大特性" class="headerlink" title="一、面向对象的四大特性"></a>一、面向对象的四大特性</h1><h2 id="1、继承性"><a href="#1、继承性" class="headerlink" title="1、继承性"></a>1、继承性</h2><p>继承性是类的一种层次模型，提供了明确表述<code>共性</code>的方法,对象的新类在类中继承派生。类可以从他的基类<code>继承</code>方法和实例变量，并且类可以<code>修改或者增加</code>新的方法使之更适合特殊的需要</p><p><code>关键字:extends、class</code></p><h2 id="2、多态性"><a href="#2、多态性" class="headerlink" title="2、多态性"></a>2、多态性</h2><p>多态性是对象在<code>不同时刻</code>表现出来的多种状态,是一种<code>编译时期状态</code>和<code>运行时期状态</code>不一致的现象，多态包括<code>参数多态</code>和<code>包含多态</code></p><p><code>关键字:interface</code></p><h2 id="3、抽象性"><a href="#3、抽象性" class="headerlink" title="3、抽象性"></a>3、抽象性</h2><p>抽象是指对一类事物的高度提炼以得到的<code>共性</code>部分,抽象不需要了解全部细节，只是一种通用的描述<code>约束</code>,抽象可以是<code>过程抽象</code>或者<code>数据抽象</code></p><p><code>关键字:abstract</code></p><h2 id="4、封装性"><a href="#4、封装性" class="headerlink" title="4、封装性"></a>4、封装性</h2><p>封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的<code>隐私性和可靠性</code></p><blockquote><p>面向对象的特性:更多的实践使用就是设计模式</p></blockquote><h1 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h1><h1 id="三、基础修饰符"><a href="#三、基础修饰符" class="headerlink" title="三、基础修饰符"></a>三、基础修饰符</h1><h2 id="1、权限修饰符"><a href="#1、权限修饰符" class="headerlink" title="1、权限修饰符"></a>1、权限修饰符</h2><ul><li><code>private</code>:只能在定义它们的类中使用，在其他类中不能调用。</li><li><code>缺省(default)</code>:只能在定义它们的类中，以及同包的类中被调用</li><li><code>protected</code>:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类</li><li><code>public</code>:可以在任何一个类中被调用</li></ul><h2 id="2、final"><a href="#2、final" class="headerlink" title="2、final"></a>2、final</h2><p>①<code>类</code>被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final</p><p>②<code>变量</code>被声明为final,必须在声明时初始化，且只能读取不能修改</p><p>③<code>方法</code>被声明为final,不能被<code>重载</code></p><blockquote><p>一般会使用final和static组合来定义常量</p></blockquote><h2 id="3、static"><a href="#3、static" class="headerlink" title="3、static"></a>3、static</h2><p><code>static</code>可以用来修饰的类成员变量、成员方法、代码块,将独立于对象</p><ol><li>被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问)</li><li><code>静态方法</code>不能访问类的非静态方法和成员变量</li><li><code>静态成员变量</code>会被所有的对象<code>共享</code></li><li><code>静态代码块</code>会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作</li></ol><p>关于static还有一个<code>类内元素加载顺序</code>的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个构造代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    Block(String who) &#123;</span><br><span class="line">        System.out.println(who+<span class="string">" new"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义一个父类    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Block staticblock = <span class="keyword">new</span> Block(<span class="string">"father static"</span>);</span><br><span class="line">    Block block = <span class="keyword">new</span> Block(<span class="string">"father"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"father block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(<span class="string">"father  constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Block staticblock = <span class="keyword">new</span> Block(<span class="string">"son static"</span>);</span><br><span class="line">     Block block = <span class="keyword">new</span> Block(<span class="string">"son"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"son block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        System.out.println(<span class="string">"son constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">father <span class="keyword">static</span> <span class="keyword">new</span></span><br><span class="line">father <span class="keyword">static</span> block</span><br><span class="line">son <span class="keyword">static</span> <span class="keyword">new</span></span><br><span class="line">son <span class="keyword">static</span> block</span><br><span class="line">father <span class="keyword">new</span></span><br><span class="line">father block</span><br><span class="line">father constructor</span><br><span class="line">son <span class="keyword">new</span></span><br><span class="line">son block</span><br><span class="line">son constructor</span><br></pre></td></tr></table></figure></p><p>可以看出加载顺序是</p><ol><li>父类静态成员变量</li><li>父类静态代码块</li><li>子类静态成员变量</li><li>子类静态代码块</li><li>父类非静态成员变量</li><li>父类非静态代码块</li><li>父类构造方法</li><li>子类非静态成员变量</li><li>子类非静态代码块</li><li>子类构造方法</li></ol><p>由此也可以得知<br>执行子类构造方法之前，如果没有用 <code>super()</code> 来调用父类<code>特定的构造方</code>法，则会调用父类中<code>没有参数的构造方法</code>。因此，如果父类中只定义了<code>有参数的构造方法</code>，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误</p><h2 id="4、this和super"><a href="#4、this和super" class="headerlink" title="4、this和super"></a>4、this和super</h2><p><code>this</code>为当前类的引用对象，应用场景</p><ul><li>构造方法:通过this的调用同类中指定参数类型的构造方法<code>this(参数列表)</code>,只能用在构造方法体的第一行</li><li>变量:当成员变量与局部变量重名，使用this特指<code>成员变量</code></li><li>方法:在方法中引用该方法所属类的当前对象，注意不能用于static方法(this对象级别，static类级别)</li></ul><hr><p><code>super</code>为父类存储空间标识</p><ul><li>构造方法:在子类构造方法中调用父类构造方法<code>super(参数列表)</code>,同样只能在构造方法体的第一行</li></ul><h2 id="5、instance-of"><a href="#5、instance-of" class="headerlink" title="5、instance of"></a>5、instance of</h2><p>instance of运算符是用来在运行时指出对象是否是特定类的一个实例</p><h1 id="四、方法的重写和重载"><a href="#四、方法的重写和重载" class="headerlink" title="四、方法的重写和重载"></a>四、方法的重写和重载</h1><h2 id="1、重写"><a href="#1、重写" class="headerlink" title="1、重写"></a>1、重写</h2><p>子类对<code>父类允许访问的方法</code>的方法体进行覆盖并重新实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line"></span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、重载"><a href="#2、重载" class="headerlink" title="2、重载"></a>2、重载</h2><p>重载是在一个类里面，方法名字相同,而<code>参数的类型和个数</code>不同的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="五、变长参数"><a href="#五、变长参数" class="headerlink" title="五、变长参数"></a>五、变长参数</h1><p>在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用<code>...</code>表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、自增自减运算符"><a href="#六、自增自减运算符" class="headerlink" title="六、自增自减运算符"></a>六、自增自减运算符</h1><p>这里主要需要注意一个陷阱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>count++是一个有返回值的表达式，<code>返回值</code>是count自加之前的值，具体步骤是</p><ol><li>JVM把count值拷贝到临时变量区(0)</li><li>count值加1,此时count为(1)</li><li>返回临时变量区的值(0)</li><li>此时count被重置为0</li></ol><p>也就是不管count = count++多少次，count的值,都是一样。 </p><p>Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全</p><ol><li>synchronized代码块或者方法</li><li>使用Lock锁</li><li>使用JDK提供的线程安全类<code>AtomicInteger</code>(推荐)</li></ol><h1 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h1><h2 id="1、-与-equals"><a href="#1、-与-equals" class="headerlink" title="1、== 与 equals"></a>1、== 与 equals</h2><p><code>==</code>:基础数据类型比较的是<code>值</code>，引用比较的是内存地址，即两个对象是否同一个<br><code>equals</code>:默认情况下，equals的作用与<code>==</code>一样是比较对象。<br>有些类会将equals方法重写，如<code>String</code>重写比较的是对象的值</p><h2 id="2、equals-与-hashCode"><a href="#2、equals-与-hashCode" class="headerlink" title="2、equals 与 hashCode"></a>2、equals 与 hashCode</h2><p><code>hashCode</code>方法定义在Object.java中，说明任何一个Java类都有<code>hashCode</code>方法<br>hashCode的作用是获取哈希码,特点是能够根据”key”迅速获取对应的”value”,而且hashCode相等的两个对象不一定相等(碰撞)，所以比较两个对象是否相等时</p><ol><li>先判断hashCode是否存在相同的</li><li>发现了相同hashCode的对象才会时候equals去判断</li></ol><p>这样会大大减少equals使用的频率，提高执行速度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、面向对象的四大特性&quot;&gt;&lt;a href=&quot;#一、面向对象的四大特性&quot; class=&quot;headerlink&quot; title=&quot;一、面向对象的四大特性&quot;&gt;&lt;/a&gt;一、面向对象的四大特性&lt;/h1&gt;&lt;h2 id=&quot;1、继承性&quot;&gt;&lt;a href=&quot;#1、继承性&quot; class
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/11/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/11/02/类加载机制/</id>
    <published>2019-11-02T01:17:51.419Z</published>
    <updated>2019-11-02T01:46:52.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>从被加载到虚拟机内存中开始到卸载出内存为止，生命周期包括<code>七个阶段</code></p><ol><li>加载(loading)</li><li>验证(Verification)</li><li>准备(Preparation)</li><li>解析(Resolution)</li><li>初始化(Initialization)</li><li>使用(Using)</li><li>卸载(Unloading)</li></ol><p>其中验证、准备、解析三部分称为<code>连接</code></p><p>为了支持Java语言的<code>运行时绑定</code>，某些情况下<code>解析阶段</code>会在初始化之后开始</p><p>虚拟机规范严格规定，出来下列五种情况，虚拟机必须对类进行初始化</p><ol><li>遇到new、getstatic、putstatic和invokestatic这4条字节码指令时</li><li>使用java.lang.reflect包的方法对类进行反射调用时</li><li>初始化一个类时，发现父类没有初始化,先初始化父类</li><li>虚拟机启动时,用户需要制定一个要执行的主类</li><li>MethodHandle实例解析出REF_getStatic,REF_putStatic,REF_invokeStatic方法句柄，对应的类未初始化</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>类和数组类加载</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了确保Class文件的字节流包含的信息符合当前虚拟机的要求<br>验证阶段大致上会完成下面4个阶段的检验动作</p><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink&quot; title=&quot;类加载的时机&quot;&gt;&lt;/a&gt;类加载的时机&lt;/h1&gt;&lt;p&gt;从被加载到虚拟机内存中开始到卸载出内存为止，生命周期包括&lt;code&gt;七个阶段&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/31/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/10/31/类文件结构/</id>
    <published>2019-10-31T07:57:16.076Z</published>
    <updated>2019-11-02T01:16:53.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h1><p>Class文件是一组以<code>8位字节为基础单位的二进制流</code>,各个数据紧凑地排列，中间没有任何分割符，需要占用8位以上的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储</p><p>Class文件格式采用类似于C语言结构体的伪结构存储数据，且只有两种数据类型<code>无符号数</code>和<code>表</code><br>无符号数属于基本数据类型，使用u1,u2,u4,u8分别代表1一个字节，2个字节，4个字节，8个字节的无符号数<br><code>无符号数</code>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值<br><code>表</code>是由多个无符号数或者其他表作为数据项构成的复合数据类型,表是由<code>_info</code>结尾,用于描述有层次关系的符合结构数据，整个Class文件本质上就是一张表<br><img src="/media/15725148670004.jpg" alt=""></p><h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><p>每个Class文件的头4个字节称为魔数字，唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件,用作身份识别。他的值为<code>0xCAFEBABE</code>，魔数的4个字节存储的Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号,Java的版本号是从45开始的</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着主版本号的是常量池入口，这个可以理解为Class文件的资源仓库,于其他项目关联最大，并且占用空间最大。<br>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值<br>常量池第0项空出来的，目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义。Class文件结构中只有这个是从1开始计数的</p><p>常量池中主要存放两大类常量</p><ol><li>字面量(Literal)</li><li>符号引用(Symbolic References)<br>字面量接近Java语言常量的概念，符号引用属于编译原理方面的概念,包含了下面三类常量</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol><p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。</p><p>常量池的14种表类型,它们有一个共同特点，开始的第一位是一个u1类型的标志位tag，表示属于哪种常量类型。<br><img src="/media/15725694254619.jpg" alt=""></p><p>各个常量表的字段及其表示含义<br><img src="/media/15725697493569.jpg" alt=""><br><img src="/media/15725697573646.jpg" alt=""></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>接下来就是访问标志<br><img src="/media/15725698605350.jpg" alt=""></p><h2 id="类索引、父类索引与接口索引"><a href="#类索引、父类索引与接口索引" class="headerlink" title="类索引、父类索引与接口索引"></a>类索引、父类索引与接口索引</h2><p>类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合。Class文件中由这三项数据来确定这个类的继承关系。<br>类索引用于确定这个类的全限定名<br>父类索引用于确定这个类的父类的全限定名</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述<code>接口或类</code>中声明的变量。字段包括类级变量以及实例级变量</p><p>字段表结构<br><img src="/media/15726572673399.jpg" alt=""></p><p>字段访问标志<br><img src="/media/15726572833906.jpg" alt=""></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p><img src="/media/15726573982729.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类结构&quot;&gt;&lt;a href=&quot;#类结构&quot; class=&quot;headerlink&quot; title=&quot;类结构&quot;&gt;&lt;/a&gt;类结构&lt;/h1&gt;&lt;p&gt;Class文件是一组以&lt;code&gt;8位字节为基础单位的二进制流&lt;/code&gt;,各个数据紧凑地排列，中间没有任何分割符，需要占用8位以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/30/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/30/垃圾收集器/</id>
    <published>2019-10-30T13:04:20.382Z</published>
    <updated>2019-10-31T07:01:42.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>最原始的收集器，用于新生代,单线程,没有线程交互的开销<br>对于用在Client模式下的虚拟机是一个很好的选择</p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>这个实际上就是Serial收集器的多线程版本<br>对于用在Server模式下的虚拟机的首选<br>而且除了Serial收集器以外，只有ParNew能于CMS收集器(并发收集器)配合工作</p><blockquote><p>并行:指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态<br>并发:指用户线程与垃圾收集线程同时执行(不一定并行，可能交替执行),用户线程在继续运行，而垃圾收集程序运行于另一个CPU上</p></blockquote><h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>使用复制算法的新生代收集器,并行多线程<br>这个收集器关注点是达到一个可控制的<code>吞吐量</code></p><blockquote><p>吞吐量:CPU用于运行用户代码的时间与CPU总消耗时间的比值<br>即,吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote><p>停顿时间越短越适合需要与用户交互的程序<br>高吞吐量则可以高效率地利用CPU时间，尽快完成运算任务</p><p>提供了两个参数用于精确控制吞吐量</p><ol><li>最大垃圾收集停顿时间-XX:MaxGCPauseMillis</li><li>设置吞吐量大小-XX:GCTimeRatio</li></ol><p>停顿时间越少，吞吐量就越少</p><p><code>-XX:UseAdaptiveSizePolicy</code>是一个开关参数<br>会动态调整新生代的大小Eden与Survivor的比例，晋升老年代对象的年龄-XX:PretenureSizeThreshold,达到最合适的停顿时间或最大吞吐量,称为GC自适应的调节策略</p><h1 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h1><p>这是Serial收集器的老年代版本，单线程，使用”标记-整理”算法<br>主要也是给Client模式下的虚拟机使用</p><h1 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h1><p>Parallel Scavenge的老年代版本，使用多线程和”标记-整理”算法</p><blockquote><p>注意吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old </p></blockquote><h1 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h1><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器<br>重视服务的相应速度，希望系统停顿时间最短，给用户带来较好的体验，CMS就非常符合这类应用</p><p>CMS是基于”标记-清除”算法实现的,运作过程分为4个步骤</p><ol><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ol><p>CMS的缺点,</p><ol><li><code>对CPU资源非常敏感</code>，事实上并发设计的程序对CPU资源都比较敏感，并发虽然不会导致用户线程停顿，但是会因为占用了一些CPU资源而导致程序变慢，总吞吐量会降低。   <code>CMS默认启动的回收线程数是(CPU数量+3)/4</code>,也就是当CPU在4个以上时，将占用25%的CPU资源。CPU数越少，影响越大。于是出现了<code>增量式并发收集器/i-CMS</code>,也就是让GC线程和用户线程交替运行，尽量较少GC线程的独占资源的时间，垃圾回收时间会更长，但是对用户程序的影响就会显得少一些,速度下降没那么明显,但是效果一般</li><li>无法处理<code>浮动垃圾</code>。浮动垃圾就是GC过程中用户线程并发产生的垃圾，当次不能处理，只能留到下次。也是由于在垃圾收集阶段用户信息还需要运行，那么就需要预留空间给用户线程使用,因此不能等老年代几乎被塞满了再收集。参数<code>-XX:CMSInitiatingOccupancyFraction</code>调高可以降低内存回收次数获得更好的性能。过高的话，内存无法满足程序运行，就会取用Serial Old</li><li>标记-清除算法带来的碎片。CMS提供了-XX:UserCMSCompactAtFullCollection开关(默认开启),在CMS要Full GC的时候做碎片整理，碎片整理是无法并发的，所以停顿时间会加长，-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，再执行一次压缩的(默认0，每次进入Full GC都进行碎片整理)</li></ol><h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>与其他收集器相比,G1具备如下特点。</p><ol><li>并发与并行:能通过多个CPU来缩短停顿时间,并且能通过并发的方式让Java程序继续执行</li><li>分代收集:G1不需要其他收集器配合就能独立管理整个GC堆</li><li>空间整合</li><li>可预测的停顿</li></ol><p>Java对的内存布局与其他收集器有很大的差别<br>它将<code>整个</code>Java堆划分为多个<code>大小相等的独立区域</code>，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分区域的集合</p><p>可预测的停顿时间模型是因为可以避免对这个Java堆进行垃圾收集，G1会跟踪分析回收价值最大的一个Region，维护一个优先列表，按优先级回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Serial收集器&quot;&gt;&lt;a href=&quot;#Serial收集器&quot; class=&quot;headerlink&quot; title=&quot;Serial收集器&quot;&gt;&lt;/a&gt;Serial收集器&lt;/h1&gt;&lt;p&gt;最原始的收集器，用于新生代,单线程,没有线程交互的开销&lt;br&gt;对于用在Client模
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/30/HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/30/HotSpot的垃圾回收算法实现/</id>
    <published>2019-10-30T02:11:14.271Z</published>
    <updated>2019-10-30T13:02:43.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h1><p>在可达性分析中，可作为GC Roots的节点主要在<code>全局性的引用(常量或类静态属性)与执行上下文(栈帧中的局部变量表)</code>中<br>但是现在应用仅仅方法区就数百兆，要逐个检查完，那么必然消耗很多时间。</p><p>而且在这个工作还需要进行GC停顿，因为这项分析工作必须能<code>保持一致性</code>，就是不可以在分析过程中对象的关系还在变化</p><p>目前主流的Java虚拟机使用的都是准确式GC，也就是当执行系统停顿下来后，虚拟机有办法直接得知哪些方法存放着这些对象引用，hotspot中使用一组称为<code>OopMap</code>的数据结构来达到这个目的。<br>在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就直接知道这些信息了。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>需要关注的一个点事，如果为每一条指令都生成对应的OopMap，会需要大量的额外空间,但是hotspot很显然并没有这样做，只是在<code>特定的位置</code>记录了这些信息，而这些位置称为安全点。即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p><p>安全点选定的标准是，<code>是否具有让程序长时间运行的特征</code></p><p>另外一个需要考虑的问题，如何在GC发生时让所有线程，都跑到最近的安全点上再停顿下来，两种方案</p><ol><li>抢先式中断<br>GC发生时，把所有的线程中断，如果现有的线程中断不在安全点上，就恢复线程让它跑到安全点上(弃用)</li><li>主动式中断<br>设置一个标志，各个线程在执行时主动去轮询这个标志，发现中断标志就自挂东南枝。<br>实际情况会有线程处于block或sleep的状态,无法走到中断标志，这时候就需要<code>安全区域</code></li></ol><p>安全区域指的是，在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;枚举根节点&quot;&gt;&lt;a href=&quot;#枚举根节点&quot; class=&quot;headerlink&quot; title=&quot;枚举根节点&quot;&gt;&lt;/a&gt;枚举根节点&lt;/h1&gt;&lt;p&gt;在可达性分析中，可作为GC Roots的节点主要在&lt;code&gt;全局性的引用(常量或类静态属性)与执行上下文(栈帧中的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/29/JVM%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2019/10/29/JVM回收/</id>
    <published>2019-10-29T02:46:58.393Z</published>
    <updated>2019-10-30T02:07:36.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h1><p>主流的实现中使用的都是<code>可达性分析(Reachability Analysis)</code></p><p>基本思想是,以一系列称为<code>GC Roots</code>的对象作为起始点,从这些节点往下开始搜索，搜索所走过的路称为<code>引用链</code>,当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用</p><p>在Java语言中,可作为GC Roots的对象包括</p><ol><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol><p>即使通过可达性分析算法中<code>不可达的对象</code>，并非”非死不可”。<br>真正要宣告一个对象死亡，至少要经历两次标记过程</p><p>通过可达性分析被发现不可达后就会被标记，并且进行一次筛选<br>筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，判断条件如下</p><ol><li>当对象没有覆盖finalize方法</li><li>已经被虚拟机执行过了</li></ol><p>这两种情况都没有必要执行</p><p>如果对象被判断有必要执行，那么这个对象就会被放置到一个<code>F-Queue</code>中，并且由虚拟机创建一个低优先级的Finalizer执行。注意这里只会是触发，不会等待运行结束。</p><p>如果在finalize过程中与引用链中的对上建立了联系，那么这个对象就不会被回收。<br>反之则会被第二次标记，进行回收</p><p>需要注意的是，任何对象的<code>finalize</code>方法只会被执行一次，面对下一次回收就不会被执行了</p><h2 id="回收方法区-永久代"><a href="#回收方法区-永久代" class="headerlink" title="回收方法区(永久代)"></a>回收方法区(永久代)</h2><p>永久代的垃圾回收主要回收两部分</p><ol><li>废弃常量</li><li>无用的类</li></ol><p>废弃常量，以常量池中的字面量为例，<br>比如字符串“abc”,如果当前系统中没有任何一个String对象是”abc”,那就会被清出常量池</p><p>要清出无用的类需要满足下面3个条件</p><ol><li>该类所有的实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问</li></ol><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>分为”标记”和”清除”两个阶段。首先标记处所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记的算法就是之前说的可达性算法。</p><p>这是最基础的收集算法,因为后续的算法都是基于这种思路并且对其不足进行优化，主要的不足有两个</p><ol><li>效率<br>标记和清除两个过程的效率都不高</li><li>空间<br>标记清除之后会产生大量不连续的内存碎片。空间碎片太多会到导致后面需要分配大对象时，无法获得连续的内存而不得触发另一次垃圾回收</li></ol><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题而出现，它将可用内存按容量划分为<code>相等大小的两块</code>，每次只使用其中一块，当着一块用完了，就把存活的对象复制到另一快，然后把使用过的内存空间一次清理</p><p>目前的商业虚拟机都采用的这种手机算法来回收新生代<br>将内存分为一块较大的<code>Eden空间和两块小的Survivor</code>,每次使用Eden和其中一块Survivor<br>当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一个Survivor，最后清理Eden和之前的Survivor，Eden和Survivor的比例是8:1<br>因为无法保证回收时存活的对象少于10%，Survivor的空间不足时，需要依赖其他的内存进行<code>分配担保</code><br>那么这些对象将直接通过分配担保机制进入老年代。<del>~</del>to be continue</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时，需要较多的复制操作，效率会变低。<br>另外，如果不想浪费50%的空间，就需要额外的空间做分配担保，应对对象100%存活率的极端<br>标记还是使用可达性算法，整理是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>一般是把Java堆分为新生代和老年代<br>新生代，每次垃圾手机时都发现有大批对象死去，只有少量存活，那就复制<code>复制算法</code><br>老年代，因为存活率高，没有额外的空间分配担保，必须使用<code>标记清理或标记整理算法</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断对象是否存活&quot;&gt;&lt;a href=&quot;#判断对象是否存活&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否存活&quot;&gt;&lt;/a&gt;判断对象是否存活&lt;/h1&gt;&lt;p&gt;主流的实现中使用的都是&lt;code&gt;可达性分析(Reachability Analysis)&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/28/JVM%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/10/28/JVM对象相关/</id>
    <published>2019-10-28T04:11:45.311Z</published>
    <updated>2019-10-28T14:02:21.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><h5 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h5><p>当虚拟机遇到一条new指令时(克隆，反序列化)，首先检查这个<code>指令的参数是否能在常量池</code>中定位到一个<code>类的符号引用</code>,检查有没有被加载,解析和初始化过，如果没有，在执行相应的类加载的过程（疑问）</p><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><p>接下来虚拟机会为新生对象<code>分配内存</code>，分配的方式有两种</p><ol><li>指针碰撞<br>内存规整，用指针分开已用内存和空闲内存</li><li>空闲列表<br>内存不规整，维护一个列表记录空闲的内存</li></ol><p>防止并发</p><blockquote><p>虚拟机会使用CAS配上失败重试的方式保持更新的原子性</p></blockquote><p>还有另外一种方法，在每个线程的Java栈中分配一小块内存，称为<code>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</code>，哪个线程需要分配内存，就在TLAB上分配，内存用完了,同步锁定<br>是否使用TLAB，可以通过 <code>-XX:+/-UserTLAB</code>参数设定</p><p>分配完成之后，分配到的内存空间都会被<code>初始化为零</code>,并且为<code>对象头赋值</code>,从虚拟机的层面来说已经创建完成了</p><p>接下来执行<code>&lt;init&gt;</code>方法，按照程序员的意愿进行初始化</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在内存中存储的布局可以分为3块区域:<code>对象头、实例数据、对齐填充</code></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头分两部分信息</p><ol><li>对象自身的运行时数据(Mark Word)<br>Hash码,GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时戳</li><li>类型指针，指向它的类元数据的指针</li></ol><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储着程序代码中定义的各种类型的字段内容,包括父类的。</p><p>存储顺序收到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java中定义的顺序影响<br>hotspot默认是longs/doubles,ints,shorts/chars,bytes/boolean,oops(Ordinary Object Pointers),也就是宽度的字段会分配到一起，在满足这个条件的情况下，父类定义的变量会在子类之前</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>这部分不是不然存在的，也没有特殊含义，起到占位符的作用，对象大小必须为8字节的倍数，不够就补齐</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过什么方式去定位<br>实际上主流的方式有两种</p><ol><li><p>使用句柄<br>这种方式会在Java堆中划分出一块内存作为句柄池,栈中的引用指向的就是对象的句柄地址<br>而句柄中包含了对象实例数据与类型数据各自的地址信息<br><img src="/media/15722712326856.jpg" alt=""></p></li><li><p>直接指针访问<br>这种方式存储的直接就是对象地址<br><img src="/media/15722712075007.jpg" alt=""></p></li></ol><p>两种方式各有优势，使用句柄访问好处是对象被移动的时候，只需要修改句柄的实例数据指针<br>直接指针访问最大的好处就是速度快</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h1&gt;&lt;h5 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/25/2019-10-25/"/>
    <id>http://yoursite.com/2019/10/25/2019-10-25/</id>
    <published>2019-10-25T04:01:25.815Z</published>
    <updated>2019-10-25T04:01:50.876Z</updated>
    
    <content type="html"><![CDATA[<p># </p><p>线程之间的通信机制有两种：共享内存和消息传递</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;p&gt;线程之间的通信机制有两种：共享内存和消息传递&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java多线程 - synchronized关键字 3.2</title>
    <link href="http://yoursite.com/2019/10/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%20-%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97%203.2/"/>
    <id>http://yoursite.com/2019/10/24/Java多线程 - synchronized关键字 3.2/</id>
    <published>2019-10-24T05:28:16.971Z</published>
    <updated>2019-11-04T03:38:55.720Z</updated>
    
    <content type="html"><![CDATA[<p><code>synchronized</code>的作用是保证方法或代码在运时，同一时刻只有一个方法可以进到<code>临界区</code>,同时还可以保证共享变量的内存可见性</p><p><code>synchronized</code>可修饰的对象有</p><ul><li>代码块synchronized(){}，范围是<code>大括号{}</code>括起来的部分,作用对象是小括号里的对象</li><li>方法，范围是<code>整个方法</code>,作用对象是调用这个方法的对象</li><li>静态方法,范围是<code>整个静态方法</code>,作用对象是这个类的所有对象</li><li>类，作用范围是<code>synchronized</code>后面括号部分，作用对象是类的所有对象</li></ul><h2 id="底层语义原理"><a href="#底层语义原理" class="headerlink" title="底层语义原理"></a>底层语义原理</h2><p>Java虚拟机中的同步基于<code>进入和退出monitor</code>对象实现,显式同步和隐式同步都是 (monitorenter和monitorexit指令)<br>二同步方法是由方法调用指令，读取运行时<code>常量池</code>中方法的<code>ACC_SYNCHRONIZED</code>标志来隐式实现的。<br>对理解synchronized原理来说，<code>Java对象头</code>的概念很重要</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在JVM中，对象在内存中的布局分为三块区域<code>对象头、实例数据、填充数据</code><br><img src="/media/15719044553160.jpg" alt=""></p><ul><li>实例变量:存放<code>类的属性</code>数据信息，包括父类的属性信息，数组还包括数组长度，按<code>4字节对齐</code></li><li>填充数据:由于虚拟机要求对象的起始地址必须是<code>8字节的倍数</code>,所以就有了填充,为了字节对齐</li></ul><p>JVM中采用<code>2个字</code>存储对象头(数组是<code>3个</code>,多一个记录数组长度)</p><p>其主要结构是由<code>Mark Word</code>和<code>Class Metadata Address</code>组成</p><table><thead><tr><th>虚拟机位数</th><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的HashCode、锁信息或分代年龄或GC标志</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，确认该对象是哪个类的实例</td></tr></tbody></table><p>各种锁状态下Mark Word存储情况</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit 是否是偏向锁</th><th>2bit 锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID(23bit) Epoch(2bit)</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向锁记录的指针</td><td>对象分代年龄</td><td>0</td><td>00</td></tr><tr><td>重量级锁</td><td>指向重量级锁的指针</td><td>对象分代年龄</td><td>0</td><td>10</td></tr><tr><td>GC标记</td><td>空</td><td>对象分代年龄</td><td>1</td><td>11</td></tr></tbody></table><p>synchronized在JDK1.6优化之后才出现<code>偏向锁和轻量级锁</code></p><hr><h1 id="synchronized的三种锁的状态及升级原理"><a href="#synchronized的三种锁的状态及升级原理" class="headerlink" title="synchronized的三种锁的状态及升级原理"></a>synchronized的三种锁的状态及升级原理</h1><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的意思是如果一个线程获取了一个偏向锁,在接下来的一段时间没有其他线程来竞争，那么持有偏向锁的线程再次进入同步代码时，<code>不再需要抢占锁和释放锁的操作</code></p><h3 id="偏向锁获取方式"><a href="#偏向锁获取方式" class="headerlink" title="偏向锁获取方式"></a>偏向锁获取方式</h3><ol><li>首先判断目标对象的对象头，根据<code>标识和epoch</code>判断是否处于可偏向状态</li><li>是的话，通过自旋锁的方式将自己的线程ID复制到对象头的Mark Work,继续执行</li><li>不是的话，判断自己的线程ID跟对象头Mark Work中的是否相等，相等证明已获得,继续执行不用进行竞争和释放操作</li><li>如果不相等，需要撤销偏向锁</li></ol><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>当偏向锁撤销，有两种情况 </p><ol><li>线程已经退出同步代码,接下来就是撤销偏向锁,升级为轻量级锁</li><li>线程正在执行同步代码，原来的线程会继续持有锁并且升级为轻量级锁</li></ol><h3 id="轻量级锁获取方式"><a href="#轻量级锁获取方式" class="headerlink" title="轻量级锁获取方式"></a>轻量级锁获取方式</h3><ol><li>JVM会在当前的线程<code>栈帧</code>中创建一个用于存储锁记录的空间</li><li>将对象头的Mark Work的记录复制到锁记录中</li><li>线程尝试用自旋锁的方式将对象头Mark Work替换为指向所记录空间的指针</li><li>替换成功,则当前线程获取轻量级锁</li><li>替换失败，则存在其他线程竞争，自旋若干次失败后，会升级成重量级锁</li></ol><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁依赖对象内部的monitor锁实现，而monitor又依赖操作系统的MutexLock(互斥锁)</p><p>重量级锁开销比较大的原因是，阻塞和唤醒一个线程，都需要通过操作系统完成，从用户态转换到内核态相对耗时 </p><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a><br><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/54883355</a><br><a href="https://zhuanlan.zhihu.com/p/53080541" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53080541</a></p><p>reentrantlock<br><a href="https://juejin.im/post/5aeb0a8b518825673a2066f0" target="_blank" rel="noopener">https://juejin.im/post/5aeb0a8b518825673a2066f0</a></p><p>atomic<br><a href="https://www.cnblogs.com/nullzx/p/4967931.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/4967931.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;的作用是保证方法或代码在运时，同一时刻只有一个方法可以进到&lt;code&gt;临界区&lt;/code&gt;,同时还可以保证共享变量的内存可见性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;可修饰的对象有&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>

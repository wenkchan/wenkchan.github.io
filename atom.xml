<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenk.Chan的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-29T00:48:10.726Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenk.Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java项目基础模板</title>
    <link href="http://yoursite.com/2019/09/29/Java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2019/09/29/Java项目基础模板/</id>
    <published>2019-09-29T00:34:14.093Z</published>
    <updated>2019-09-29T00:48:10.726Z</updated>
    
    <content type="html"><![CDATA[<p>功能</p><ol><li>鉴权</li><li>全局异常处理</li></ol><p>一、代码辅助类</p><ol><li>lombok 代码简化</li><li>freemaker 生成代码引擎</li></ol><p>二、监控类</p><ol><li>log4j 日志输出</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鉴权&lt;/li&gt;
&lt;li&gt;全局异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一、代码辅助类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lombok 代码简化&lt;/li&gt;
&lt;li&gt;freemaker 生成代码引擎&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、监控类&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
      <category term="Java项目" scheme="http://yoursite.com/categories/Java%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础3.1 — 线程基础</title>
    <link href="http://yoursite.com/2019/09/27/Java%E5%9F%BA%E7%A1%803.1%20%E2%80%94%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/09/27/Java基础3.1 — 线程的基本概念/</id>
    <published>2019-09-27T02:33:03.758Z</published>
    <updated>2019-09-27T04:20:55.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程的基本概念"><a href="#一、线程的基本概念" class="headerlink" title="一、线程的基本概念"></a>一、线程的基本概念</h1><h2 id="并行-Parallel-和并发-concurrent"><a href="#并行-Parallel-和并发-concurrent" class="headerlink" title="并行(Parallel)和并发(concurrent)"></a>并行(Parallel)和并发(concurrent)</h2><ul><li>并发是相对一个CPU,分时间片执行任务,同一<code>时间间隔</code>事件</li><li>并行是相对多个CPU,分别同时执行任务,同一<code>时间点</code>事件</li></ul><h2 id="并行和串行"><a href="#并行和串行" class="headerlink" title="并行和串行"></a>并行和串行</h2><ul><li>串行是执行完一个任务再去执行下一个</li><li>并行是多个任务同时执行</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul><li>同步是<code>顺序进行</code>，需要进行等待，协调</li><li>异步在等待某一个任务执行过程中继续执行自己的任务,线程是实现异步的一个方式</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程是程序设计的<code>逻辑概念</code>，指的是在进程中并发运行的一段<code>代码</code>，实现多个线程间切换执行</p><h1 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h1><p>在Java类库,<code>Thread类</code>中有一个<code>State的枚举类</code>列出了线程的<code>6个状态</code></p><ul><li>初始(NEW)：<code>新创建</code>了一个线程对象，但还没有调用start()方法。</li><li><p>可运行(RUNNABLE)：Java线程中将<code>就绪（ready）</code>和<code>运行中（running）</code>两种状态笼统地称为”运行”。<br>调用了start()方法。线程位于<code>可运行线程池</code>中,<code>等待被线程调度</code>选中，此时处于<code>就绪状态（ready）</code>。就绪状态的线程在<code>获得CPU时间片后</code>变为运行中状态（running）。</p></li><li><p>阻塞(BLOCKED)：表示线程<code>阻塞于锁</code>。</p></li><li><p>等待(WAITING)：进入该状态的线程需要等待其他线程<code>做出一些特定动作</code>（通知或中断）。</p></li><li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后<code>自行返回</code>。</p></li><li><p>终止(TERMINATED)：表示该线程已经<code>执行完毕</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、线程的基本概念&quot;&gt;&lt;a href=&quot;#一、线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、线程的基本概念&quot;&gt;&lt;/a&gt;一、线程的基本概念&lt;/h1&gt;&lt;h2 id=&quot;并行-Parallel-和并发-concurrent&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础2.4 — Map家族之HashTable</title>
    <link href="http://yoursite.com/2019/09/26/Java%E5%9F%BA%E7%A1%802.4%20%E2%80%94%20Map%E5%AE%B6%E6%97%8F%E4%B9%8BHashTable/"/>
    <id>http://yoursite.com/2019/09/26/Java基础2.4 — Map家族之HashTable/</id>
    <published>2019-09-26T01:31:36.370Z</published>
    <updated>2019-09-26T01:34:30.103Z</updated>
    
    <content type="html"><![CDATA[<p>判断 value 是否为空，为空则抛出异常；<br>计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value；<br>否则，我们可以将其插入到 table[index] 位置。</p><ul><li><p>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</p></li><li><p>Hashtable 的 key 和 value 都不允许为 null。Hashtable遇到 null，直接返回 NullPointerException。</p></li><li><p>Hashtable 方法是同步，几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断 value 是否为空，为空则抛出异常；&lt;br&gt;计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value；
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础2.3 — Map家族之TreeMap</title>
    <link href="http://yoursite.com/2019/09/26/Java%E5%9F%BA%E7%A1%802.3%20%E2%80%94%20Map%E5%AE%B6%E6%97%8F%E4%B9%8BTreeMap/"/>
    <id>http://yoursite.com/2019/09/26/Java基础2.3 — Map家族之TreeMap/</id>
    <published>2019-09-26T01:22:15.377Z</published>
    <updated>2019-09-26T01:23:35.680Z</updated>
    
    <content type="html"><![CDATA[<p>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 该映射根据其键的自然顺序(字母排序)进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>TreeMap是非线程安全的。 它的iterator 方法返回的迭代器是fail-fast的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 该映射根据其键的自然顺序(字母排序)进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。&lt;br&gt;TreeMap是非线程安全的。 它的iterator 方法返
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础2.2 — Map家族之LinkedHashMap</title>
    <link href="http://yoursite.com/2019/09/24/Java%E5%9F%BA%E7%A1%802.2%20%E2%80%94%20Map%E5%AE%B6%E6%97%8F%E4%B9%8BLinkedHashMap/"/>
    <id>http://yoursite.com/2019/09/24/Java基础2.2 — Map家族之LinkedHashMap/</id>
    <published>2019-09-24T06:26:51.963Z</published>
    <updated>2019-09-25T01:28:08.628Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/15693063662970.jpg" alt=""></p><h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>LinkHashMap继承自HashMap,在保留了HashMap的线程不安全的，允许key为null,value为null，这些特点的同时，加入了<code>保存插入时的顺序</code>，使得遍历时的顺序与插入时一致</p><h1 id="二、存储结构"><a href="#二、存储结构" class="headerlink" title="二、存储结构"></a>二、存储结构</h1><p>结构上与HashMap一样是<code>数组+链表+红黑树</code></p><p>要搞明白的两个问题:数据底层<code>存储的是什么</code>? 这种存储方式有什么<code>优缺点</code>?</p><ol><li>源码中可以得知，<code>Entry</code>继承了<code>HashMap.Node</code>,并且新增了两个参数,记录节点前后的节点信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且还新增了<code>head,tail</code>这两个成员变量记录了链表的头部和尾部，把链表修改成了<code>双向链表</code>,实现了遍历顺序为插入顺序,<code>accessOrder</code>就是控制了这点(默认false)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//链表尾部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//遍历时的顺序，true 访问顺序 false 插入顺序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h1 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h1><h2 id="1、put方法"><a href="#1、put方法" class="headerlink" title="1、put方法"></a>1、put方法</h2><p>这里没有对put方法进行重写，重写的是构建新节点的的方法<code>newNode()</code>,并通过<code>linkNodeLast</code>将新节点连接到内部双向链表的尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把节点添加到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及HashMap专门留下来的回调方法</p><ul><li>afterNodeAccess </li><li>afterNodeInsertion</li><li>afterNodeRemoval</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//被访问后回调，会将被访问的节点移到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; </span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//回调函数，新节点插入之后回调,根据evict和设定是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;         </span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，将节点从双向链表中删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; </span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致<code>fail-fast</code>，因为迭代的顺序已经改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/15693063662970.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、概要&quot;&gt;&lt;a href=&quot;#一、概要&quot; class=&quot;headerlink&quot; title=&quot;一、概要&quot;&gt;&lt;/a&gt;一、概要&lt;/h1&gt;&lt;p&gt;LinkHashMa
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础2.1 — Map家族之HashMap</title>
    <link href="http://yoursite.com/2019/09/22/Java%E5%9F%BA%E7%A1%802.1%20%E2%80%94%20Map%E5%AE%B6%E6%97%8F%E4%B9%8BHashMap/"/>
    <id>http://yoursite.com/2019/09/22/Java基础2.1 — Map家族之HashMap/</id>
    <published>2019-09-22T10:35:45.895Z</published>
    <updated>2019-09-29T02:50:51.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/15693063662970.jpg" alt=""></p><h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>HashMap是一个<code>关联数组、哈希表</code>，其中数组被称为<code>哈希桶</code>，每个<code>桶里放的是链表或红黑树</code>，每个<code>节点</code>就是哈希表中的<code>元素</code>。</p><p>特点是</p><ol><li>线程不安全(线程安全可使用<code>ConcurrentHashMap</code>)</li><li>遍历无序</li><li>允许单个null的key和多个null的值</li></ol><p><code>JDK1.8后</code>，新增了<code>红黑树</code>，当单个链表的元素达到<code>8</code>，就会转换成红黑树，提高查询和插入的效率，避免链表过长的问题</p><p>需要关注的问题</p><ol><li>hash表，涉及到<code>碰撞解决</code></li><li>数组，涉及到<code>扩容机制</code></li></ol><blockquote><h2 id="Hash知识补充"><a href="#Hash知识补充" class="headerlink" title="Hash知识补充"></a>Hash知识补充</h2><p>Hash就是把任意长度的消息(<code>预映射:pre-image</code>)通过哈希算法压缩成<code>固定长度</code>的消息输出,输出的值就是<code>Hash值</code>。<code>不同的输入</code>可能有<code>同样的输出</code>,所以用Hash值<code>得不到唯一值</code>,同样的输出<br>称为<code>碰撞</code>需要进行<code>碰撞处理</code>:一般有:<br><code>拉链法(open hashing)</code>、<code>开放定址法(closed hashing)</code>、<code>再哈希法</code>、<code>建立公共溢出区</code></p></blockquote><h1 id="二、存储结构与碰撞解决"><a href="#二、存储结构与碰撞解决" class="headerlink" title="二、存储结构与碰撞解决"></a>二、存储结构与碰撞解决</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>从源码可知，HashMap中非常重要的一个字段， <code>Node[] table</code>，即<code>Hash桶数组</code>，Node的数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//用于定位索引</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">//链表的下一个Node</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了<code>Map.Entry</code>接口，本质是就是一个<code>键值对</code>。每一个<code>节点存储的就是一个Node</code></p><h2 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h2><p>HashMap使用的是Hash表存储，并且使用<code>拉链法</code>解决碰撞。简单来说，就是数组加链表的结合.<br>当数据被Hash后，得到<code>数组下标</code>，把数据放在<code>对应下标元素的链表</code>。如果发生了碰撞，就会把数据插到对应链表的<code>尾部</code>(JDK1.7是插到头部，插到尾部避免了逆序，环形链表,后文会讲到)</p><p> <img src="/media/15692013445358.jpg" alt="-w541"></p><h1 id="三、扩容机制"><a href="#三、扩容机制" class="headerlink" title="三、扩容机制"></a>三、扩容机制</h1><p> 理解扩容机制之前需要看一下几个重要的参数<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容量默认为16,且必须为2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//负载默认因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">int</span> threshold;            </span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    </span><br><span class="line"><span class="comment">//结构变化次数</span></span><br><span class="line"><span class="keyword">int</span> modCount; </span><br><span class="line"><span class="comment">//实际存储的键值对</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>threshold</code>是HashMap所能容纳的最大数据量,计算公式是<code>threshold = length * loadFactor</code><br>当存储个数<code>size</code>大于<code>threshold</code>,容量扩大为<code>原来的两倍</code></p></li><li><p><code>modCount</code>用来记录HashMap<code>内部结构发生变化的次数</code>,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value<code>被覆盖不属于结构变化</code></p></li><li><p><code>loadFactor 负载因子</code>默认值是<code>0.75</code>,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重</p></li><li><p><code>DEFAULT_INITIAL_CAPACITY 初始容量</code>为<code>16</code>,且为<code>2的幂</code>,采用这种<code>非常规</code>设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p></li></ul><p>下面来分析一下<code>resize</code>的源码，鉴于红黑树比较复杂，这里先看JDK1.7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   </span><br><span class="line">     <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     Entry[] oldTable = table;    </span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;        </span><br><span class="line">     <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了 </span></span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; </span><br><span class="line">         <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 </span></span><br><span class="line">         threshold = Integer.MAX_VALUE; </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//！！将数据转移到新的Entry数组里  </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line">   <span class="comment">//HashMap的table属性引用新的Entry数组                        </span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//修改阈值                          </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//释放旧Entry数组的对象引用，防止对象游离</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">//标记</span></span><br><span class="line">                 e.next = newTable[i];</span><br><span class="line">                 <span class="comment">//将元素放在数组上 </span></span><br><span class="line">                 newTable[i] = e;</span><br><span class="line">                 <span class="comment">//访问下一个Entry链上的元素      </span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>e的引用复制给了newTable[i],也就是说这里使用了单链表的<code>头插法</code>，而且需要<code>重新计算</code>每个元素的<code>hash值</code>，这两点与JDK1.8有区别,</p><p>下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为<code>原来的2倍</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure></p><p>所以，元素的位置要么是在<code>原位置</code>，要么是在<code>原位置再移动2次幂</code>的位置，下图就可以看的出来<br><img src="/media/15692961900375.jpg" alt=""><br>a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化<br><img src="/media/15692963388249.jpg" alt=""></p><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是<code>0的话索引没变</code>，是<code>1的话索引变成&quot;原索引+oldCap&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e</span><br></pre></td></tr></table></figure><p>下图为16扩充为32的resize示意图<br><img src="/media/15692963846956.jpg" alt=""></p><p>这样，既<code>省去了重新计算hash值的时间</code>，同时，由于新增的1bit可以认为是<code>随机的</code>，因此resize的过程，<code>均匀地</code>把之前的冲突的节点分散到新的bucket了。</p><blockquote><h2 id="JDK1-7的环形链表死循环问题"><a href="#JDK1-7的环形链表死循环问题" class="headerlink" title="JDK1.7的环形链表死循环问题"></a>JDK1.7的环形链表死循环问题</h2><p>扩容时，当线程A运行到<code>Entry&lt;K,V&gt; next = e.next</code>被挂起，线程B完成了扩容操作后，会出现<br>主要原因是新链表<code>头插</code>操作,导致<code>逆序</code>,JDK1.8之后改用<code>尾插</code>修复，但是仍然是线程不安全</p></blockquote><p>下面是JDK1.8扩容的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果原容量的两倍小于最大容量，且元容量大于默认容量</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              <span class="comment">//新容量为原容量的两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//遍历旧数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="comment">// 原索引</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、put方法"><a href="#2、put方法" class="headerlink" title="2、put方法"></a>2、put方法</h2><p><img src="/media/15692055428965.jpg" alt=""></p><ol><li>如果table为null则创建</li><li>根据hash计算出元素index(<code>length - 1 &amp; hash</code>效果等同于取模,效率提高),并处理null值</li><li>如果key存在,直接覆盖Value</li><li>判断是否为红黑树</li><li>判断是否为链表</li><li>判断是否需要扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//对key进行hash操作</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//1、如果table为null则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">//2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//3、如果key存在,直接覆盖Value</span></span><br><span class="line">         <span class="keyword">if</span> (p。hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">//4、判断是否为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">//5、判断是否为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//链表大于阈值则转换为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//key存在直接覆盖</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.alue;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">//6、判断是否需要扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="四、JDK8新增优化"><a href="#四、JDK8新增优化" class="headerlink" title="四、JDK8新增优化"></a>四、JDK8新增优化</h1><ul><li>新增红黑树</li><li>扩容机制优化效率</li></ul><blockquote><p><code>Java 8系列之重新认识HashMap</code> <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br><code>HashMap在JDK7和JDK8中的区别</code> <a href="https://zhuanlan.zhihu.com/p/59250175" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59250175</a><br><code>Map 综述（一）：彻头彻尾理解 HashMap</code> <a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/62893086</a><br><code>面试必备：HashMap源码解析（JDK8）</code> <a href="https://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="noopener">https://blog.csdn.net/zxt0601/article/details/77413921</a><br><code>解决哈希冲突的常用方法分析</code> <a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">https://www.jianshu.com/p/4d3cb99d7580</a></p></blockquote><p>遗留:</p><ol><li>WeakHashMap</li><li>解决hash碰撞</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/15693063662970.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、概要&quot;&gt;&lt;a href=&quot;#一、概要&quot; class=&quot;headerlink&quot; title=&quot;一、概要&quot;&gt;&lt;/a&gt;一、概要&lt;/h1&gt;&lt;p&gt;HashMap是一个
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.4 — 异常</title>
    <link href="http://yoursite.com/2019/05/01/Java%E5%9F%BA%E7%A1%803.2%20%E2%80%94%20%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/05/01/Java基础3.2 — 异常/</id>
    <published>2019-05-01T07:01:09.960Z</published>
    <updated>2019-09-21T03:11:20.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java中异常分类"><a href="#一、Java中异常分类" class="headerlink" title="一、Java中异常分类"></a>一、Java中异常分类</h1><h2 id="1-继承关系分类"><a href="#1-继承关系分类" class="headerlink" title="1.继承关系分类"></a>1.继承关系分类</h2><p><img src="/media/15572859400020.jpg" alt="15572859400020"></p><ul><li><code>Throwable</code>:所有异常的<code>基类</code>,指出了代码中可以用通过异常传播机制传输Java程序任何问题的<code>共性</code></li><li><code>Error</code>:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止</li><li><code>Exception</code>:程序本身可以处理的错误，Exception还有一个重要的子类<code>RunTimeException</code>,<code>RunTimeException及其子类</code>用来表示<code>JVM常用操作</code>引发的错误(NullPointerException、ArithmeticException)</li></ul><h2 id="2、可查异常-checked-exceptions-和不可查异常-unchecked-exceptions"><a href="#2、可查异常-checked-exceptions-和不可查异常-unchecked-exceptions" class="headerlink" title="2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)"></a>2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)</h2><p>包含Exception和Error在内，Java异常可分为<code>可查异常</code>和<code>不可查异常</code></p><ul><li><code>可查异常</code>:在程序正常运行中允许发生的异常，并且<code>必须进行处理</code>，否则Java编译器不会通过.</li><li><code>不可查异常</code>:包含<code>RunTimeException及其子类</code>和<code>Error</code></li></ul><h2 id="3、运行时异常和非运行时异常-编译异常"><a href="#3、运行时异常和非运行时异常-编译异常" class="headerlink" title="3、运行时异常和非运行时异常(编译异常)"></a>3、运行时异常和非运行时异常(编译异常)</h2><ul><li><code>运行时异常</code>:都是<code>RunTimeException及其子类</code>,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException</li><li><code>非运行时异常(编译异常)</code>:RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException</li></ul><h1 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h1><h2 id="1、异常处理机制分为-抛出异常和捕捉异常"><a href="#1、异常处理机制分为-抛出异常和捕捉异常" class="headerlink" title="1、异常处理机制分为:抛出异常和捕捉异常"></a>1、异常处理机制分为:<code>抛出异常和捕捉异常</code></h2><ul><li><code>抛出异常</code>:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中<code>包括异常类型和异常信息</code></li><li><code>捕获异常</code>:在抛出异常后，运行时系统就开始寻找合适的<code>异常处理器(exception handler)</code>,寻找的地方就是依次留在调用<code>方法栈中的方法的集合</code>,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止</li></ul><h2 id="2、Java要求对异常的处理方式"><a href="#2、Java要求对异常的处理方式" class="headerlink" title="2、Java要求对异常的处理方式"></a>2、Java要求对异常的处理方式</h2><ul><li>RunTimeException:由运行时系统抛出，可以忽略，</li><li>Error:属于不允许发生情况，所以不捕捉</li><li>可查异常:必须捕捉、或者声明抛出</li></ul><h2 id="3、捕捉处理异常语句try-catch-finally"><a href="#3、捕捉处理异常语句try-catch-finally" class="headerlink" title="3、捕捉处理异常语句try-catch-finally"></a>3、捕捉处理异常语句try-catch-finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally</li><li>catch:用于处理捕捉到的异常</li><li>finally:无论是否捕捉到异常,都会执行,<code>如果try或者catch中有返回语句，那么finally会在返回之前执行</code></li></ul><p>以下四种情况finally不会被执行</p><ul><li>finally出现异常</li><li>前面代码使用System.exit()退出程序</li><li>程序所有线程死亡</li><li>关闭CPU</li></ul><h2 id="4、抛出异常-throws"><a href="#4、抛出异常-throws" class="headerlink" title="4、抛出异常 throws"></a>4、抛出异常 throws</h2><p>如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用<code>throws</code>抛出异常，给上一层处理</p><p>###抛出规则</p><ul><li>对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出</li><li>可查异常，要么try-catch捕获，要么使用<code>throws</code>声明抛出</li><li>抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java中异常分类&quot;&gt;&lt;a href=&quot;#一、Java中异常分类&quot; class=&quot;headerlink&quot; title=&quot;一、Java中异常分类&quot;&gt;&lt;/a&gt;一、Java中异常分类&lt;/h1&gt;&lt;h2 id=&quot;1-继承关系分类&quot;&gt;&lt;a href=&quot;#1-继承关系分类&quot;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.3 — Java相关语法那些事</title>
    <link href="http://yoursite.com/2019/03/25/Java%E5%9F%BA%E7%A1%803.1%20%E2%80%94%20Java%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/25/Java基础3.1 — Java相关语法/</id>
    <published>2019-03-25T12:16:25.552Z</published>
    <updated>2019-09-19T13:24:21.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java面向对象的四大特性"><a href="#一、Java面向对象的四大特性" class="headerlink" title="一、Java面向对象的四大特性"></a>一、Java面向对象的四大特性</h1><h2 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1.继承性"></a>1.继承性</h2><p>继承性是类的一种层次模型，提供了明确表述<code>共性</code>的方法,对象的新类在类中继承派生。类可以从他的基类<code>继承</code>方法和实例变量，并且类可以<code>修改或者增加</code>新的方法使之更适合特殊的需要</p><p><code>关键字:extends、class</code></p><h2 id="2-多态性"><a href="#2-多态性" class="headerlink" title="2.多态性"></a>2.多态性</h2><p>多态性是对象在<code>不同时刻</code>表现出来的多种状态,是一种<code>编译时期状态</code>和<code>运行时期状态</code>不一致的现象，多态包括<code>参数多态</code>和<code>包含多态</code></p><p><code>关键字:interface</code></p><h2 id="3-抽象性"><a href="#3-抽象性" class="headerlink" title="3.抽象性"></a>3.抽象性</h2><p>抽象是指对一类事物的高度提炼以得到的<code>共性</code>部分,抽象不需要了解全部细节，只是一种通用的描述<code>约束</code>,抽象可以是<code>过程抽象</code>或者<code>数据抽象</code></p><p><code>关键字:abstract</code></p><h2 id="4-封装性"><a href="#4-封装性" class="headerlink" title="4.封装性"></a>4.封装性</h2><p>封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的<code>隐私性和可靠性</code></p><blockquote><p>面向对象的特性:更多的实践使用就是设计模式</p></blockquote><h1 id="二、Java中的基础修饰符"><a href="#二、Java中的基础修饰符" class="headerlink" title="二、Java中的基础修饰符"></a>二、Java中的基础修饰符</h1><h2 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="1.权限修饰符"></a>1.权限修饰符</h2><ul><li><code>private</code>:只能在定义它们的类中使用，在其他类中不能调用。</li><li><code>缺省(default)</code>:只能在定义它们的类中，以及同包的类中被调用</li><li><code>protected</code>:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类</li><li><code>public</code>:可以在任何一个类中被调用</li></ul><h2 id="2-final"><a href="#2-final" class="headerlink" title="2.final"></a>2.final</h2><p>①<code>类</code>被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final</p><p>②<code>变量</code>被声明为final,必须在声明时初始化，且只能读取不能修改</p><p>③<code>方法</code>被声明为final,不能被<code>重载</code></p><blockquote><p>一般会使用final和static组合来定义常量</p></blockquote><h2 id="3-static修饰符"><a href="#3-static修饰符" class="headerlink" title="3.static修饰符"></a>3.static修饰符</h2><p><code>static</code>可以用来修饰的类成员变量、成员方法、代码块,将独立于对象</p><ol><li>被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问)</li><li><code>静态方法</code>不能访问类的非静态方法和成员变量</li><li><code>静态成员变量</code>会被所有的对象<code>共享</code></li><li><code>静态代码块</code>会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作</li></ol><p>关于static还有一个<code>类内元素加载顺序</code>的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个构造代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    Block()&#123;</span><br><span class="line">        System.out.println(<span class="string">"block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义一个父类    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Block block=<span class="keyword">new</span> Block();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father()&#123;</span><br><span class="line">       System.out.println(<span class="string">"father static constructor"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Block block=<span class="keyword">new</span> Block();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son()&#123;</span><br><span class="line">        System.out.println(<span class="string">"son static constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">father <span class="keyword">static</span> block</span><br><span class="line">son <span class="keyword">static</span> block</span><br><span class="line">block</span><br><span class="line">father <span class="keyword">static</span> constructor</span><br><span class="line">block</span><br><span class="line">son <span class="keyword">static</span> constructor</span><br></pre></td></tr></table></figure></p><p>可以看出加载顺序是<code>静态代码块-&gt;构造代码块-&gt;构造方法</code></p><h2 id="4-this和super"><a href="#4-this和super" class="headerlink" title="4.this和super"></a>4.this和super</h2><p><code>this</code>为当前类的引用对象，应用场景</p><ol><li>构造方法:通过this的调用同类中指定参数类型的构造方法<code>this(参数列表)</code>,只能用在构造方法体的第一行</li><li>变量:当成员变量与局部变量重名，使用this特指<code>成员变量</code></li><li>方法:在方法中引用该方法所属类的当前对象，注意不能用于this方法(this对象级别，static类级别)</li></ol><p><code>super</code>为父类存储空间标识</p><ol><li>构造方法:在子类构造方法中调用父类构造方法<code>super(参数列表)</code>,同样只能在构造方法体的第一行</li></ol><h1 id="三、Java的变长参数"><a href="#三、Java的变长参数" class="headerlink" title="三、Java的变长参数"></a>三、Java的变长参数</h1><p>在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用<code>...</code>表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Java的自增自减运算符"><a href="#四、Java的自增自减运算符" class="headerlink" title="四、Java的自增自减运算符"></a>四、Java的自增自减运算符</h1><p>这里主要需要注意一个陷阱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是</p><ol><li>JVM把count值拷贝到临时变量区(0)</li><li>count值加1,此时count为(1)</li><li>返回临时变量区的值(0)</li><li>此时count被重置为0</li></ol><p>也就是不管count = count++多少次，count的值,都是一样。 </p><p>Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全</p><ol><li>synchronized代码块或者方法</li><li>使用Lock锁</li><li>使用JDK提供的线程安全类<code>AtomicInteger</code>(推荐)</li></ol><h1 id="五、equals和hasCode"><a href="#五、equals和hasCode" class="headerlink" title="五、equals和hasCode"></a>五、equals和hasCode</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java面向对象的四大特性&quot;&gt;&lt;a href=&quot;#一、Java面向对象的四大特性&quot; class=&quot;headerlink&quot; title=&quot;一、Java面向对象的四大特性&quot;&gt;&lt;/a&gt;一、Java面向对象的四大特性&lt;/h1&gt;&lt;h2 id=&quot;1-继承性&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.2 — 关于字符串String、StringBuilder、StringBuffer那些事</title>
    <link href="http://yoursite.com/2019/03/24/Java%E5%9F%BA%E7%A1%802.1%20%E2%80%94%20%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2String%E3%80%81StringBuilder%E3%80%81StringBuffer%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/</id>
    <published>2019-03-24T02:33:10.360Z</published>
    <updated>2019-09-19T13:24:21.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、String的不可变性"><a href="#一、String的不可变性" class="headerlink" title="一、String的不可变性"></a>一、String的不可变性</h1><p>咱们先来看一下String类的声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    /` The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    /` Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure></p><p>首先知道的是String实际上内部维护的是<code>char数组</code>,并且这个数组和String一样，都用<code>final</code>修饰，证明String是不可变的和不可被继承的，进一步解释就是一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变，不能指向其他对象，指向的对象的状态也不能被改变，那么这样设计的好处有什么呢?原因有以下</p><ol><li>只有当String是不可变时，<code>String常量池</code>才有可能实现并且为heap节省了空间</li><li><code>网络安全</code>,否则黑客可以改变String指向的对象的值而造成安全漏洞问题</li><li><code>线程安全</code>,可以被多个线程共享</li><li><code>性能</code>,因为String不可变，所以String创建时的<code>hashcode也具有唯一性</code>，作为Map的键时比其他键对象快</li></ol><h1 id="二、String-Constant-Pool-String常量池"><a href="#二、String-Constant-Pool-String常量池" class="headerlink" title="二、String Constant Pool(String常量池)"></a>二、String Constant Pool(String常量池)</h1><blockquote><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即<code>String Pool(字符串池)</code></p></blockquote><p><code>常量池底层</code>方法是 <code>String#intern()</code> 使用StringTable数据结构保存字符串引用，StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， <code>String#intern()</code> 的性能由O(1)退化到O(n)。</p><blockquote><p>深入解析String#intern<br><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote><p>在<code>JDK6</code>的版本中，String Pool使用固定容量的<code>HashMap</code>实现并存储在<code>永久代</code>中的，后面变为可配置，因为永久带内存有限，所以在<code>JDK7</code>开始就移动到<code>heap(堆内存)</code>中,这就意味着你可以通过调整堆大小来调整应用程序,通过<code>JVM参数-XX:StringTableSize</code>可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好</p><p>创建字符串对象的方式有两种</p><ol><li>通过字面常量赋值</li><li>通过new关键字新建字符串对象</li></ol><p>这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么</p><h2 id="1-字面常量赋值"><a href="#1-字面常量赋值" class="headerlink" title="1.字面常量赋值"></a>1.字面常量赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"ab"</span>+<span class="string">"c"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的<br>String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”;</p></blockquote><p>采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的<code>s1和s2</code>指向的都是同一个对象，用 <code>==</code> 比较就会返回<code>true</code>,我们也可以通过<code>字节码</code>来进一步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt; </span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当调用<code>ldc #2</code>,如果 <code>#2</code> 的symbol还没解析，则会调用C++底层的 <code>StringTable::intern</code> 方法生成char数组，并将引用保存在 <code>StringTable和常量池中</code>，当下次调用 <code>ldc #2</code>,通过将常量池中 <code>#2</code>对应的字符串推送到栈顶获取到 <code>&quot;abc&quot;</code>，避免再次到StringTable中查找。<code>astore_1</code> 将 <code>&quot;abc&quot;</code> 保存到 <code>局部变量</code></p><h2 id="2-使用new关键字新建"><a href="#2-使用new关键字新建" class="headerlink" title="2.使用new关键字新建"></a>2.使用new关键字新建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们来分析一下发生了什么<br>①因为”abc”是用<code>字面常量</code>定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②<br>②由于使用了<code>new</code>，所以JVM会在 <code>heap(堆)</code> 中创建一个内容相同的String对象，然后返回堆中Sring对象的引用</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 ldc #3 &lt;abc&gt;  </span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>所以，分别在常量池和堆中生成了两个内容相同的String对象</p><h2 id="3-使用变量连接的情况"><a href="#3-使用变量连接的情况" class="headerlink" title="3.使用变量连接的情况"></a>3.使用变量连接的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>重点在s6,因为s5是一个变量，即使我们知道这个值，但是Jvm仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 <code>heap(堆)</code> 中创建了一个内容为”abc”的对象并返回给s6,而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现.</p><p>下面是字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;ab&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> 3 new #3 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">14 ldc #6 &lt;c&gt;</span><br><span class="line">16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>字符串变量的<code>连接</code>动作，在编译期会被转化成<code>StringBuilder的append操作</code></p><h2 id="4-使用final关键字修饰String"><a href="#4-使用final关键字修饰String" class="headerlink" title="4.使用final关键字修饰String"></a>4.使用final关键字修饰String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String s7 = <span class="string">"ab"</span>;</span><br><span class="line">String s8 = s7 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>在这种情况下,<code>final</code>修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc”</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;ab&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #3 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><h1 id="三、String、StringBuilder和StringBuffer的区别"><a href="#三、String、StringBuilder和StringBuffer的区别" class="headerlink" title="三、String、StringBuilder和StringBuffer的区别"></a>三、String、StringBuilder和StringBuffer的区别</h1><ol><li>String是字符串 <code>常量</code>，而 tringBuilder和StringBuffer都是字符串 <code>变量</code></li><li>StringBuilder是 <code>线程不安全</code> 的，而StringBuffer是 <code>线程安全</code> 的，这样就以为者后者会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高</li><li>String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认<code>16个字节数组</code>的大小。扩容就<code>原来的大小 x 2 + 2</code>,可以考虑初始化StringBuilder的大小来提高代码的效率。</li></ol><h1 id="四、一些题目"><a href="#四、一些题目" class="headerlink" title="四、一些题目"></a>四、一些题目</h1><p>1.下面程序运行的结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//false String的equals有对参数进行instance of String判断</span></span><br><span class="line"></span><br><span class="line">StringBuffer s3 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s3.equals(<span class="string">"abc"</span>));  <span class="comment">//StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是</span></span><br><span class="line">System.out.println(s3.toString().equals(<span class="string">"abc"</span>)); <span class="comment">//true 比较的是值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">0</span>));   <span class="comment">//true,如果subString的index是0，直接返回对象</span></span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">1</span>));   <span class="comment">//false,不为0就new一个sub之后的对象返回</span></span><br></pre></td></tr></table></figure></p><p>除此之外,<code>toLowerCase</code>和<code>toUpperCase</code>都是new一个对象返回</p><p>2.下面语句一共创建了多少个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure></p><p>这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是<code>两个</code>,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、String的不可变性&quot;&gt;&lt;a href=&quot;#一、String的不可变性&quot; class=&quot;headerlink&quot; title=&quot;一、String的不可变性&quot;&gt;&lt;/a&gt;一、String的不可变性&lt;/h1&gt;&lt;p&gt;咱们先来看一下String类的声明&lt;br&gt;&lt;figu
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.1 — Java八大基本数据类型及其包装类</title>
    <link href="http://yoursite.com/2019/03/23/Java%E5%9F%BA%E7%A1%801.1%20%E2%80%94%20Java%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/</id>
    <published>2019-03-23T05:36:43.063Z</published>
    <updated>2019-09-20T15:11:07.094Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">数据类型</th><th style="text-align:center">大小/位</th><th style="text-align:center">封装类</th><th style="text-align:center">默认值</th><th style="text-align:center">可表示数据范围</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Byte</td><td style="text-align:center">0</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Short</td><td style="text-align:center">0</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Integer</td><td style="text-align:center">0</td><td style="text-align:center">-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Long</td><td style="text-align:center">0L</td><td style="text-align:center">-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Float</td><td style="text-align:center">0F</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Double</td><td style="text-align:center">0D</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Character</td><td style="text-align:center">空</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">boolean</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Boolean</td><td style="text-align:center">false</td><td style="text-align:center">true或false</td></tr></tbody></table><blockquote><p>无需记忆可表示范围，在JDK里面数据类型可承载的最大最小值已经在包装类里面用常量的形式表示出来了<br>如:<code>Integer.MIN_VALUE</code><br><code>Integer.MAX_VALUE</code><br><code>Integer.SIZE</code></p></blockquote><h2 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h2><ul><li>整型：byte、short、int、long</li><li>浮点型：float、double</li><li>逻辑型：boolean</li><li>字符型：char</li></ul><h2 id="2、类型转换"><a href="#2、类型转换" class="headerlink" title="2、类型转换"></a>2、类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">short</span> -&gt; <span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>从左到右的数据类型转换都是隐式转换，无需强转。</p><p>从右到做的数据类型转换需要强转，并且会损失精度</p><h1 id="二、包装类"><a href="#二、包装类" class="headerlink" title="二、包装类"></a>二、包装类</h1><p>java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值,而包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址</p><h2 id="1、自动拆箱和自动装箱"><a href="#1、自动拆箱和自动装箱" class="headerlink" title="1、自动拆箱和自动装箱"></a>1、自动拆箱和自动装箱</h2><p>在JDK1.5以后，提供了自动拆箱和自动装箱功能这样的”语法糖”,如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自动装箱</span></span><br><span class="line">Integer i = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//转换成了</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException</span></span><br></pre></td></tr></table></figure></p><p>从字节码看出也是一样的</p><p>(通过idea搜索<code>jclasslib bytecode viewer</code>插件查看更方便，安装后在 <code>View-&gt;Show Bytes Code With jclasslib</code>)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> iconst_1</span><br><span class="line"> 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">9</span> astore_2</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>同样地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱</span></span><br><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;,</span><br><span class="line"><span class="comment">//后面一句转换成了</span></span><br><span class="line"><span class="keyword">int</span> j = i.intValue();</span><br></pre></td></tr></table></figure></p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> aload_1</span><br><span class="line"> 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"> <span class="number">9</span> istore_2</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"><span class="number">14</span> istore_3</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>由此也可以看出，自动拆装箱属于<code>编译特性</code></p><h2 id="2、缓存池"><a href="#2、缓存池" class="headerlink" title="2、缓存池"></a>2、缓存池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Byte</code>都是用缓存池里面的值</li><li><code>Short、Integer、Long</code>会缓存 <code>-128~127</code></li><li><code>Float和Double</code>则直接返回，因为精度数不能每次都一样，所以缓存没有意义</li><li><code>Character</code>则是缓存 <code>&lt;=127</code></li><li><code>Boolean</code>,只有两个值，直接就用常量的形式表示出来了</li></ul><h1 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h1><ul><li>double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是<code>false</code>,所以在进行带精度计算时，需要用到<code>BigDecimal</code></li><li>switch中只能用byte、char、short、int，JDK1.7后可用String</li><li>Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型</li><li>两边都是包装类的<code>equals</code>比较值，<code>==</code> 比较引用，其中一边是表达式的，<code>==</code> 就是比较数值</li></ul><h1 id="四、题目"><a href="#四、题目" class="headerlink" title="四、题目"></a>四、题目</h1><p>1.下面语句做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>; <span class="comment">//valueOf()自动装箱成Integer类型</span></span><br><span class="line">i+=<span class="number">1</span>;<span class="comment">//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer</span></span><br></pre></td></tr></table></figure></p><p>2.下面程序语句有什么问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;  <span class="comment">//编译不通过、需要强转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s2 =<span class="number">1</span>;</span><br><span class="line">s2 += <span class="number">1</span>;  <span class="comment">//正常编译</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//NullPointException</span></span><br></pre></td></tr></table></figure></p><p>3.下面程序的运行结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//false 比较了对象</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//true 缓存了-128~127</span></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="number">1f</span>;</span><br><span class="line">Float f2 = <span class="number">1f</span>;</span><br><span class="line">System.out.println(f1 == f2) <span class="comment">//false 始终new新对象</span></span><br></pre></td></tr></table></figure></p><ul><li>char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(<a href="https://blog.csdn.net/BuquTianya/article/details/80685437" target="_blank" rel="noopener">拓展资料</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;序号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;大小/位&lt;/th&gt;
&lt;
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>创建Hexo博客并部署到云主机</title>
    <link href="http://yoursite.com/2018/06/18/%E5%88%9B%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/06/18/创建Hexo博客并部署到云主机/</id>
    <published>2018-06-18T09:50:21.000Z</published>
    <updated>2019-09-19T13:20:57.137Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p><h1 id="一、云服务器配置-Ubuntu-16-04-LTS"><a href="#一、云服务器配置-Ubuntu-16-04-LTS" class="headerlink" title="一、云服务器配置(Ubuntu 16.04 LTS)"></a>一、云服务器配置(Ubuntu 16.04 LTS)</h1><h3 id="安装git和nginx"><a href="#安装git和nginx" class="headerlink" title="安装git和nginx"></a>安装<code>git</code>和<code>nginx</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git-core nginx</span><br></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>创建目录用于存放静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/www/blog</span><br></pre></td></tr></table></figure><p>创建一个Nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure><p>键入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">listen 8080;</span><br><span class="line">root /var/www/blog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h3 id="配置Git-Hooks"><a href="#配置Git-Hooks" class="headerlink" title="配置Git Hooks"></a>配置Git Hooks</h3><p>生成<code>blog.git</code>作为仓库，当本地Push过来时自动同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/blog.git &amp;&amp; cd ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p>创建<code>Hooks</code>脚本，当<code>blog.git</code>收到Push时自动执行<code>post-receive</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>然后脚本里面做的操作就是自动clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/www/blog</span><br><span class="line">sudo git clone /root/blog.git /var/www/blog</span><br></pre></td></tr></table></figure><p>最后再给个权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h1 id="二、本地相关配置-Mac-OS"><a href="#二、本地相关配置-Mac-OS" class="headerlink" title="二、本地相关配置(Mac OS)"></a>二、本地相关配置(Mac OS)</h1><h3 id="安装相关软件"><a href="#安装相关软件" class="headerlink" title="安装相关软件"></a>安装相关软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"></span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>然后安装<code>Hexo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>在自己想要的目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heox init .</span><br></pre></td></tr></table></figure><p>目录如下</p><p><img src="/media/15293158035733-1.jpg" alt="15293158035733"></p><p>在目录下找到配置文件<code>_config.yml</code>并修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: root@152.92.13.78:blog.git(例)</span><br></pre></td></tr></table></figure><div class="tip"><br>云服务器最好是使用SSH登录，那种比较方便，通过以下命令即可添加<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~./ssh/id_dsa</span><br></pre></td></tr></table></figure><br><br>删除<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -d ./ssh/id_xxx.pub</span><br></pre></td></tr></table></figure><br><br>查看<br>#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><br><br></div><h1 id="三、执行"><a href="#三、执行" class="headerlink" title="三、执行"></a>三、执行</h1><p>最后在本地生成静态文件后再进行部署即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>访问<code>152.92.13.78:8080(例)</code>即为博客站点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、云服务器配置-Ubuntu-16-04-LTS&quot;&gt;&lt;a href=&quot;#一、云服务器配置-U
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)</title>
    <link href="http://yoursite.com/2018/06/18/Android%20%E8%B0%B7%E6%AD%8C%E4%BA%B2%E5%84%BF%E5%AD%90%E7%B3%BB%E5%88%97%E7%BA%BF%E5%88%B7%E5%AE%98%E6%96%B9%E5%87%BA%E5%8E%82%E5%8C%85(Nexus%206P%E4%B8%BA%E4%BE%8B)/"/>
    <id>http://yoursite.com/2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/</id>
    <published>2018-06-18T06:48:11.000Z</published>
    <updated>2019-09-19T13:22:07.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h1><p>官方链接 <a href="https://developers.google.com/android/images" target="_blank" rel="noopener">官方出厂包下载(FQ)</a></p><hr><h1 id="二、修改"><a href="#二、修改" class="headerlink" title="二、修改"></a>二、修改</h1><p>解压出来是这个样子<br><img src="/media/15293050030148.jpg" alt="15293050030148"></p><p>需要把里面的zip文件也解压并且放到同一目录<br><img src="/media/15293049424410.jpg" alt="15293049424410"></p><hr><h1 id="三、开始刷机"><a href="#三、开始刷机" class="headerlink" title="三、开始刷机"></a>三、开始刷机</h1><p>最后利用adb进入bootfast模式重启并连接上手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>直接运行<code>flash-all.sh</code>即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; title=&quot;一、下载&quot;&gt;&lt;/a&gt;一、下载&lt;/h1&gt;&lt;p&gt;官方链接 &lt;a href=&quot;https://developers.google.com/android/images&quot; ta
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>

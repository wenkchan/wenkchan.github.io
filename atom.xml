<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenk.Chan的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-19T13:18:32.809Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenk.Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础1.4 — 异常</title>
    <link href="http://yoursite.com/2019/05/01/Java%E5%9F%BA%E7%A1%803.2%20%E2%80%94%20%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/05/01/Java基础3.2 — 异常/</id>
    <published>2019-05-01T07:01:09.960Z</published>
    <updated>2019-09-19T13:18:32.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java中异常分类"><a href="#一、Java中异常分类" class="headerlink" title="一、Java中异常分类"></a>一、Java中异常分类</h1><h2 id="1-继承关系分类"><a href="#1-继承关系分类" class="headerlink" title="1.继承关系分类"></a>1.继承关系分类</h2><p><img src="/media/15572859400020.jpg" alt="15572859400020"></p><ul><li><code>Throwable</code>:所有异常的<code>基类</code>,指出了代码中可以用通过异常传播机制传输Java程序任何问题的<code>共性</code></li><li><code>Error</code>:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止</li><li><code>Exception</code>:程序本身可以处理的错误，Exception还有一个重要的子类<code>RunTimeException</code>,<code>RunTimeException及其子类</code>用来表示<code>JVM常用操作</code>引发的错误(NullPointerException、ArithmeticException)</li></ul><h2 id="2、可查异常-checked-exceptions-和不可查异常-unchecked-exceptions"><a href="#2、可查异常-checked-exceptions-和不可查异常-unchecked-exceptions" class="headerlink" title="2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)"></a>2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)</h2><p>包含Exception和Error在内，Java异常可分为<code>可查异常</code>和<code>不可查异常</code></p><ul><li><code>可查异常</code>:在程序正常运行中允许发生的异常，并且<code>必须进行处理</code>，否则Java编译器不会通过.</li><li><code>不可查异常</code>:包含<code>RunTimeException及其子类</code>和<code>Error</code></li></ul><h2 id="3、运行时异常和非运行时异常-编译异常"><a href="#3、运行时异常和非运行时异常-编译异常" class="headerlink" title="3、运行时异常和非运行时异常(编译异常)"></a>3、运行时异常和非运行时异常(编译异常)</h2><ul><li><code>运行时异常</code>:都是<code>RunTimeException及其子类</code>,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException</li><li><code>非运行时异常(编译异常)</code>:RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException</li></ul><h1 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h1><h2 id="1、异常处理机制分为-抛出异常和捕捉异常"><a href="#1、异常处理机制分为-抛出异常和捕捉异常" class="headerlink" title="1、异常处理机制分为:抛出异常和捕捉异常"></a>1、异常处理机制分为:<code>抛出异常和捕捉异常</code></h2><ul><li><code>抛出异常</code>:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中<code>包括异常类型和异常信息</code></li><li><code>捕获异常</code>:在抛出异常后，运行时系统就开始寻找合适的<code>异常处理器(exception handler)</code>,寻找的地方就是依次留在调用<code>方法栈中的方法的集合</code>,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止</li></ul><h2 id="2、Java要求对异常的处理方式"><a href="#2、Java要求对异常的处理方式" class="headerlink" title="2、Java要求对异常的处理方式"></a>2、Java要求对异常的处理方式</h2><p>对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java中异常分类&quot;&gt;&lt;a href=&quot;#一、Java中异常分类&quot; class=&quot;headerlink&quot; title=&quot;一、Java中异常分类&quot;&gt;&lt;/a&gt;一、Java中异常分类&lt;/h1&gt;&lt;h2 id=&quot;1-继承关系分类&quot;&gt;&lt;a href=&quot;#1-继承关系分类&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.3 — Java相关语法那些事</title>
    <link href="http://yoursite.com/2019/03/25/Java%E5%9F%BA%E7%A1%803.1%20%E2%80%94%20Java%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/25/Java基础3.1 — Java相关语法/</id>
    <published>2019-03-25T12:16:25.552Z</published>
    <updated>2019-09-19T13:15:53.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java面向对象的四大特性"><a href="#一、Java面向对象的四大特性" class="headerlink" title="一、Java面向对象的四大特性"></a>一、Java面向对象的四大特性</h1><h2 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1.继承性"></a>1.继承性</h2><p>继承性是类的一种层次模型，提供了明确表述<code>共性</code>的方法,对象的新类在类中继承派生。类可以从他的基类<code>继承</code>方法和实例变量，并且类可以<code>修改或者增加</code>新的方法使之更适合特殊的需要</p><p><code>关键字:extends、class</code></p><h2 id="2-多态性"><a href="#2-多态性" class="headerlink" title="2.多态性"></a>2.多态性</h2><p>多态性是对象在<code>不同时刻</code>表现出来的多种状态,是一种<code>编译时期状态</code>和<code>运行时期状态</code>不一致的现象，多态包括<code>参数多态</code>和<code>包含多态</code></p><p><code>关键字:interface</code></p><h2 id="3-抽象性"><a href="#3-抽象性" class="headerlink" title="3.抽象性"></a>3.抽象性</h2><p>抽象是指对一类事物的高度提炼以得到的<code>共性</code>部分,抽象不需要了解全部细节，只是一种通用的描述<code>约束</code>,抽象可以是<code>过程抽象</code>或者<code>数据抽象</code></p><p><code>关键字:abstract</code></p><h2 id="4-封装性"><a href="#4-封装性" class="headerlink" title="4.封装性"></a>4.封装性</h2><p>封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的<code>隐私性和可靠性</code></p><blockquote><p>面向对象的特性:更多的实践使用就是设计模式</p></blockquote><h1 id="二、Java中的基础修饰符"><a href="#二、Java中的基础修饰符" class="headerlink" title="二、Java中的基础修饰符"></a>二、Java中的基础修饰符</h1><h2 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="1.权限修饰符"></a>1.权限修饰符</h2><ul><li><code>private</code>:只能在定义它们的类中使用，在其他类中不能调用。</li><li><code>缺省(default)</code>:只能在定义它们的类中，以及同包的类中被调用</li><li><code>protected</code>:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类</li><li><code>public</code>:可以在任何一个类中被调用</li></ul><h2 id="2-final"><a href="#2-final" class="headerlink" title="2.final"></a>2.final</h2><p>①<code>类</code>被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final</p><p>②<code>变量</code>被声明为final,必须在声明时初始化，且只能读取不能修改</p><p>③<code>方法</code>被声明为final,不能被<code>重载</code></p><blockquote><p>一般会使用final和static组合来定义常量</p></blockquote><h2 id="3-static修饰符"><a href="#3-static修饰符" class="headerlink" title="3.static修饰符"></a>3.static修饰符</h2><p><code>static</code>可以用来修饰的类成员变量、成员方法、代码块,将独立于对象</p><ol><li>被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问)</li><li><code>静态方法</code>不能访问类的非静态方法和成员变量</li><li><code>静态成员变量</code>会被所有的对象<code>共享</code></li><li><code>静态代码块</code>会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作</li></ol><p>关于static还有一个<code>类内元素加载顺序</code>的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个构造代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    Block()&#123;</span><br><span class="line">        System.out.println(<span class="string">"block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义一个父类    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Block block=<span class="keyword">new</span> Block();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father()&#123;</span><br><span class="line">       System.out.println(<span class="string">"father static constructor"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Block block=<span class="keyword">new</span> Block();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son()&#123;</span><br><span class="line">        System.out.println(<span class="string">"son static constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">father <span class="keyword">static</span> block</span><br><span class="line">son <span class="keyword">static</span> block</span><br><span class="line">block</span><br><span class="line">father <span class="keyword">static</span> constructor</span><br><span class="line">block</span><br><span class="line">son <span class="keyword">static</span> constructor</span><br></pre></td></tr></table></figure></p><p>可以看出加载顺序是<code>静态代码块-&gt;构造代码块-&gt;构造方法</code></p><h2 id="4-this和super"><a href="#4-this和super" class="headerlink" title="4.this和super"></a>4.this和super</h2><p><code>this</code>为当前类的引用对象，应用场景</p><ol><li>构造方法:通过this的调用同类中指定参数类型的构造方法<code>this(参数列表)</code>,只能用在构造方法体的第一行</li><li>变量:当成员变量与局部变量重名，使用this特指<code>成员变量</code></li><li>方法:在方法中引用该方法所属类的当前对象，注意不能用于this方法(this对象级别，static类级别)</li></ol><p><code>super</code>为父类存储空间标识</p><ol><li>构造方法:在子类构造方法中调用父类构造方法<code>super(参数列表)</code>,同样只能在构造方法体的第一行</li></ol><h1 id="三、Java的变长参数"><a href="#三、Java的变长参数" class="headerlink" title="三、Java的变长参数"></a>三、Java的变长参数</h1><p>在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用<code>...</code>表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Java的自增自减运算符"><a href="#四、Java的自增自减运算符" class="headerlink" title="四、Java的自增自减运算符"></a>四、Java的自增自减运算符</h1><p>这里主要需要注意一个陷阱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是</p><ol><li>JVM把count值拷贝到临时变量区(0)</li><li>count值加1,此时count为(1)</li><li>返回临时变量区的值(0)</li><li>此时count被重置为0</li></ol><p>也就是不管count = count++多少次，count的值,都是一样。 </p><p>Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全</p><ol><li>synchronized代码块或者方法</li><li>使用Lock锁</li><li>使用JDK提供的线程安全类<code>AtomicInteger</code>(推荐)</li></ol><h1 id="五、equals和hasCode"><a href="#五、equals和hasCode" class="headerlink" title="五、equals和hasCode"></a>五、equals和hasCode</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Java面向对象的四大特性&quot;&gt;&lt;a href=&quot;#一、Java面向对象的四大特性&quot; class=&quot;headerlink&quot; title=&quot;一、Java面向对象的四大特性&quot;&gt;&lt;/a&gt;一、Java面向对象的四大特性&lt;/h1&gt;&lt;h2 id=&quot;1-继承性&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.2 — 关于字符串String、StringBuilder、StringBuffer那些事</title>
    <link href="http://yoursite.com/2019/03/24/Java%E5%9F%BA%E7%A1%802.1%20%E2%80%94%20%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2String%E3%80%81StringBuilder%E3%80%81StringBuffer%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/</id>
    <published>2019-03-24T02:33:10.360Z</published>
    <updated>2019-09-19T13:15:53.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、String的不可变性"><a href="#一、String的不可变性" class="headerlink" title="一、String的不可变性"></a>一、String的不可变性</h1><p>咱们先来看一下String类的声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    /` The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    /` Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure></p><p>首先知道的是String实际上内部维护的是<code>char数组</code>,并且这个数组和String一样，都用<code>final</code>修饰，证明String是不可变的和不可被继承的，进一步解释就是一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变，不能指向其他对象，指向的对象的状态也不能被改变，那么这样设计的好处有什么呢?原因有以下</p><ol><li>只有当String是不可变时，<code>String常量池</code>才有可能实现并且为heap节省了空间</li><li><code>网络安全</code>,否则黑客可以改变String指向的对象的值而造成安全漏洞问题</li><li><code>线程安全</code>,可以被多个线程共享</li><li><code>性能</code>,因为String不可变，所以String创建时的<code>hashcode也具有唯一性</code>，作为Map的键时比其他键对象快</li></ol><h1 id="二、String-Constant-Pool-String常量池"><a href="#二、String-Constant-Pool-String常量池" class="headerlink" title="二、String Constant Pool(String常量池)"></a>二、String Constant Pool(String常量池)</h1><blockquote><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即<code>String Pool(字符串池)</code></p></blockquote><p><code>常量池底层</code>方法是 <code>String#intern()</code> 使用StringTable数据结构保存字符串引用，StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， <code>String#intern()</code> 的性能由O(1)退化到O(n)。</p><blockquote><p>深入解析String#intern<br><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote><p>在<code>JDK6</code>的版本中，String Pool使用固定容量的<code>HashMap</code>实现并存储在<code>永久代</code>中的，后面变为可配置，因为永久带内存有限，所以在<code>JDK7</code>开始就移动到<code>heap(堆内存)</code>中,这就意味着你可以通过调整堆大小来调整应用程序,通过<code>JVM参数-XX:StringTableSize</code>可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好</p><p>创建字符串对象的方式有两种</p><ol><li>通过字面常量赋值</li><li>通过new关键字新建字符串对象</li></ol><p>这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么</p><h2 id="1-字面常量赋值"><a href="#1-字面常量赋值" class="headerlink" title="1.字面常量赋值"></a>1.字面常量赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"ab"</span>+<span class="string">"c"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的<br>String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”;</p></blockquote><p>采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的<code>s1和s2</code>指向的都是同一个对象，用 <code>==</code> 比较就会返回<code>true</code>,我们也可以通过<code>字节码</code>来进一步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt; </span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当调用<code>ldc #2</code>,如果 <code>#2</code> 的symbol还没解析，则会调用C++底层的 <code>StringTable::intern</code> 方法生成char数组，并将引用保存在 <code>StringTable和常量池中</code>，当下次调用 <code>ldc #2</code>,通过将常量池中 <code>#2</code>对应的字符串推送到栈顶获取到 <code>&quot;abc&quot;</code>，避免再次到StringTable中查找。<code>astore_1</code> 将 <code>&quot;abc&quot;</code> 保存到 <code>局部变量</code></p><h2 id="2-使用new关键字新建"><a href="#2-使用new关键字新建" class="headerlink" title="2.使用new关键字新建"></a>2.使用new关键字新建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们来分析一下发生了什么<br>①因为”abc”是用<code>字面常量</code>定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②<br>②由于使用了<code>new</code>，所以JVM会在 <code>heap(堆)</code> 中创建一个内容相同的String对象，然后返回堆中Sring对象的引用</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 ldc #3 &lt;abc&gt;  </span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>所以，分别在常量池和堆中生成了两个内容相同的String对象</p><h2 id="3-使用变量连接的情况"><a href="#3-使用变量连接的情况" class="headerlink" title="3.使用变量连接的情况"></a>3.使用变量连接的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>重点在s6,因为s5是一个变量，即使我们知道这个值，但是Jvm仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 <code>heap(堆)</code> 中创建了一个内容为”abc”的对象并返回给s6,而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现.</p><p>下面是字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;ab&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> 3 new #3 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">14 ldc #6 &lt;c&gt;</span><br><span class="line">16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>字符串变量的<code>连接</code>动作，在编译期会被转化成<code>StringBuilder的append操作</code></p><h2 id="4-使用final关键字修饰String"><a href="#4-使用final关键字修饰String" class="headerlink" title="4.使用final关键字修饰String"></a>4.使用final关键字修饰String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String s7 = <span class="string">"ab"</span>;</span><br><span class="line">String s8 = s7 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>在这种情况下,<code>final</code>修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc”</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;ab&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #3 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><h1 id="三、String、StringBuilder和StringBuffer的区别"><a href="#三、String、StringBuilder和StringBuffer的区别" class="headerlink" title="三、String、StringBuilder和StringBuffer的区别"></a>三、String、StringBuilder和StringBuffer的区别</h1><ol><li>String是字符串 <code>常量</code>，而 tringBuilder和StringBuffer都是字符串 <code>变量</code></li><li>StringBuilder是 <code>线程不安全</code> 的，而StringBuffer是 <code>线程安全</code> 的，这样就以为者后者会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高</li><li>String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认<code>16个字节数组</code>的大小。扩容就<code>原来的大小 x 2 + 2</code>,可以考虑初始化StringBuilder的大小来提高代码的效率。</li></ol><h1 id="四、一些题目"><a href="#四、一些题目" class="headerlink" title="四、一些题目"></a>四、一些题目</h1><p>1.下面程序运行的结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//false String的equals有对参数进行instance of String判断</span></span><br><span class="line"></span><br><span class="line">StringBuffer s3 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s3.equals(<span class="string">"abc"</span>));  <span class="comment">//StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是</span></span><br><span class="line">System.out.println(s3.toString().equals(<span class="string">"abc"</span>)); <span class="comment">//true 比较的是值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">0</span>));   <span class="comment">//true,如果subString的index是0，直接返回对象</span></span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">1</span>));   <span class="comment">//false,不为0就new一个sub之后的对象返回</span></span><br></pre></td></tr></table></figure></p><p>除此之外,<code>toLowerCase</code>和<code>toUpperCase</code>都是new一个对象返回</p><p>2.下面语句一共创建了多少个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure></p><p>这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是<code>两个</code>,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、String的不可变性&quot;&gt;&lt;a href=&quot;#一、String的不可变性&quot; class=&quot;headerlink&quot; title=&quot;一、String的不可变性&quot;&gt;&lt;/a&gt;一、String的不可变性&lt;/h1&gt;&lt;p&gt;咱们先来看一下String类的声明&lt;br&gt;&lt;figu
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础1.1 — Java八大基本数据类型及其包装类</title>
    <link href="http://yoursite.com/2019/03/23/Java%E5%9F%BA%E7%A1%801.1%20%E2%80%94%20Java%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/</id>
    <published>2019-03-23T05:36:43.063Z</published>
    <updated>2019-09-19T13:15:53.555Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">数据类型</th><th style="text-align:center">大小/位</th><th style="text-align:center">封装类</th><th style="text-align:center">默认值</th><th style="text-align:center">可表示数据范围</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Byte</td><td style="text-align:center">0</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Short</td><td style="text-align:center">0</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Integer</td><td style="text-align:center">0</td><td style="text-align:center">-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Long</td><td style="text-align:center">0L</td><td style="text-align:center">-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Float</td><td style="text-align:center">0F</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Double</td><td style="text-align:center">0D</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Character</td><td style="text-align:center">空</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">boolean</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Boolean</td><td style="text-align:center">false</td><td style="text-align:center">true或false</td></tr></tbody></table><blockquote><p>无需记忆可表示范围，在JDK里面数据类型可承载的最大最小值已经在包装类里面用常量的形式表示出来了<br>如:<code>Integer.MIN_VALUE</code><br><code>Integer.MAX_VALUE</code><br><code>Integer.SIZE</code></p></blockquote><h2 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h2><ul><li>整型：byte、short、int、long</li><li>浮点型：float、double</li><li>逻辑型：boolean</li><li>字符型：char</li></ul><h2 id="2、类型转换"><a href="#2、类型转换" class="headerlink" title="2、类型转换"></a>2、类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">short</span> -&gt; <span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>从左到右的数据类型转换都是隐式转换，无需强转。</p><p>从右到做的数据类型转换需要强转，并且会损失精度</p><h1 id="二、包装类"><a href="#二、包装类" class="headerlink" title="二、包装类"></a>二、包装类</h1><p>java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值,而包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址</p><h2 id="1、自动拆箱和自动装箱"><a href="#1、自动拆箱和自动装箱" class="headerlink" title="1、自动拆箱和自动装箱"></a>1、自动拆箱和自动装箱</h2><p>在JDK1.5以后，提供了自动拆箱和自动装箱功能这样的”语法糖”,如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自动装箱</span></span><br><span class="line">Integer i = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//转换成了</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException</span></span><br></pre></td></tr></table></figure></p><p>从字节码看出也是一样的</p><p>(通过idea搜索<code>jclasslib bytecode viewer</code>插件查看更方便，安装后在 <code>View-&gt;Show Bytes Code With jclasslib</code>)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> iconst_1</span><br><span class="line"> 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">9</span> astore_2</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>同样地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱</span></span><br><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;,</span><br><span class="line"><span class="comment">//后面一句转换成了</span></span><br><span class="line"><span class="keyword">int</span> j = i.intValue();</span><br></pre></td></tr></table></figure></p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> aload_1</span><br><span class="line"> 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"> <span class="number">9</span> istore_2</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"><span class="number">14</span> istore_3</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>由此也可以看出，自动拆装箱属于<code>编译特性</code></p><h2 id="2、缓存池"><a href="#2、缓存池" class="headerlink" title="2、缓存池"></a>2、缓存池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Byte</code>都是用缓存池里面的值</li><li><code>Short、Integer、Long</code>会缓存 <code>-128~127</code></li><li><code>Float和Double</code>则直接返回，因为精度数不能每次都一样，所以缓存没有意义</li><li><code>Character</code>则是缓存 <code>&lt;=127</code></li><li><code>Boolean</code>,只有两个值，直接就用常量的形式表示出来了</li></ul><h1 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h1><ul><li>double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是<code>false</code>,所以在进行带精度计算时，需要用到<code>BigDecimal</code></li><li>switch中只能用byte、char、short、int，JDK1.7后可用String</li><li>Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型</li><li>两边都是包装类的<code>equals</code>比较值，<code>==</code> 比较引用，其中一边是表达式的，<code>==</code> 就是比较数值</li></ul><h1 id="四、题目"><a href="#四、题目" class="headerlink" title="四、题目"></a>四、题目</h1><p>1.下面语句做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>; <span class="comment">//valueOf()自动装箱成Integer类型</span></span><br><span class="line">i+=<span class="number">1</span>;<span class="comment">//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer</span></span><br></pre></td></tr></table></figure></p><p>2.下面程序语句有什么问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;  <span class="comment">//编译不通过、需要强转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s2 =<span class="number">1</span>;</span><br><span class="line">s2 += <span class="number">1</span>;  <span class="comment">//正常编译</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//NullPointException</span></span><br></pre></td></tr></table></figure></p><p>3.下面程序的运行结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//false 比较了对象</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//true 缓存了-128~127</span></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="number">1f</span>;</span><br><span class="line">Float f2 = <span class="number">1f</span>;</span><br><span class="line">System.out.println(f1 == f2) <span class="comment">//false 始终new新对象</span></span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/BuquTianya/article/details/80685437" target="_blank" rel="noopener">https://blog.csdn.net/BuquTianya/article/details/80685437</a></p><ul><li>char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;序号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;大小/位&lt;/th&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>创建Hexo博客并部署到云主机</title>
    <link href="http://yoursite.com/2018/06/18/%E5%88%9B%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/06/18/创建Hexo博客并部署到云主机/</id>
    <published>2018-06-18T09:50:21.000Z</published>
    <updated>2019-09-19T13:20:57.137Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p><h1 id="一、云服务器配置-Ubuntu-16-04-LTS"><a href="#一、云服务器配置-Ubuntu-16-04-LTS" class="headerlink" title="一、云服务器配置(Ubuntu 16.04 LTS)"></a>一、云服务器配置(Ubuntu 16.04 LTS)</h1><h3 id="安装git和nginx"><a href="#安装git和nginx" class="headerlink" title="安装git和nginx"></a>安装<code>git</code>和<code>nginx</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git-core nginx</span><br></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>创建目录用于存放静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/www/blog</span><br></pre></td></tr></table></figure><p>创建一个Nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure><p>键入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">listen 8080;</span><br><span class="line">root /var/www/blog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h3 id="配置Git-Hooks"><a href="#配置Git-Hooks" class="headerlink" title="配置Git Hooks"></a>配置Git Hooks</h3><p>生成<code>blog.git</code>作为仓库，当本地Push过来时自动同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/blog.git &amp;&amp; cd ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p>创建<code>Hooks</code>脚本，当<code>blog.git</code>收到Push时自动执行<code>post-receive</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>然后脚本里面做的操作就是自动clone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/www/blog</span><br><span class="line">sudo git clone /root/blog.git /var/www/blog</span><br></pre></td></tr></table></figure><p>最后再给个权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h1 id="二、本地相关配置-Mac-OS"><a href="#二、本地相关配置-Mac-OS" class="headerlink" title="二、本地相关配置(Mac OS)"></a>二、本地相关配置(Mac OS)</h1><h3 id="安装相关软件"><a href="#安装相关软件" class="headerlink" title="安装相关软件"></a>安装相关软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"></span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>然后安装<code>Hexo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>在自己想要的目录执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heox init .</span><br></pre></td></tr></table></figure><p>目录如下</p><p><img src="/media/15293158035733-1.jpg" alt="15293158035733"></p><p>在目录下找到配置文件<code>_config.yml</code>并修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: root@152.92.13.78:blog.git(例)</span><br></pre></td></tr></table></figure><div class="tip"><br>云服务器最好是使用SSH登录，那种比较方便，通过以下命令即可添加<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~./ssh/id_dsa</span><br></pre></td></tr></table></figure><br><br>删除<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -d ./ssh/id_xxx.pub</span><br></pre></td></tr></table></figure><br><br>查看<br>#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><br><br></div><h1 id="三、执行"><a href="#三、执行" class="headerlink" title="三、执行"></a>三、执行</h1><p>最后在本地生成静态文件后再进行部署即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>访问<code>152.92.13.78:8080(例)</code>即为博客站点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、云服务器配置-Ubuntu-16-04-LTS&quot;&gt;&lt;a href=&quot;#一、云服务器配置-U
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)</title>
    <link href="http://yoursite.com/2018/06/18/Android%20%E8%B0%B7%E6%AD%8C%E4%BA%B2%E5%84%BF%E5%AD%90%E7%B3%BB%E5%88%97%E7%BA%BF%E5%88%B7%E5%AE%98%E6%96%B9%E5%87%BA%E5%8E%82%E5%8C%85(Nexus%206P%E4%B8%BA%E4%BE%8B)/"/>
    <id>http://yoursite.com/2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/</id>
    <published>2018-06-18T06:48:11.000Z</published>
    <updated>2019-09-19T13:22:07.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h1><p>官方链接 <a href="https://developers.google.com/android/images" target="_blank" rel="noopener">官方出厂包下载(FQ)</a></p><hr><h1 id="二、修改"><a href="#二、修改" class="headerlink" title="二、修改"></a>二、修改</h1><p>解压出来是这个样子<br><img src="/media/15293050030148.jpg" alt="15293050030148"></p><p>需要把里面的zip文件也解压并且放到同一目录<br><img src="/media/15293049424410.jpg" alt="15293049424410"></p><hr><h1 id="三、开始刷机"><a href="#三、开始刷机" class="headerlink" title="三、开始刷机"></a>三、开始刷机</h1><p>最后利用adb进入bootfast模式重启并连接上手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>直接运行<code>flash-all.sh</code>即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; title=&quot;一、下载&quot;&gt;&lt;/a&gt;一、下载&lt;/h1&gt;&lt;p&gt;官方链接 &lt;a href=&quot;https://developers.google.com/android/images&quot; ta
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>

{"meta":{"title":"Wenk.Chan的个人博客","subtitle":null,"description":null,"author":"Wenk.Chan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"Java/Thread/2019-11-21","date":"2019-11-21T08:36:44.055Z","updated":"2019-11-21T09:36:16.769Z","comments":true,"path":"2019/11/21/Java/Thread/2019-11-21/","link":"","permalink":"http://yoursite.com/2019/11/21/Java/Thread/2019-11-21/","excerpt":"","text":"新军事系列(801~830)801 小飞机802 挎斗摩托803 小军车804 侦察机805 小坦克806 追击807 吹号兵808 哨站809 堵截军车810 战斗机811 载兵车812 火箭炮813 两栖车814 装甲车815 冲锋艇816 潜艇817 悍马818 武装直升机819 海兵炮营820 护卫舰821 导弹巡洋舰822 导弹车823 坦克824 军官指挥车825 指挥部826 航母827 老特务828 炮兵829 探雷兵830 小战车","categories":[],"tags":[]},{"title":"","slug":"Java/Collections/2019-11-19","date":"2019-11-19T10:44:26.320Z","updated":"2019-11-19T10:52:05.556Z","comments":true,"path":"2019/11/19/Java/Collections/2019-11-19/","link":"","permalink":"http://yoursite.com/2019/11/19/Java/Collections/2019-11-19/","excerpt":"","text":"早期","categories":[],"tags":[]},{"title":"","slug":"Algorithm/树","date":"2019-11-09T00:37:14.962Z","updated":"2019-11-09T00:53:38.870Z","comments":true,"path":"2019/11/09/Algorithm/树/","link":"","permalink":"http://yoursite.com/2019/11/09/Algorithm/树/","excerpt":"","text":"二叉树:每个节点最多包含两棵子树，分别为左子树和右子树 满二叉树 国内定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。 国外定义：满二叉树的结点要么是叶子结点，度为0，要么是度为2的结点，不存在度为1的结点。 完全二叉树:从根结点开始，依次从左到右填充树结点 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。","categories":[],"tags":[]},{"title":"Java集合(七) — Queue","slug":"Java/Collections/Java集合(七) — Queue","date":"2019-11-08T10:40:43.513Z","updated":"2019-11-09T05:23:16.769Z","comments":true,"path":"2019/11/08/Java/Collections/Java集合(七) — Queue/","link":"","permalink":"http://yoursite.com/2019/11/08/Java/Collections/Java集合(七) — Queue/","excerpt":"","text":"一、概述Queue一般用来存放等待处理元素，这种场景一般用于缓冲、并发访问 下面是Queue的一些基本方法1234567891011121314public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; //插入（抛出异常） boolean add(E e); //插入（返回特殊值） boolean offer(E e); //移除（抛出异常） E remove(); //移除（返回特殊值） E poll(); //检查（抛出异常） E element(); //检查（返回特殊值） E peek();&#125; 下面来看一下Java中的一些非并发Queue 二、PriorityQueue1、概述PriorityQueue也叫做优先级队列，每次取出的元素都是队列中优先级最高的 下面是它的特性 基于优先级堆实现的无界优先队列 元素自然排序，或者在构造方法传入实现的Comparator排序 不允许null元素 不允许不可比较的元素 非线程安全 迭代器的迭代顺序无法保证 PriorityQueue是基于堆实现的，而堆是用完全二叉树处理数据的 完全二叉树:若二叉树的深度是h，那么除第h层外，其他各层（1～h-1）层的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树 堆也分为最大堆和最小堆 最大堆:根节点是所有节点中最大的元素,而且每个节点的值都比子节点大最小堆:根节点是所有节点中最小的元素,而且每个节点的值都比子节点小 而PriorityQueue默认是基于最小堆实现的,而且底层通过数组来构建数据结构 2、属性1234567891011121314151617public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; // 使用数组来构造堆，也就是优先级队列 transient Object[] queue; // 数组默认的初始化容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 队列的容量 private int size = 0; // 比较器 private final Comparator&lt;? super E&gt; comparator; // 结构化修改次数 transient int modCount = 0; // 数组最大容量限制，Integer最大值-8是说一些虚拟机可能会在数组中保留一些header words的空间， // 所以没有取Integer最大值 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&#125; PriorityQueue是继承自AbstractQueue,AbstractQueue实现了Queue接口，封装了一些队列基础的方法。 注释里面有写到父节点和子节点下标值之间的关系12childLeftNode= 2 * parentNode + 1; childRightNode= 2 * (parentNode + 1); 4、构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 默认构造方法，初始化容量为11，比较器为空 */public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null);&#125;/** * 指定具体容量的构造方法 */public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null);&#125;/** * 指定比较器的构造方法 */public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator);&#125;/** * 指定容量和比较器的构造方法， */public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125;/** * 将集合转换为队列，根据集合类型不同，又分为三种情况 */public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; if (c instanceof SortedSet&lt;?&gt;) &#123; SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) ss.comparator(); initElementsFromCollection(ss); &#125; else if (c instanceof PriorityQueue&lt;?&gt;) &#123; PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) pq.comparator(); initFromPriorityQueue(pq); &#125; else &#123; this.comparator = null; initFromCollection(c); &#125;&#125; 5、重点方法add方法内部都是通过offer来实现的 offer1234567891011121314151617181920212223public boolean add(E e) &#123; return offer(e);&#125;public boolean offer(E e) &#123; //1.判空 if (e == null) throw new NullPointerException(); //2.结构化修改次数+1 modCount++; int i = size; //3.判断是否扩容 if (i &gt;= queue.length) grow(i + 1); size = i + 1; //4.首个元素直接添加 if (i == 0) queue[0] = e; else //5.不是首个元素则上浮 siftUp(i, e); return true;&#125; 扩容grow12345678910111213141516171819private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // 如果容量小于64，则翻倍，大于则增加原来的一半 int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; siftUp1234567891011121314151617181920212223242526private void siftUp(int k, E x) &#123; //根据是否有比较器选用对应的处理方法,处理方法类似 if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125; @SuppressWarnings(\"unchecked\")private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; // 1.通过无符号右移，计算并获取父级结点下标， // -&gt; parent = (thisNode -1) / 2 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; // 2.如果入参大于父节点，则不需要移动，结束 if (comparator.compare(x, (E) e) &gt;= 0) break; // 3.小于父节点,则父节点下沉 queue[k] = e; // 4.改变下标 k = parent; &#125; //5.把当前节点值放到对应位置上 queue[k] = x;&#125; 出队peek和poll12345678910111213141516171819202122//取出堆中最小值public E peek() &#123; return (size == 0) ? null : (E) queue[0];&#125;public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; // 1.取堆中最小值 E result = (E) queue[0]; // 2.取数组中最后一个元素的值 E x = (E) queue[s]; // 3.将堆中最后一个值设置为null queue[s] = null; // 4.如果数组不是只有一个元素，执行下沉操作 if (s != 0) // 下沉操作 siftDown(0, x); return result;&#125; siftDown12345678910111213141516171819202122232425262728293031private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125;private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; // 计算非叶子结点元素的最大位置，循环的终止条件（在最后一个非叶子节点处结束） int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; // 计算k位置处的左子结点 int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; // 右子结点等于左子结点下标加1 int right = child + 1; // 获取左右孩子中值较小的值 if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; // 然后重新和父结点进行比较，如果大于父结点，不需要移动，结束 if (key.compareTo((E) c) &lt;= 0) break; // 父结点下移 queue[k] = c; // 改变下标，循环此操作 k = child; &#125; queue[k] = key;&#125; remove123456789101112131415161718192021222324252627282930313233343536373839public boolean remove(Object o) &#123; //获取元素的下标 int i = indexOf(o); if (i == -1) return false; else &#123; removeAt(i); return true; &#125;&#125;/** * 执行移除操作 */private E removeAt(int i) &#123; // assert i &gt;= 0 &amp;&amp; i &lt; size; modCount++; int s = --size; // 如果要移除的就是最后一个元素，赋值为null if (s == i) // removed last element queue[i] = null; else &#123; // 取队列尾元素 E moved = (E) queue[s]; // 将队尾元素置为null queue[s] = null; // 下沉操作 siftDown(i, moved); // 如果下移后元素位置没发生变化，说明moved的左右子结点都大于moved，这时就需要上浮操作 if (queue[i] == moved) &#123; // 上浮操作 siftUp(i, moved); // 如果上浮之后发生了元素位置 if (queue[i] != moved) return moved; &#125; &#125; return null;&#125; 三、 ArrayDeque另外，Deque是双端队列，在Queue的基础上增加了针对双端添加和删除元素的方法实现了ArrayDeque的非并发集合有ArrayDeque,还有LinkedArrayList下面是Deque的一些基本方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; //从头部插入（抛异常） void addFirst(E e); //从尾部插入（抛异常） void addLast(E e); //从头部插入（特殊值） boolean offerFirst(E e); //从尾部插入（特殊值） boolean offerLast(E e); //从头部移除（抛异常） E removeFirst(); //从尾部移除（抛异常） E removeLast(); //从头部移除（特殊值） E pollFirst(); //从尾部移除（特殊值） E pollLast(); //从头部查询（抛异常） E getFirst(); //从尾部查询（抛异常） E getLast(); //从头部查询（特殊值） E peekFirst(); //从尾部查询（特殊值） E peekLast(); //（从头到尾遍历列表时，移除列表中第一次出现的指定元素） boolean removeFirstOccurrence(Object o); //（从头到尾遍历列表时，移除列表中最后一次出现的指定元素） boolean removeLastOccurrence(Object o); boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); void push(E e); E pop(); boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator();&#125; ArrayDeque比较值得关注的可能就是构造方法分配容量因为ArrayDeque需要满足容量是2^n，所以就有了以下算法123456789101112131415161718private void allocateElements(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests \"&lt;=\" because arrays aren't kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; elements = new Object[initialCapacity];&#125; 因为2^n不管n是多少，转换为二进制的话，所有位都是1，然后+1，所以，这个算法是把传入参数的所有位都置为1，然后再加1","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java集合(六) — Set","slug":"Java/Collections/Java集合(六) — Set","date":"2019-11-08T04:07:35.665Z","updated":"2019-11-08T12:56:40.235Z","comments":true,"path":"2019/11/08/Java/Collections/Java集合(六) — Set/","link":"","permalink":"http://yoursite.com/2019/11/08/Java/Collections/Java集合(六) — Set/","excerpt":"","text":"一、概述Set是由无重复对象组成的集合,标准是 不能有两个引用指向同一个对象 不能有两个引用指向null 使用equals方法比较两个对象不相等 Set的实现通常都是基于Map的，因为Map的key是唯一的，value没有用到，只需要占位即可。 二、HashSetHashSet是基于HashMap实现的，所以也具有HashMap的特性 允许使用null 不保证顺序 非同步 1、构造方法1234567891011121314151617181920212223public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 通过构造方法，一下子就知道，HashSet就是通过HashMap来实现的 2、API操作HashSet的操作方法基本都是通过HashMap来实现的值是存放在HashMap的key上，value是PRESENT的固定值123456789101112131415161718192021222324252627 public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125;public int size() &#123; return map.size();&#125;public boolean isEmpty() &#123; return map.isEmpty();&#125;public boolean contains(Object o) &#123; return map.containsKey(o);&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;public void clear() &#123; map.clear();&#125; 四、LinkedHashSetLinkedHashSet是继承于HashSet的，而且在HashSet里面有一个专门提供给LinkedHashSet的构造方法，123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 所以LinkedHashSet是基于LinkedHashMap的，所以也拥有LinkedHashMap的特性，可以保证有序 下面是LinkedHashSet的内容，其实也只有构造方法，使用的都是父类HashSet的方法。 12345678910111213141516171819202122private static final long serialVersionUID = -2851667679971038690L;public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125; public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125; public LinkedHashSet() &#123; super(16, .75f, true);&#125;public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125; 五、TreeSet","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java基础(九) — 其他","slug":"Java/Basic/Java基础(九) — 其他","date":"2019-11-07T01:22:43.783Z","updated":"2019-11-07T03:42:24.611Z","comments":true,"path":"2019/11/07/Java/Basic/Java基础(九) — 其他/","link":"","permalink":"http://yoursite.com/2019/11/07/Java/Basic/Java基础(九) — 其他/","excerpt":"","text":"一、==与equals==:基础数据类型比较的是值，引用比较的是内存地址，即两个对象是否同一个equals:默认情况下，equals的作用与==一样是比较对象。有些类会将equals方法重写，如String重写比较的是对象的值 二、equals与hashCodehashCode方法定义在Object.java中，说明任何一个Java类都有hashCode方法hashCode的作用是获取哈希码,特点是能够根据”key”迅速获取对应的”value”,而且hashCode相等的两个对象不一定相等(碰撞)，所以比较两个对象是否相等时 先判断hashCode是否存在相同的 发现了相同hashCode的对象才会时候equals去判断 这样会大大减少equals使用的频率，提高执行速度 三、类内元素加载顺序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//定义一个构造代码块public class Block &#123; Block(String who) &#123; System.out.println(who+\" new\"); &#125;&#125; //定义一个父类 public class Father &#123; static Block staticblock = new Block(\"father static\"); Block block = new Block(\"father\"); static &#123; System.out.println(\"father static block\"); &#125; &#123; System.out.println(\"father block\"); &#125; Father() &#123; System.out.println(\"father constructor\"); &#125;&#125;//定义一个子类public class Son extends Father &#123; static Block staticblock = new Block(\"son static\"); Block block = new Block(\"son\"); static &#123; System.out.println(\"son static block\"); &#125; &#123; System.out.println(\"son block\"); &#125; Son() &#123; System.out.println(\"son constructor\"); &#125;&#125;//运行public class Main &#123; public static void main(String argr[])&#123; Son son=new Son(); &#125;&#125; 输出结果为12345678910father static newfather static blockson static newson static blockfather newfather blockfather constructorson newson blockson constructor 可以看出加载顺序是 父类静态成员变量 父类静态代码块 子类静态成员变量 子类静态代码块 父类非静态成员变量 父类非静态代码块 父类构造方法 子类非静态成员变量 子类非静态代码块 子类构造方法 由此也可以得知执行子类构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误 四、引用类型在Java中，Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类，分别有以下四种 引用类型 取得对象的方式 垃圾回收条件 是否可能内存泄露 强引用 调用new 不回收 可能 软引用 通过get()方法 内存低时回收 不可能 弱引用 通过get()方法 下一次GC 不可能 虚引用 无法获得 不回收 可能 1、强引用如果一个对象具有强引用，那么垃圾回收器绝对不会回收他，即时抛出异常 2、软引用如果一个对象具有软引用，内存足够的不会被回收，内存不足时就会被回收，可以用于实现内存敏感的高速缓存软引用可以与引用队列(ReferenceQueue)联合使用，如果软引用被回收了，就会被加入这个队列中 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();SoftReference&lt;String[]&gt; softBean = new SoftReference&lt;String[]&gt;(new String[]&#123;\"a\", \"b\", \"c\"&#125;, referenceQueue); 3、弱引用弱引用，一旦被发现一定会回收。但是垃圾回收器线程优先级比较低，不一样会马上发现弱引用也可以与引用队列(ReferenceQueue)联合使用，如果弱引用被回收了，就会被加入这个队列中 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();WeakReference&lt;String[]&gt; softBean = new WeakReference&lt;String[]&gt;(new String[]&#123;\"a\", \"b\", \"c\"&#125;, referenceQueue); 4、虚引用“虚引用”顾名思义，就是形同虚设。那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();PhantomReference&lt;String[]&gt; referent = new PhantomReference&lt;String&gt;(new String[]&#123;\"a\", \"b\", \"c\"&#125;, referenceQueue); 五、克隆为了快速构造一个和原有对象相同的副本，不比手动进行复制，所以就有了克隆这个操作克隆涉及到的方法就是Obejct的clone方法,任何克隆的过程都得经过这个方法1protected native Object clone() throws CloneNotSupportedException; 克隆分为浅克隆和深克隆,下面定义两个类来做一下实现 1234567891011121314151617181920212223public class Student implements Cloneable &#123; private String name; private int age; private Teacher teacher; public Student(String name, int age, Teacher teacher) &#123; this.name = name; this.age = age; this.teacher = teacher; &#125;&#125;public class Teacher implements Cloneable &#123; private String name; private String course; public Teacher(String name, String course) &#123; this.name = name; this.course = course; &#125;&#125; 1、浅克隆浅克隆的效果是复制出来的对象的所有变量与原来对象相同,而所有的对其他对象的引用仍然指向原对象 克隆对象实现一下Cloneable接口，并且在克隆的方法里面调用super.clone()就会返回克隆后的对象1234567891011121314151617181920212223public class Student implements Cloneable &#123; private String name; private int age; private Teacher teacher; public Student(String name, int age, Teacher teacher) &#123; this.name = name; this.age = age; this.teacher = teacher; &#125; @Override public Student clone() &#123; Student student = null; try &#123; student = (Student) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return student; &#125;&#125; 测试代码 12345678910111213public static void main(String args[]) &#123; Teacher teacher = new Teacher(\"王老师\", \"英语\"); Student student = new Student(\"小明\", 11, teacher); Student clone = student.clone(); clone.setName(\"小强\"); clone.setAge(20); clone.getTeacher().setName(\"李老师\"); System.out.println(student.getName() + \" \" + student.getAge()); System.out.println(clone.getName() + \" \" + clone.getAge()); System.out.println(clone.getTeacher() == student.getTeacher()); &#125; 最后输出结果123小明 11小强 20true 由上面的结果可知道，克隆出来的对象name和age都是新的，而对象引用teacher还是原来的 2、普通深克隆深克隆的效果是，克隆出来所有变量都含有与原来对象相同的值，而引用指向的对象也是新创建的。 如果要实现深克隆，克隆对象里面的对象类型也必须要实现Cloneable接口并调用clone()对Teacher类进行修改123456789101112131415161718192021public class Teacher implements Cloneable &#123; private String name; private String course; public Teacher(String name, String course) &#123; this.name = name; this.course = course; &#125; public Teacher clone() &#123; Teacher clone = null; try &#123; clone = (Teacher) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 测试代码 1234567891011Teacher teacher = new Teacher(\"王老师\", \"英语\");Student student = new Student(\"小明\", 11, teacher);Student clone = student.clone();clone.setName(\"小强\");clone.setAge(20);clone.getTeacher().setName(\"李老师\");System.out.println(student.getName() + \" \" + student.getAge());System.out.println(clone.getName() + \" \" + clone.getAge());System.out.println(clone.getTeacher() == student.getTeacher()); 输出 123小明 11小强 20false 从输出结果就可以得知，两个对象的Teacher已经不是同一个了，但是，如果克隆的对象存在比较长的继承链，实现深克隆就必须每一层去实现Cloneable方法。但是有一个简便的方法，序列化克隆 3、serializable深克隆把对象序列化写进一个流里面，再读取出来，就是一个新的对象了 12345678910111213141516171819202122232425public class Student implements Serializable &#123; private String name; private int age; private Teacher teacher; public Student(String name, int age, Teacher teacher) &#123; this.name = name; this.age = age; this.teacher = teacher; &#125; public Student serializableClone() throws IOException, ClassNotFoundException &#123; Student clone; ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); clone = (Student) oi.readObject(); return clone; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java多线程(十一) — 线程池","slug":"Java/Thread/Java多线程(十一) — 线程池","date":"2019-11-06T11:31:19.411Z","updated":"2019-11-21T06:14:53.004Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(十一) — 线程池/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(十一) — 线程池/","excerpt":"","text":"一、概述当提交一个任务到线程池后，线程池处理任务的顺序 判断核心线程池是否都在执行任务。如果不是则新建一个执行任务，如果进入下一个判断 判断工作队列是否已满，如果未满，则加入工作队列，如果已满，进入下一个判断 判断线程池的线程是否都处于工作状态，如果不是，新建一个线程来执行任务，如果满了，执行饱和策略 如何合理选择线程池的参数","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(十) — 并发工具类","slug":"Java/Thread/Java多线程(十) — 并发工具类","date":"2019-11-06T11:30:15.112Z","updated":"2019-11-21T04:55:43.067Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(十) — 并发工具类/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(十) — 并发工具类/","excerpt":"","text":"一、CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作再执行。内部有一个通过共享锁实现的计数器初始化时需要传入一个int值作为计数器的初始值，也可以理解为共享锁的获取次数 当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。 当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 - 1。 当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。 二、CyclicBarrier它要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障 可以应用于合并计算结果的场景 不同CountDownLatch的是，CyclicBarrier可以对计数器进行reset 三、SemaphoreSemaphore(信号量)是用来控制同时访问特定资源的线程数量 四、ExchangerExchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(九) — 原子操作","slug":"Java/Thread/Java多线程(九) — 原子操作","date":"2019-11-06T11:25:22.941Z","updated":"2019-11-21T04:15:01.040Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(九) — 原子操作/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(九) — 原子操作/","excerpt":"","text":"一、概述Java从JDK1.5开始提供了除synchronized以外的方法来保证原子性，java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。Atomic包里一共提供了13个类，属于4种类型的原子更新方式 原子更新基本类型 原子更新数组 原子更新引用 原子更新属性Atomic包里的类基本都是使用Unsafe实现的包装类 二、原子更新基本类型类 AtomicBoolean:原子更新布尔类型。 AtomicInteger:原子更新整型。 AtomicLong:原子更新长整型。 以上3个类提供的方法几乎一模一样,以AtomicInteger为例 int addAndGet(int delta):以原子方式将输入的数值与实例中的值(AtomicInteger里的 value)相加，并返回结果。 boolean compareAndSet(int expect，int update):如果输入的数值等于预期值，则以原子方式将该值设为输入的值。 int getAndIncrement():以原子方式将当前值加1，注意，这里返回的是自增前的值。 void lazySet(int newValue):最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 int getAndSet(int newValue):以原子方式设置为newValue的值，并返回旧值。 除了以上之外的基本类型，char、float和double等，可以参照AtomicBoolean的方式进行原子操作因为Unsafe类关于基本类型的只有这三个方法，AtomicBoolean是先转换成整形再进行操作的123456789101112public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);//AtomicBoolean的compareAndSet方法public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125; 三、原子更新数组 AtomicIntegerArray:原子更新整型数组里的元素。 AtomicLongArray:原子更新长整型数组里的元素。 AtomicReferenceArray:原子更新引用类型数组里的元素。 以AtomicIntegerArray为例，方法也是类似与基本数据类型，对应操作对象换成对象索引罢了 四、原子更新引用类型 AtomicReference:原子更新引用类型。 AtomicReferenceFieldUpdater:原子更新引用类型里的字段。 AtomicMarkableReference:原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef，boolean initialMark)。 五、原子更新字段类 AtomicIntegerFieldUpdater:原子更新整型的字段的更新器。 AtomicLongFieldUpdater:原子更新长整型字段的更新器。 AtomicStampedReference:原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(八) — 并发容器","slug":"Java/Thread/Java多线程(八) — 并发容器","date":"2019-11-06T11:23:33.035Z","updated":"2019-11-21T03:55:19.124Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(八) — 并发容器/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(八) — 并发容器/","excerpt":"","text":"一、CopyOnWriteArrayList一般来说，CopyOnWriteArrayList是ArrayList的线程安全版本,适合读多写少的并发场景 在添加或者修改时，会复制出一个数组来完成操作，然后再将引用指向新数组，过程中用重入锁。如果增删改比较多，会占用很多内存 get或者遍历时，不加锁。读取的是旧的数据，因此只有数据只有最终一致性，没有实时一致性 二、CopyOnWriteArraySetCopyOnWriteArraySet内部容器是CopyOnWriteArrayList，在加入容器时，进行了addIfAbsent的判断，防止加入相同元素 三、ConcurrentSkipListMapConcurrentSkipListMap一般来说是TreeMap的线程安全版本，内部通过链表的跳表和CAS来实现的 ##跳表跳表是一种使用”空间换时间”的概念用来提高查询效率的链表特性:1.由很多层组成，level越搞的层级点越少2.每一层的节点数据也都是有顺序的3.上面层的节点肯定会在下面层出现4.每一个节点都有两个指针，分别是同一层的下一个节点和下一层节点的指针 查询元素的时候从最上层开始找，根据比较逐渐往下缩小范围 新增元素会先确定Level层，在当前level和以下的level都加入新的元素而层数是通过一种随机算法获取的,如果Level大于跳表的层数,那么会新增一层 四、ConcurrentSkipListSetConcurrentSkipListSet内部是基于ConcurrentSkipListMap实现的，在加入容器时，进行了putIfAbsent的判断，防止加入相同元素","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(七) — Queue","slug":"Java/Thread/Java多线程(七) — Queue","date":"2019-11-06T11:22:23.590Z","updated":"2019-11-21T01:22:12.665Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(七) — Queue/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(七) — Queue/","excerpt":"","text":"一、ConcurrentLinkedQueueConcurrentLinkedQueue是一个基于链接节点的无界线程队列，使用FIFO规则对节点进行排序，采用了CAS算法进行实现出队入队，判空时要使用isEmpty 二、BlockingQueue1、概述阻塞队列是在一个支持两个附加操作的队列 当队列满时，队列会阻塞插入元素的线程，直到不满 当队列空时，获取元素的线程会等待队列变为非空 2、JDK提供的阻塞队列ArrayBlockingQueue由数组组成的有界阻塞队列,内部使用ReentrantLock实现了公平、非公平锁,默认是不公平12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; LinkedBlockingQueue用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 PriorityBlockingQueue支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。可以通过Comparator进行自定义，不保证同等级的元素的优先级123456789public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.lock = new ReentrantLock(); this.notEmpty = lock.newCondition(); this.comparator = comparator; this.queue = new Object[initialCapacity];&#125; DelayQueue支持延时获取元素的无界阻塞队列,使用PriorityQueue实现，队列中的元素必须实现Delayed接口，应用场景 缓存系统:保存缓存元素的有效期，线程循环查询，一旦能从中获取元素，表示缓存过期 定时任务调度:保存当天将会执行的任务和执行时间，一旦从中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。 SynchronousQueue不存储元素的阻塞队列,每一个put操作必须等待一个take操作,否则不能继续添加元素,123public SynchronousQueue(boolean fair) &#123; transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125; 支持公平访问，适合传递性场景，吞吐量高 LinkedTransferQueue由链表结构组成的无界阻塞队列,与其他阻塞队列相比，多了tryTransfer和transfer方法 transfer如果有正在等待的消费者，可以通过transfer马上传递给消费者，没有则放到队尾 tryTransfer尝试是否直接传给消费者，如果没有则返回falseLinkedBlockingDeque由链表结构组成的双向阻塞队列,可以从队列的两端插入和移出元素,而且可以运用在工作窃取模式中 ####工作窃取算法把一个大任务分割(fork)成互不依赖的小任务，减少线程间的竞争，然后把子任务放到不同的队列中，每个队列创建一个线程去执行任务有的线程把自己的任务执行完毕，回去别的队列窃取任务进行执行因为访问同一个队列，为了减少线程竞争，会使用双端队列，一头窃取，一头正常运行都完成之后合并结果(join) 对于这种模式，JDK中提供了Fork/Join框架的实现 ForkJoinTask使用Fork/Join框架，必须首先创建一个ForkJoin任务,一般会使用继承于ForkJoinTask的两个子类 RecursiveAction:用于没有返回结果的任务。 RecursiveTask:用于有返回结果的任务。 ForkJoinPoolForkJoinTask需要通过ForkJoinPool来执行,内部维护了一个双端队列 123456789101112131415161718192021222324252627282930313233343536public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private static final int THRESHOLD = 2; // 阈值 private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; // 如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= THRESHOLD; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); // 执行子任务 CountTask rightTask = new CountTask(middle + 1, end); leftTask.fork(); rightTask.fork(); // 等待子任务执行完，并得到其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125;&#125; 因为无法在主线程抛出异常，内部提供了isCompletedAbnormally方法来判断是否抛出了异常获取任务已取消 3、实现原理比如使用Condition，队列满了生产者会停止生产并且阻塞(LockSupport.park(this))，这时消费者如果消费了队列中的元素，就会通知生产者队列可以用,继续生产","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(六) — ConcurrentHashMap","slug":"Java/Thread/Java多线程(六) — ConcurrentHashMap","date":"2019-11-06T11:21:41.648Z","updated":"2019-11-20T03:21:45.188Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(六) — ConcurrentHashMap/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(六) — ConcurrentHashMap/","excerpt":"","text":"一、概述ConcurrentHashMap是一个线程安全的K-V集合。因为HashMap不是线程安全还有HashTable效率过低出现的. 二、原理1、JDK1.7内部基本结构ConcurrentHashMap JDK 1.7是由Segment数组结构和HashEntry数组结构组成,采取分段锁的方式实现线程安全Segment继承于ReentrantLock，扮演锁的角色 一个Segment对应一个HashEntry数组,每个HashEntry都是一个链表 主要成员变量1234567891011121314151617181920212223242526//用于根据给定的key的hash值定位到一个Segmentfinal int segmentMask;//用于根据给定的key的hash值定位到一个Segmentfinal int segmentShift;//HashEntry[]初始容量：决定了HashEntry数组的初始容量和初始阀值大小static final int DEFAULT_INITIAL_CAPACITY = 16;//Segment对象下HashEntry[]的初始加载因子：static final float DEFAULT_LOAD_FACTOR = 0.75f;//Segment对象下HashEntry[]最大容量：static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//Segment[]初始并发等级：决定了Segment[]的长度static final int DEFAULT_CONCURRENCY_LEVEL = 16;//最小Segment[]容量：static final int MIN_SEGMENT_TABLE_CAPACITY = 2;//最大Segement[]容量static final int MAX_SEGMENTS = 1 &lt;&lt; 16;//Segment[]final Segment&lt;K,V&gt;[] segments; 其中DEFAULT_INITIAL_CAPACITY、DEFAULT_LOAD_FACTOR、MAXIMUM_CAPACITY与HashEntry[]的构建有关。 DEFAULT_CONCURRENCY_LEVEL、MIN_SEGMENT_TABLE_CAPACITY、MAX_SEGMENTS与Segment[]的构建有关。 构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; //限制不能小于0 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); //并发等级不能大于segment[]长度 if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments //记录按位左移次数 int sshift = 0; //记录segment数组的大小 int ssize = 1; while (ssize &lt; concurrencyLevel) &#123;//对ssize进行二次方处理，服务hash算法 ++sshift; ssize &lt;&lt;= 1; //左移一位就是乘以2, &#125; //segmentShift、segmentMask用于元素在Segment[]数组的定位 this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; //初始容量不能大于HashEntry最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //c影响了每个Segment[]上要放置多少个HashEntry; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; //创建第一个segment对象，并创建该对象下HashEntry[] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); //创建Segment[]，指定segment数组的长度 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; //使用CAS方式，将上面创建的segment对象放入segment[]数组中; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] //对ConcurrentHashMap中的segment数组赋值 this.segments = ss;&#125; put12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); //根据hash值定位Segment[]的index int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; //使用CAS方式，从Segment[]中获取index所在的segment对象 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment //index处没有元素，则新建一个 s = ensureSegment(j); //调用segment的put方法 return s.put(key, hash, value, false);&#125; final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; //获取锁 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; //获取Segment中的HashEntry数组 HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; //根据index获取HashEntry对象 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) //对HashEntry进行扩容 rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue; &#125; get123456789101112131415161718public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; //使用volatile的方式保持可见性进行get if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; size1234567891011121314151617181920212223242526272829303132333435363738394041public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; //尝试计算三次之后，才进行加锁运算 if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; //前面三次前后计算如果相等，直接返回 if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; JDK1.8内部基本结构ConcurrentHashMap JDK1.8采用Node+CAS+Synchronized来保证并发安全进行实现底层采用数组+链表+红黑树的存储结构下面是主要的一些成员变量123456789101112131415161718192021222324252627282930313233343536// node数组最大容量：2^30=1073741824private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认初始值，必须是2的幕数private static final int DEFAULT_CAPACITY = 16;//数组可能最大值，需要与toArray（）相关方法关联static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//并发级别，遗留下来的，为兼容以前的版本private static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 负载因子private static final float LOAD_FACTOR = 0.75f;// 链表转红黑树阀值,&gt; 8 链表转换为红黑树static final int TREEIFY_THRESHOLD = 8;//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;private static final int MIN_TRANSFER_STRIDE = 16;private static int RESIZE_STAMP_BITS = 16;// 2^15-1，help resize的最大线程数private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;// 32-16=16，sizeCtl中记录size大小的偏移量private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;// forwarding nodes的hash值static final int MOVED = -1;// 树根节点的hash值static final int TREEBIN = -2;// ReservationNode的hash值static final int RESERVED = -3;// 可用处理器数量static final int NCPU = Runtime.getRuntime().availableProcessors();//存放node的数组transient volatile Node&lt;K,V&gt;[] table;/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义 *当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容 *当为0时：代表当时的table还没有被初始化 *当为正数时：表示初始化或者下一次进行扩容的大小private transient volatile int sizeCtl; Node是ConcurrentHashMap存储结构的基本单元,实际上是一个链表，只允许查询，不允许修改set1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; //val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序 volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return val; &#125; public final int hashCode() &#123; return key.hashCode() ^ val.hashCode(); &#125; public final String toString()&#123; return key + \"=\" + val; &#125; public final V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; public final boolean equals(Object o) &#123; Object k, v, u; Map.Entry&lt;?,?&gt; e; return ((o instanceof Map.Entry) &amp;&amp; (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp; (v = e.getValue()) != null &amp;&amp; (k == key || k.equals(key)) &amp;&amp; (v == (u = val) || v.equals(u))); &#125; /** * Virtualized support for map.get(); overridden in subclasses. */ Node&lt;K,V&gt; find(int h, Object k) &#123; Node&lt;K,V&gt; e = this; if (k != null) &#123; do &#123; K ek; if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek)))) return e; &#125; while ((e = e.next) != null); &#125; return null; &#125;&#125; TreeNode是为了实现红黑树而创建的类，与HashMap类似,当链表的节点数大于8时会转换成红黑树的结构，过TreeNode作为存储结构代替Node来转换成黑红树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next, TreeNode&lt;K,V&gt; parent) &#123; super(hash, key, val, next); this.parent = parent; &#125; Node&lt;K,V&gt; find(int h, Object k) &#123; return findTreeNode(h, k, null); &#125; /** * Returns the TreeNode (or null if not found) for the given key * starting at given root. */ final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123; if (k != null) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; q; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.findTreeNode(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); &#125; return null; &#125;&#125; 另外还有一个类TreeBin,用于存储TreeNode，和对TreeNode进行操作 初始化12public ConcurrentHashMap() &#123;&#125; ConcurrentHashMap函数的构造方法为空，初始化操作没有在这里实现，而是在put实现 put1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); //两次hash，减少hash冲突，可以均匀分布 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; //对这个table进行迭代 Node&lt;K,V&gt; f; int n, i, fh; //这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;//如果i位置没有数据，就直接无锁插入 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED)//如果在进行扩容，则先进行扩容操作 tab = helpTransfer(tab, f); else &#123; V oldVal = null; //如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; //表示该节点是链表结构 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //这里涉及到相同的key进行put就会覆盖原先的value if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; //插入链表尾部 pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123;//红黑树结构 Node&lt;K,V&gt; p; binCount = 2; //红黑树结构旋转插入 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表的长度大于8时就会进行红黑树的转换 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount);//统计size，并且检查是否需要扩容 return null;&#125; get123456789101112131415161718192021public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); //计算两次hash if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;//读取首节点的Node元素 if ((eh = e.hash) == h) &#123; //如果该节点就是首节点就返回 if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来 //查找，查找到就返回 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123;//既不是首节点也不是ForwardingNode，那就往下遍历 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; size1234567891011121314151617public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125;final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; //变化的数量 long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; 在JDK1.8版本中，对于size的计算，在扩容和addCount()方法就已经有处理了","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(五) — Lock","slug":"Java/Thread/Java多线程(五) — Lock","date":"2019-11-06T11:21:26.078Z","updated":"2019-11-21T00:06:10.929Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(五) — Lock/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(五) — Lock/","excerpt":"","text":"一、概述Lock是用来控制多个线程访问共享资源的方式，于synchronized的功能类似，但是在Lock的获取，释放，超时和可中断的功能上具有更加灵活的可操作性。比如以下的一些特定 尝试非阻塞获取锁 能被中断地获取锁 超时获取锁 Lock是一个接口,定义了锁获取和释放的一些基本操作 lock():获取锁，调用该方法当前线程将会获得锁，获得锁之后，从该方法返回 lockInterruptible():中断地获取锁，即在锁获取中可以中断当前线程 tryLock():尝试非堵塞获取锁,获取到则返回ture，否则返回false tryLock(long,TimeUnit):超时获取锁 unLock():释放锁 newCondition():获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait()方法，调用后，当前线程将释放锁 二、AQS1、概述AQS全称AbstractQueuedSynchronizer(队列同步器),用于构建锁或者其他同步组件的基础框架 AQS内部维护了一个(FIFO的双向队列)同步队列来完成同步状态的管理当前线程获取同步状态失败时，同步器会将当前线程和等待状态等信息构造成一个节点(Node),加入同步队列。同时阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。首节点获取成功后，会继续唤醒后继节点尝试获取同步状态 Node的信息 属性类型和名称 描述 int waitStatus 等待状态 CANCELLED 1 取消等待 SIGNAL -1 当前节点线程释放同步状或取消后,通知后继节点 CONDITION -2 等待在Condition中 PROPAGATE -3 下一次共享式同步状态获取将无条件地传播下去 INITIAL 0 初始状态 Node pre 前驱节点，尾插 Node next 后继节点 Node nextWaiter 等待队列中的后继节点 thread Thread 获取同步状态的线程 可重写方法AQS是一个抽象类，支持独占式和共享式地获取状态。抽象类中支持重写的方法有 方法名称 描述 protected boolean tryAcquire(int arg) 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后用CAS设置同步状态 protected boolean tryRelease(int arg) 独占式释放同步状态,等待获取同步状态的线程将有机会获取同步状态 protected int tryAcquireShared(int arg) 共享式获取同步状态,返回大于等于0的值,表示获取成功，反之，获取失败 protected boolean tryReleaseShared(int arg) 共享式释放同步状态 protected boolean isHeldExclusively() 当前同步器是否在独占模式下被线程占用,一般该方法表示是否被当前线程独占 模板方法AQS简化了锁的实现方式，屏蔽了同步状态管理，线程排队，等待和唤醒这些底层操作,并提供了一些模板方法 方法名称 描述 void acquire(int arg) 独占式获取同步状态，如果当前线程获取状态成功，则返回。否则，进入同步队列等待，该方法会调用重写的tryAcquire(int arg) void acquireInterruptibly(int arg) 与acquire(int arg)相同,多了响应中断 boolean tryAcquireNanos(int arg,long nanos) 在acquireInterruptibly(int arg)基础上加了超时限制， void acquireShared(int arg) 共享式的获取同步状态 void acquireSharedinterruptibly(int arg) 于acquireShared(int arg)相同，多了响应中断 tryAcquireSharedNanos acquireSharedinterruptibly(int arg)基础上加了超时限制 boolean release(int arg) 独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒 boolean releaseShared(int arg) 共享式的释放同步状态 CollectiongetQueuedThreads() 获取等待在同步队列上的线程集合 模板方法基本上分为三类 独占式获取于释放同步状态 共享式获取与释放同步状态 查询同步队列中的等待线程情况 AQS内部也提供了三个方法对同步状态进行更改 getState():获取当前同步状态 setState(int newState):设置当前同步状态 compareAndSetState(int expect,int update):使用CAS设置当前状态，保证原子性 2、独占式同步状态通过调用acquire方法可以获取同步状态12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; //调用自定义的方法获取同步状态 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //获取失败构造节点进入同步队列 selfInterrupt();&#125; 下面是，构造节点进入同步队列相关的代码123456789101112131415161718192021222324252627282930private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); //尝试在尾部添加新节点 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;//自旋，直到节点添加成功为止private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 下面是队列通过自旋尝试获取同步状态的方法123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123;//只有前驱节点是头结点可以获取同步状态 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 然后就是释放了123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head;//新的头结点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒新的头节点的后继节点 return true; &#125; return false;&#125; 小结 acquire调用尝试获取同步状态,成功则返回，不成功则进入addWaiter同步队列自旋判断自身前继节点是否头结点 如果是,acquireQueued尝试获取同步状态，移除队列，获取成功并执行相应逻辑后,设置为新的头节点 通过release唤醒后继结点进行自旋获取同步状态 3、共享式同步状态共享式和独占式区别在于在同一时刻是否能有多个线程获取到同步状态比如文件的读可以同时进行，写需要独占 当共享式访问资源时，其他共享式的访问都会被允许，而独占式访问会被阻塞独占式访问资源时,同一时刻其他访问会被堵塞 通过acquireShared可以共享地获取同步状态1234567891011121314151617181920212223242526272829303132public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) //调用重写的tryAcquireShared获取同步状态 doAcquireShared(arg);&#125;private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //自旋获取 final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //获取成功 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 下面是释放共享式的方法1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 释放同步状态后，唤醒后继节点，这里与独占式的区别是，tryReleaseShared必须确认同步状态线程安全释放(自旋CAS) 三、ReentrantLock1、概述ReentrantLock支持重进入的锁，表示该锁能支持一个线程对资源重复加锁。同时还支持公平与非公平的选择这里的公平指的是，在绝对时间上，先进行获取锁请求的一定先被满足，反之是不公平事实上公平的锁往往没有非公平的效率高(线程切换).公平锁主要功能是减少饥饿发生的概率，等待越久的请求越是优先满足 2、实现重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被阻塞,需要解决两个问题 线程再次获取锁识别获取锁的线程是否为当前占据锁的线程 锁的最终释放线程重复获取了多少次锁，就得有多少次释放，获取自增，释放自减，为0时表示锁已成功释放 四、ReentrantReadWriteLock1.概述ReentrantReadWriteLock是读写锁，维护了一个读锁和一个写锁,读锁可以允许多个线程访问，写锁阻塞访问读写锁有以下特性 保证写操作对读操作的可见性,如果存在读锁，则写锁不能被获取 有公平锁和非公平锁之分 支持重入,读锁获取了，还可以再次获取。写锁获取了，读写锁都可以再次获取 支持锁降级，同一个线程中，在没有释放写锁的情况下，可以申请读锁 2.实现读写锁也是基于AQS实现的，但是只有一个整形变量，所以，读写锁以按位切割的方式把变量分成了两个部分高16位表示读，低16位表示写 五、工具1、LockSupport当需要阻塞或唤醒一个线程的时候，需要LockSupport，LockSupport定义了一组公共静态方法，提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。 方法名称 描述 void park() 阻塞当前线程，如果调用unpark(Thread thread)方法或当前线程被中断,才能从park() void parkNanos(long nanos) 在park()基础上增加了超时返回 void parkUntil(long deadline) 阻塞当前线程指导，deadline,毫秒 void unpack(Thread thread) 唤醒指定线程 2、ConditionCondition跟Lock配合可以实现等待/通知模式,比Object自带的有一些加强使用上比较简单，调用Lock的newCondition即可123456789101112131415161718Lock lock = new ReentrantLock();Condition condition = lock.newCondition();public void conditionWait () throws InterruptedException &#123; lock.lock(); try &#123; condition.await();//释放锁并等待 &#125; finally &#123; lock.unlock(); &#125;&#125;public void conditionSignal () throws InterruptedException &#123; lock.lock(); try &#123; condition.signal();//通知当前线程从await返回,并且返回前获取了锁 &#125; finally &#123; lock.unlock(); &#125;&#125;","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(四) — synchronized","slug":"Java/Thread/Java多线程(四) — synchronized","date":"2019-11-06T11:21:12.941Z","updated":"2019-11-12T03:36:43.731Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(四) — synchronized/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(四) — synchronized/","excerpt":"","text":"synchronized的作用是保证方法或代码在运时，同一时刻只有一个方法可以进到临界区,同时还可以保证共享变量的内存可见性 synchronized可修饰的对象有 代码块synchronized(){}，范围是大括号{}括起来的部分,作用对象是小括号里的对象 方法，范围是整个方法,作用对象是调用这个方法的对象 静态方法,范围是整个静态方法,作用对象是这个类的所有对象 类，作用范围是synchronized后面括号部分，作用对象是类的所有对象 底层语义原理Java虚拟机中的同步基于进入和退出monitor对象实现,显式同步和隐式同步都是 (monitorenter和monitorexit指令) 而同步方法是由方法调用指令，读取运行时常量池中方法的ACC_SYNCHRONIZED标志来隐式实现的。 Java对象头在JVM中，对象在内存中的布局分为三块区域对象头、实例数据、填充数据 实例变量:存放类的属性数据信息，包括父类的属性信息，数组还包括数组长度，按4字节对齐 填充数据:由于虚拟机要求对象的起始地址必须是8字节的倍数,所以就有了填充,为了字节对齐 JVM中采用2个字存储对象头(数组是3个,多一个记录数组长度) 1、结构其主要结构是由Mark Word和Class Metadata Address组成 虚拟机位数 头对象结构 说明 32/64bit Mark Word 存储对象的HashCode、锁信息或分代年龄或GC标志 32/64bit Class Metadata Address 类型指针指向对象的类元数据，确认该对象是哪个类的实例 2、Mark Word各种锁状态下Mark Word存储情况 锁状态 25bit 4bit 1bit 是否是偏向锁 2bit 锁标志位 无锁状态 对象HashCode 对象分代年龄 0 01 偏向锁 线程ID(23bit) Epoch(2bit) 对象分代年龄 0 01 轻量级锁 指向锁记录的指针 对象分代年龄 0 00 重量级锁 指向重量级锁的指针 对象分代年龄 0 10 GC标记 空 对象分代年龄 1 11 synchronized在JDK1.6优化之后才出现偏向锁和轻量级锁 synchronized锁升级原理1、偏向锁偏向锁的意思是如果一个线程获取了一个偏向锁,在接下来的一段时间没有其他线程来竞争，那么持有偏向锁的线程再次进入同步代码时，不再需要抢占锁和释放锁的操作 适合一个线程的场景 -XX:BiasedLockingStartupDelay=0 可以设置偏向锁启动的延迟-XX:UseBiasedLocking=false 如果确认通常是竞争状态，可关闭偏向锁，默认会进入轻量级锁 偏向锁获取方式 首先判断目标对象的对象头，根据标识和epoch判断是否处于可偏向状态 是的话，通过CAS将自己的线程ID复制到对象头的Mark Work,继续执行 不是的话，判断自己的线程ID跟对象头Mark Work中的是否相等，相等证明已获得,继续执行不用进行竞争和释放操作 如果不相等，需要撤销偏向锁，升级轻量级锁 2、轻量级锁当偏向锁撤销，有两种情况 线程已经退出同步代码,接下来就是撤销偏向锁,升级为轻量级锁 线程正在执行同步代码，原来的线程会继续持有锁并且升级为轻量级锁 适合追求相应速度，同步块执行速度快 轻量级锁获取方式 JVM会在当前的线程栈帧中创建一个用于存储锁记录的空间 将对象头的Mark Work的记录复制到锁记录中 线程尝试用CAS将对象头Mark Work替换为指向所记录空间的指针 替换成功,则当前线程获取轻量级锁 替换失败，则存在其他线程竞争，CAS若干次失败后，会升级成重量级锁 3、重量级锁因为CAS消耗资源，一旦升级成重量级锁，就不会降级，其他线程访问就会出现堵塞的状态 适合吞吐量高，同步块执行时间长 重量级锁依赖对象内部的monitor锁实现，而monitor又依赖操作系统的MutexLock(互斥锁)重量级锁开销比较大的原因是，阻塞和唤醒一个线程，都需要通过操作系统完成，从用户态转换到内核态相对耗时","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(三) — volatile","slug":"Java/Thread/Java多线程(三) — volatile","date":"2019-11-06T11:13:45.659Z","updated":"2019-11-13T02:02:22.487Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(三) — volatile/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(三) — volatile/","excerpt":"","text":"一、概述Java允许线程访问共享变量，为了确保共享变量能被准确和一直地更新，线程应该通过排他锁获得这个变量，所以就有了volatile如果一个字段被声明为volatile,那么Java线程内存模型会确保，所有线程看到这个变量的值都是一致的 简而言之，volatile有以下特性 可见性:对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写 原子性:对任意单个volatile变量的读/写具有原子性，但是类似i++这种操作没有 但是volatile是无法完全保证原子性，可以采用方法有 synchronized关键字 Lock AtomicInteger等原子操作类 二、实现原理1i = i + 1; 当线程执行这条语句时 复制一份到高速缓存 执行完+1操作后的值，写入高速缓存 最后再把高速缓存中的值刷新到主内存中 在单核CPU中是没问题的，但是多核CPU就不一样了线程A和线程B有可能同时读取一份到高速缓存，然后分别操作和写入到主内存中期望结果是2，但是最后出来的是1 被volatile关键字修饰的变量之后，在汇编代码中，会多出一个Lock前缀指令Lock前缀指令在多核处理器中会发生两件事情 将当前CPU的缓存行数据写到系统内存 其他CPU如果缓存了该内存地址的数据，会因为缓存一致性协议(MESI,嗅探技术)而被设置为无效 缓存行： CPU Cache中的最小单位 当其他CPU对这个数据进行修改操作时，会重新从系统内存中把数据读取到自己的缓存中 三、内存语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 指令重排序指编译器和处理器为了优化程序性能而堆指令序列进行重新排序的一种手段 编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令集并行重排序。如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序 内存系统的重排序。由于处理器使用缓存和读/写缓存区，使得加载和存储操作看上去是乱序执行 而为了实现volatile的内存语义，JMM会对重排序进行限制,在内存中，这个限制就是内存屏障 内存屏障:一组处理器指令，用于实现对内存操作的顺序限制 四、使用场景 对变量的写操作不依赖当前值 该变量没有包含在具有其他变量的不变式中 这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 状态标记量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(二) — Thread类","slug":"Java/Thread/Java多线程(二) — Thread类","date":"2019-11-06T11:13:15.762Z","updated":"2019-11-14T02:44:49.775Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(二) — Thread类/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(二) — Thread类/","excerpt":"","text":"一、概述在Java中，自带对多线程技术的支持，实现多线程编程的方式主要有两种 继承Thread类 实现Runnable接口 1public class Thread implements Runnable 从源码中可以看出，实际上Thread也是实现了Runnable接口，如果为了支持多继承可以使用实现Runnable接口这种方式，两者没有本质上的区别 1、继承Thread类1234567891011121314public class WKThread extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(\"I am Thread\"); &#125;&#125;public class Main &#123; public static void main(String argr[])&#123; WKThread wkThread=new WKThread(); wkThread.start(); &#125;&#125; Thread类中的start()方法通知线程规划器通知线程已就绪，等待调用线程对象的run()方法,也就是等待系统分配资源调用。这样的是异步调用。如果线程对象不是异步，而是同步，那么会由main主线程来调用run()方法，也就是必须等待run()方法完成才可执行后面的代码 2、实现Runnable接口1234567891011121314public class WKRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"I am Runnable\"); &#125;&#125;public class Main &#123; public static void main(String argr[]) &#123; Runnable runnable = new WKRunnable(); Thread thread = new Thread(runnable); thread.start(); &#125;&#125; 原理与上面相同 注意需要注意的是，使用线程的话，推荐使用线程池的方式去创建，而不是直接new 二、使用1、Thread类的一些APIcurrentThreadcurrentThread方法可以返回当前代码段被哪个线程调用的Thread对象信息比如获取线程的name 1Thread.currentThread().getName(); isAliveisAlive用于判断当前线程是否处于活动状态 sleep可以让当前线程，即this.currentThread()返回的线程，暂停执行指定毫秒数 getId获取线程的唯一标识 yieldyield方法是放弃当前的CPU资源，将它让给其他的任务去占用CPU的时间，但是放弃的时间不确定，可能刚刚放弃又获得 2、停止线程一般来说会使用interrupt()方法去停止一个线程，但是并不会马上停止，只是在当前线程打一个标记 过期的方法，stop,suspend,resume,都不能使用 有两个方法可以判断线程是否处于中断状态 interrupted:判断当前线程是否处于中断状态，并且清除停止状态 isInterrupted:判断线程是否处于中断状态 抛出异常停止如果需要马上停止一个线程，可以使用抛出异常的方法123456789101112131415161718public class WKThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"I am Thread \" + i); if (this.isInterrupted()) &#123; try &#123; throw new InterruptedException(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; return停止当然也可以使用return，但是最好方案还是抛出异常，因为这样可以把线程停止的事件往上传播12345678910111213public class WKThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"I am Thread \" + i); if (this.isInterrupted()) &#123; return; &#125; &#125; &#125;&#125; 如果是在sleep状态下停止某一个线程，会进入catch语句，并且清除停止状态值 三、线程优先级操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是优先级高但是高优先级也不一定会比低优先级的先运行，存在一定的随机性 在Java中使用setPriority方法来设置线程的优先级，并且分为1~10级，而且有几个内置常量123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级是有继承性的,即如果A线程启动B线程，那么B线程将拥有跟A线程一样的优先级 四、守护线程守护线程Daemon的作用是为其他线程服务,经典的例子就是GC，如果非守护线程不存在，守护线程也将结束 五、线程间的通信1、等待和通知机制等待和通知机制有三个重要方法,调用之前都必须获取对象级别的锁 wait:使调用该方法的线程释放共享资源的锁，然后从运行状态进入到等待队列，等待唤醒 notify:随机唤醒等待队列中等待同一资源的一个线程,使该线程进入可运行状态 notifyAll:唤醒等待队列中等待同一资源的所有线程,进入可运行状态 要注意的是notify所在的同步块要运行完之后才会释放锁，然后才到wait所在的代码获取锁 2、管道输入/输出流管道输入/输出流主要用于线程之间的数据传输，而传输的媒介为内存,包括四种类 PipedOutputStream和PipedInputStream,面向字节 PipedReader和PipedWriter,面向字符 3、join方法如果一个线程A执行了线程B的join方法，那么含义是，当前线程A等待线程B终止后才从B.join返回 123456789101112131415161718192021222324public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0);//使用wait方法 &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay);//使用wait方法 now = System.currentTimeMillis() - base; &#125; &#125;&#125; join的内部其实也是使用了wait方法 123456789101112131415161718192021222324252627282930313233343536void JavaThread::run() &#123; ... thread_main_inner();&#125;void JavaThread::thread_main_inner() &#123; ... this-&gt;exit(false); delete this;&#125;void JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123; ... // Notify waiters on thread object. This has to be done after exit() is called // on the thread (if the thread is the last thread in a daemon ThreadGroup the // group should have the destroyed bit set before waiters are notified). ensure_join(this); ...&#125;static void ensure_join(JavaThread* thread) &#123; // We do not need to grap the Threads_lock, since we are operating on ourself. Handle threadObj(thread, thread-&gt;threadObj()); assert(threadObj.not_null(), \"java thread object must exist\"); ObjectLocker lock(threadObj, thread); // Ignore pending exception (ThreadDeath), since we are exiting anyway thread-&gt;clear_pending_exception(); // Thread is exiting. So set thread_status field in java.lang.Thread class to TERMINATED. java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED); // Clear the native thread instance - this makes isAlive return false and allows the join() // to complete once we've done the notify_all below java_lang_Thread::set_thread(threadObj(), NULL); lock.notify_all(thread); // Ignore pending exception (ThreadDeath), since we are exiting anyway thread-&gt;clear_pending_exception();&#125; join之后的唤醒在native层 4、ThreadLocalThreadLocal是当前线程自己绑定的值,数据结构是key-value的形式.ThreadLocal通常被private static修饰，线程结束后，ThreadLocal对应的实例副本也被回收 数据结构ThreadLocal内部事实上是维护了一个叫ThreadLocalMap的类而ThreadLocalMap就是一个Entry的数组，key值永远是ThreadLocal对象 set方法从set的代码中可以看出，当发生hash冲突时，ThreadLocalMap会进行重新hash 1234567891011121314151617181920212223242526 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i);//清除空key的entry，防止内存泄露 return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();//hash冲突，重新哈希&#125; 还有一个重点内容是Entry是弱引用的形式的如果ThreadLocal对应的线程一直运行那么，Entry对象中的value就有可能一直得不到回收，出现内存泄露，所以set方法中会清除空key的entry 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocal使用完之后，调用remove是个好习惯 InheritableThreadLocalInheritableThreadLocal可以让子线程获得父线程的值 使用场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程(一) — 基本概念","slug":"Java/Thread/Java多线程(一) — 基本概念","date":"2019-11-06T11:11:03.364Z","updated":"2019-11-13T01:50:43.290Z","comments":true,"path":"2019/11/06/Java/Thread/Java多线程(一) — 基本概念/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Thread/Java多线程(一) — 基本概念/","excerpt":"","text":"一、线程的基本概念并行和并发 并发是相对一个CPU,分时间片执行任务,同一时间间隔事件 并行是相对多个CPU,分别同时执行任务,同一时间点事件 并行和串行 串行是执行完一个任务再去执行下一个 并行是多个任务同时执行 同步和异步 同步是顺序进行，需要进行等待，协调 异步在等待某一个任务执行过程中继续执行自己的任务,线程是实现异步的一个方式 多线程多线程是程序设计的逻辑概念，指的是在进程中并发运行的一段代码，实现多个线程间切换执行 二、Java线程的状态在Java类库,Thread类中有一个State的枚举类列出了线程的6个状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 可运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统地称为”运行”。调用了start()方法。线程位于可运行线程池中,等待被线程调度选中，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 三、并发编程需要注意的地方并行并发不一定就比串行快，因为线程的创建和上下文切换也需要开销 lmbench3可以测量上下文切换的时长 vmstat可以测量上下文切换的次数 减少上下文切换的方法 无锁并发编程:使用一些方法来避免用锁 CAS:使用Atomic包的CAS算法更新数据，不用加锁 避免使用不必要的线程 协程:单线程实现多任务调度 1、 减少waiting线 使用jstack工具dump出对应进程的线程信息 查看哪些线程waiting比较多 根据线程对应的程序调整 2、避免死锁的方法 避免一个线程获取多个锁 避免一个线程在锁内获取多个资源 尝试使用定时锁 数据库锁，加锁解锁都必须在同一个数据库连接 3、各种操作的一些资源利用下载文件 带宽 硬盘读写速度 数据库操作 数据库连接数 4、线程安全当多个线程访问一个类时，如果不考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍是正确的，那么称这个类是线程安全的 并发编程中两个关键问题：线程之间如何通信和线程之间如何同步通信机制有两种：共享内存和消息传递 而Java的方法用的是共享内存模型，Java线程间的通信总是隐式进行。 https://zhuanlan.zhihu.com/p/34678757 https://blog.csdn.net/SEU_Calvin/article/details/52411531 原子性操作原理","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java集合(五) — LinkedList","slug":"Java/Collections/Java集合(五) — LinkedList","date":"2019-11-06T11:10:42.759Z","updated":"2019-11-08T03:39:25.022Z","comments":true,"path":"2019/11/06/Java/Collections/Java集合(五) — LinkedList/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Collections/Java集合(五) — LinkedList/","excerpt":"","text":"一、概述LinkedList内部是由双向链表实现的,特点是 线程不安全 允许元素为null当然也有链表的特点，增删只需要移动指针，时间效率较高。不需扩容，空间效率比ArrayList高。访问元素时，需要定位节点，时间效率低。 二、构造方法123456789101112131415161718192021222324252627//集合元素个数transient int size = 0;//头节点transient Node&lt;E&gt; first;//尾节点transient Node&lt;E&gt; last;public LinkedList() &#123;&#125;//把传入参数的所有元素添加到集合public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;//节点信息(可以看出是双向链表)private static class Node&lt;E&gt; &#123; E item;//元素值 Node&lt;E&gt; next;//后置节点 Node&lt;E&gt; prev;//前置节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 三、操作方法1、增123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 public boolean add(E e) &#123; //在尾部添加一个节点 linkLast(e); return true; &#125; void linkLast(E e) &#123; //记录原尾结点 final Node&lt;E&gt; l = last; //新建一个节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //更新尾部节点 last = newNode; //如果本身为空链表就把新节点设为头节点 if (l == null) first = newNode; //如果不是就链接新节点 else l.next = newNode; //大小增加 size++; //修改次数添加 modCount++; &#125; //指定下标添加元素public void add(int index, E element) &#123; //检查是否越界 checkPositionIndex(index); if (index == size) //尾部插入 linkLast(element); else //从中间插入 linkBefore(element, node(index)); &#125; void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; //保存后置节点的前置节点 final Node&lt;E&gt; pred = succ.prev; //构建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //把新节点作为原succ节点的前置节点 succ.prev = newNode; //表示succ是原头结点， if (pred == null) //更新头结点 first = newNode; else //否则修改前置节点的后置节点为新节点 pred.next = newNode; size++; modCount++; &#125; 2、删12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public E remove(int index) &#123; //检测是否越界 checkElementIndex(index); //把节点从链表删除 return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; //保存节点的值，前置后置节点 final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; //前置为空，证明是头节点，直接把后置节点设为头节点 if (prev == null) &#123; first = next; //否则就把前置节点的后置节点，设置为后置节点，并把节点的前置节点置空 &#125; else &#123; prev.next = next; x.prev = null; &#125; //后置为空，证明是尾节点，直接把尾节点设置为前置节点 if (next == null) &#123; last = prev; //否则把前置节点设置为，后置节点的前置节点,并把节点的后置节点置空 &#125; else &#123; next.prev = prev; x.next = null; &#125; //把当前节点值置空 x.item = null; size--; modCount++; return element;&#125;//遍历寻找传入的节点值对应的节点public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 3、改1234567public E set(int index, E element) &#123; checkElementIndex(index); //检查越界[0,size) Node&lt;E&gt; x = node(index);//取出对应的Node E oldVal = x.item;//保存旧值 供返回 x.item = element;//用新值覆盖旧值 return oldVal;//返回旧值&#125; 4、查1234567891011121314151617181920212223242526272829303132333435363738394041public E get(int index) &#123; checkElementIndex(index);//判断是否越界 [0,size) return node(index).item; //调用node()方法 取出 Node节点，&#125;//遍历寻找对应节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;//遍历寻找对应值的节点public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123;//如果目标对象是null //遍历链表 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123;////遍历链表 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 三、DequeLinkedList实现了Deque接口，并且重写了相关方法所以也可以作为栈、队列和双端队列来使用","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java集合(四) — ArrayList","slug":"Java/Collections/Java集合(四) — ArrayList","date":"2019-11-06T11:09:19.586Z","updated":"2019-11-08T03:24:37.290Z","comments":true,"path":"2019/11/06/Java/Collections/Java集合(四) — ArrayList/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Collections/Java集合(四) — ArrayList/","excerpt":"","text":"一、概述ArrayList是一个动态数组,特点是 线程不安全 允许元素为null实现了RandomAccess接口拥有随机快速访问的能力 当然因为底层是数组，所以也拥有数组的优缺点，连续的内存，读写时间效率高，空间效率低因为是数组，所以扩容操作也是性能消耗大的地方。主要关心的也是扩容操作 二、构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546//默认容量private static final int DEFAULT_CAPACITY = 10;//空数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认构造函数的空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//存放集合元素的数组transient Object[] elementData; // non-private to simplify nested class access//当前元素的数量private int size;//传入默认容量的构造方法public ArrayList(int initialCapacity) &#123; //如果传入容量大于0，直接创建数组 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; //如果传入容量等于0，把空数组赋值 &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; //如果小于0，直接抛出异常 &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;//默认构造方法创建空数组public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//根据集合元素创建数组public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); //如果数组元素不为0,开始复制 if ((size = elementData.length) != 0) &#123; //如果c.toArray出错，没有返回Object[] if (elementData.getClass() != Object[].class) //利用Arrays.copyOf 来复制集合c中的元素到elementData数组中 elementData = Arrays.copyOf(elementData, size, Object[].class); //如果数组元素为0 &#125; else &#123; //复制空数组 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 构造方法走完之后，数组的size和elementData就有了构造方法中的一些工具方法很值得注意一下123Collection.toArray()Arrays.copyOf(elementData, size, Object[].class)System.arraycopy 三、操作API1、增123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public boolean add(E e) &#123; //添加之前，判断是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //在数组后面添加一个元素，并且size++ elementData[size++] = e; return true;&#125;public void add(int index, E element) &#123; //越界判断 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; private void ensureCapacityInternal(int minCapacity) &#123; //判断数组是否为默认空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //拿到扩容容量 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //如果确定要扩容，会修改modCount modCount++; // 判断要扩大的容量是否比当前大 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //默认扩大原来的一半 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果不够，就扩容为目标容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加过程 判断是否越界，判断是否需要扩容 如果需要扩容，修改modCount 默认扩大原来的一半,如果不够，就扩容为目标容量 复制数组 2、删1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public E remove(int index) &#123; //越界检查 rangeCheck(index); //结构改变了，修改次数增加 modCount++; //获取元素 E oldValue = elementData(index); int numMoved = size - index - 1; //将后面的元素往前移 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //把最后一个元素置空 elementData[--size] = null; return oldValue;&#125;//删除该元素在数组中第一次出现的indexpublic boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //根据index删除 fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 Objects.requireNonNull(c); return batchRemove(c, false);&#125;private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0;//w 代表批量删除后 数组还剩多少元素 boolean modified = false; try &#123; //遍历判断当前数组有没有要删除的集合 for (; r &lt; size; r++) //没有就保存 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; //出现异常的情况 if (r != size) &#123; //把出现异常后数组全部复制到数组 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; //把后面的元素置空 if (w != size) &#123; for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; //返回是否有修改 return modified;&#125; 删除操作会修改modCount,也可以涉及到数组的复制，所以相对低效 3、改1234567891011121314151617public E set(int index, E element) &#123; rangeCheck(index);//越界检查 E oldValue = elementData(index); //取出元素 elementData[index] = element;//覆盖元素 return oldValue;//返回元素&#125;``` ## 4、查 ```javapublic E get(int index) &#123; rangeCheck(index);//越界检查 return elementData(index); //下标取数据&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 5、clear12345678public void clear() &#123; modCount++;//修改modCount // clear to let GC do its work for (int i = 0; i &lt; size; i++) //将所有元素置null elementData[i] = null; size = 0; //修改size &#125; 6、contain1234567891011121314151617//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 7、判空123public boolean isEmpty() &#123; return size == 0;&#125; 8、迭代器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 游标 int lastRet = -1; // 上一个返回的元素; -1 if no such int expectedModCount = modCount;//用于判断是否被修改过 public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; //判断操作时是否被修改 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1;//游标+1 return (E) elementData[lastRet = i];//返回元素并设置上一次返回 &#125; //删除上次next的元素 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 另外还有writeObject和readObject，这两个序列化和反序列化的方法 三、Stack和Vector这两个已经是比较老的类了，一般都不使用 1、VectorArrayList和Vector操作逻辑上基本是一样的，内部也是用数组实现，不同的是，Vector的API都用synchronized去修饰，所以它是线程安全的，而且扩容的时候是12int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); 2、StackStack是继承于Vector实现一个栈","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java集合(三) — TreeMap","slug":"Java/Collections/Java集合(三) — TreeMap","date":"2019-11-06T11:09:12.582Z","updated":"2019-11-07T03:56:12.412Z","comments":true,"path":"2019/11/06/Java/Collections/Java集合(三) — TreeMap/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Collections/Java集合(三) — TreeMap/","excerpt":"","text":"","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java集合(二) — LinkedHashMap","slug":"Java/Collections/Java集合(二) — LinkedHashMap","date":"2019-11-06T11:02:29.862Z","updated":"2019-11-07T03:56:12.407Z","comments":true,"path":"2019/11/06/Java/Collections/Java集合(二) — LinkedHashMap/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Collections/Java集合(二) — LinkedHashMap/","excerpt":"","text":"一、概要LinkHashMap继承自HashMap 特点 线程不安全(线程安全可使用ConcurrentHashMap) 允许单个null的key和多个null的值 新增遍历有序 存储结构同样是数组+链表+红黑树，为了实现有序,单链表改成了双向链表,Entry继承了HashMap.Node,并且新增了两个参数,记录节点前后的节点信息 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 而且还新增了head,tail这两个成员变量记录了链表的头部和尾部accessOrder就是控制输出顺序。默认false123456//链表头部transient LinkedHashMap.Entry&lt;K,V&gt; head;//链表尾部transient LinkedHashMap.Entry&lt;K,V&gt; tail;//遍历时的顺序，true 访问顺序 false 插入顺序final boolean accessOrder; 总的来说，相对HashMap，多了遍历有序 二、 put这里没有对put方法进行重写，重写的是构建新节点的的方法newNode(),并通过linkNodeLast将新节点连接到内部双向链表的尾部 1234567891011121314151617Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;// 把节点添加到链表尾部private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; 以及HashMap专门留下来的回调方法 afterNodeAccess afterNodeInsertion afterNodeRemoval 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//被访问后回调，会将被访问的节点移到链表尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; //回调函数，新节点插入之后回调,根据evict和设定是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。void afterNodeInsertion(boolean evict) &#123; LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125;//回调函数，将节点从双向链表中删除void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java集合(一) — HashMap","slug":"Java/Collections/Java集合(一) — HashMap","date":"2019-11-06T03:49:13.907Z","updated":"2019-11-08T12:35:55.291Z","comments":true,"path":"2019/11/06/Java/Collections/Java集合(一) — HashMap/","link":"","permalink":"http://yoursite.com/2019/11/06/Java/Collections/Java集合(一) — HashMap/","excerpt":"","text":"一、 概述HashMap是一个关联数组、哈希表，其中数组被称为哈希桶，每个桶里放的是单链表或红黑树，每个节点就是哈希表中的元素。 特点是 线程不安全(线程安全可使用ConcurrentHashMap) 遍历无序 允许单个null的key和多个null的值 JDK1.8后，新增了红黑树，当单个链表的元素达到8，就会转换成红黑树，提高查询和插入的效率，避免链表过长的问题 需要关注的问题 hash表，涉及到碰撞解决 数组，涉及到扩容机制 Hash知识补充Hash就是把任意长度的消息(预映射:pre-image)通过哈希算法压缩成固定长度的消息输出,输出的值就是Hash值。不同的输入可能有同样的输出,所以用Hash值得不到唯一值,同样的输出称为碰撞需要进行碰撞处理:一般有:拉链法(open hashing)、开放定址法(closed hashing)、再哈希法、建立公共溢出区 二、碰撞解决从源码可知，HashMap中非常重要的一个字段， Node[] table，即Hash桶数组，Node的数组。 12345678910111213 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用于定位索引 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个Node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125; public final K getKey() &#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了Map.Entry接口，本质是就是一个键值对。每一个节点存储的就是一个Node HashMap使用的是Hash表存储，并且使用拉链法解决碰撞。简单来说，就是数组加链表的结合.当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表。如果发生了碰撞，就会把数据插到对应链表的尾部(JDK1.7是插到头部，插到尾部避免了逆序，环形链表,后文会讲到) 三、扩容机制 理解扩容机制之前需要看一下几个重要的参数 12345678910111213//容量默认为16,且必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//负载默认因子为0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//扩容阈值int threshold; //负载因子final float loadFactor; //结构变化次数int modCount; //实际存储的键值对int size; threshold是HashMap所能容纳的最大数据量,计算公式是threshold = length * loadFactor当存储个数size大于threshold,容量扩大为原来的两倍 modCount用来记录HashMap内部结构发生变化的次数,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value被覆盖不属于结构变化 loadFactor 负载因子默认值是0.75,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重 DEFAULT_INITIAL_CAPACITY 初始容量为16,且为2的幂,采用这种非常规设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 下面来分析一下resize的源码，鉴于红黑树比较复杂，这里先看JDK1.71234567891011121314151617181920 //传入新的容量 void resize(int newCapacity) &#123; //引用扩容前的Entry数组 Entry[] oldTable = table; int oldCapacity = oldTable.length; //扩容前的数组大小如果已经达到最大(2^30)了 if (oldCapacity == MAXIMUM_CAPACITY) &#123; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 threshold = Integer.MAX_VALUE; return; &#125; //初始化一个新的Entry数组 Entry[] newTable = new Entry[newCapacity]; //！！将数据转移到新的Entry数组里 transfer(newTable); //HashMap的table属性引用新的Entry数组 table = newTable; //修改阈值 threshold = (int)(newCapacity * loadFactor);&#125; 本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程 12345678910111213141516171819202122232425void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; //遍历旧的Entry数组 for (int j = 0; j &lt; src.length; j++) &#123; //取得旧Entry数组的每个元素 Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; //释放旧Entry数组的对象引用，防止对象游离 src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); //标记 e.next = newTable[i]; //将元素放在数组上 newTable[i] = e; //访问下一个Entry链上的元素 e = next; &#125; while (e != null); &#125; &#125; &#125; e的引用复制给了newTable[i],也就是说这里使用了单链表的头插法，而且需要重新计算每个元素的hash值，这两点与JDK1.8有区别, 1、优化下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为原来的2倍1newThr = oldThr &lt;&lt; 1; // double threshold 所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，下图就可以看的出来a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化 我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成&quot;原索引+oldCap&quot; 1newTab[e.hash &amp; (newCap - 1)] = e 下图为16扩充为32的resize示意图 这样，既省去了重新计算hash值的时间，同时，由于新增的1bit可以认为是随机的，因此resize的过程，均匀地把之前的冲突的节点分散到新的bucket了。 下面是JDK1.8扩容的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果原容量的两倍小于最大容量，且元容量大于默认容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //新容量为原容量的两倍 newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 四、 put 如果table为null则创建 根据hash计算出元素index(length - 1 &amp; hash效果等同于取模,效率提高),并处理null值 如果key存在,直接覆盖Value 判断是否为红黑树 判断是否为链表 判断是否需要扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; //对key进行hash操作 return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1、如果table为null则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3、如果key存在,直接覆盖Value if (p。hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4、判断是否为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5、判断是否为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表大于阈值则转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在直接覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.alue; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6、判断是否需要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 五、JDK1.7的死循环问题扩容时，当线程A运行到Entry&lt;K,V&gt; next = e.next被挂起，线程B完成了扩容操作后，会出现主要原因是新链表头插操作,导致逆序,JDK1.8之后改用尾插修复，但是仍然是线程不安全 六、HashMap与HashTable的区别 HashTable不允许null作为key或者key，而HashMap允许 HashTable用synchronized实现了线程安全，HashMap不是线程安全的 HashTable的enumerator迭代器不是fail-fast的,HashMap的迭代器(Iterator)是fail-fast迭代器 HashMap 内部使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值。HashTable 是直接使用 key 的 hashCode() 返回值作为 hash 值。 HashMap默认容量为 2^4 且容量一定是 2^n ; HashTable 默认容量是11,不一定是 2^n HashTable 取哈希桶下标是直接用模运算,扩容时新容量是原来的2倍+1。HashMap 在扩容的时候是原来的两倍，且哈希桶的下标使用 &amp;运算代替了取模 Java 8系列之重新认识HashMap https://tech.meituan.com/2016/06/24/java-hashmap.htmlHashMap在JDK7和JDK8中的区别 https://zhuanlan.zhihu.com/p/59250175Map 综述（一）：彻头彻尾理解 HashMap https://blog.csdn.net/justloveyou_/article/details/62893086面试必备：HashMap源码解析（JDK8） https://blog.csdn.net/zxt0601/article/details/77413921解决哈希冲突的常用方法分析 https://www.jianshu.com/p/4d3cb99d7580","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java基础(八) — 注解","slug":"Java/Basic/Java基础(八) — 注解","date":"2019-11-04T04:33:30.879Z","updated":"2019-11-10T01:28:33.125Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(八) — 注解/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(八) — 注解/","excerpt":"","text":"一、概述注解可以用于描述类、接口、方法、方法参数、字段、局部变量等,准确来说是一种特殊的注释，但是配合上解析它的代码，想象空间就很大了，有以下 格式检查 减少配置 减少重复工作 二、元注解先来引入元注解的概念，元注解就是标注其他注解的注解。用于对其他注解进行限制 例子:Java内置的方法重写的注解Override1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 下面是Java提供的元注解 1、@Target这个注解用来约束注解可以描述的地方(类、方法等),其中ElementType就是它的取值范围 TYPE: 类, 接口(包括注解), 或者枚举 FIELD：成员变量 (包括枚举类的常量) METHOD：方法 PARAMETER：方法参数 CONSTRUCTOR：构造器 LOCAL_VARIABLE：局部变量 ANNOTATION_TYPE：注解 PACKAGE：包 TYPE_PARAMETER：类型参数,1.8新增， TYPE_USE：类型使用,1.8新增，可以用于声明语句、泛型和强制转换语句中的类型 默认未指定@Target时，表示任何地方都可以用,如果要使用多个，可以用逗号隔开 1@Target(value=&#123;TYPE_USE, TYPE_PARAMETER&#125;) 特别地，1.8新增的两个类型1234567891011121314151617181920212223//TYPE_PARAMETER 标注在类型参数上class D&lt;@Parameter T&gt; &#123; &#125;//TYPE_USE则可以用于标注任意类型(不包括class)//用于父类或者接口class Image implements @Rectangular Shape &#123; &#125;//用于构造函数new @Path String(\"/usr/bin\")//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。String path=(@Path String)input;if(input instanceof @Path String)//用于指定异常public Person read() throws @Localized IOException.//用于通配符绑定List&lt;@ReadOnly ? extends Person&gt;List&lt;? extends @ReadOnly Person&gt;@NotNull String.class //非法，不能标注classimport java.lang.@NotNull String //非法，不能标注import 2、@Retention@Retention用来约束注解的声明周期 SOURCE:源码级别，编译过后，注解会被丢弃 CLASS:类文件级别，注解在Class文件中可用，但是不会被JVM加载 RUNTIME:运行时级别，注解信息会在运行时保留，可以通过反射机制获取到注解上的信息 3、@Documented被@Documented修饰的元素会生成到javadoc中 生成命令1javadoc Documents.java 4、@Inherited@Inherited可以让注解被继承,真正的含义是可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解 三、注解元素及其数据类型像上面提到的@Override注解，内部没有定义其他元素，所以也叫标记注解在自定义注解中，一般会包含一些元素来表示某些值，方便注解处理器使用如：自定义一个注解 123456@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface IntegerVaule&#123; int value() default 0; String name() default \"\";&#125; 声明了一个int和String的元素 注解支持的元素类型还有 基本数据类型 String Class Enum Annotation 上述类型的数组 元素的值必须不为空,也不接受null值，一般都会去定义一些特殊值作为默认值，空字符串或负数 如果某是元素是唯一的，那么使用时就不用key=value的方式 如下12345@IntegerVaule(20)public int age;@IntegerVaule(value = 10000,name = \"MONEY\")public int money; IntegerVaule反编译后的代码 12345public interface IntegerVaule extends Annotation&#123; public abstract int value(); public abstract String name();&#125; 可以发现，事实上这是个语法糖，编译之后会转换成接口，并且继承于Annotation,如果内部有其他的元素，会被转换成抽象方法 四、1.8新增@Repeatable在jdk1.8中，新增了@Repeatable这个元注解,主要用途是表示在同一个位置可以使用重复的注解1234567@Target(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited //添加可继承元注解@Repeatable(FilterPaths.class)public @interface FilterPath &#123; String value();&#125; 具体表现如下123@FilterPath(\"/web/update\")@FilterPath(\"/web/add\")public class A &#123;&#125; 同样的，反射机制也新增了一些API专门处理这个元注解 getDeclaredAnnotationsByType:返回此元素上的所有注解，不包括父类的注解 getAnnotationsByType:如果当前类不存在指定注解，则在父类寻找返回，存在则直接返回子类，以@FilterPath为例，如果没有使用Inherited,也是不能获取父类的 但是之前的API，getDeclaredAnnotation()和 getAnnotation()是不对@Repeatable处理的,所以无法获取 五、注解与反射(RUNTIME)java内部的反射机制提供了AnnotatedElement这个接口及其一系列的API来获取注解上的信息，然后对信息进行处理，当然注解必须是RUNTIME级别的才能用到反射,下面是一些相关的API 返回值 方法名称 说明 &lt; A extends Annotation&gt; getAnnotation(Class annotationClass) 返回指定类型的注解 Annotation[] getAnnotations() 返回此元素上所有注解,包括从父类继承的 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 判断指定类型的注解存在 Annotation[] getDeclaredAnnotations() 返回此元素上的所有注解，不包括父类的注解 六、注解处理器(CLASS)1、概述Javac编译器的编译过程,大致可分为三个步骤： 解析与填充符号表过程； 插入式注解处理器的注解处理过程； 语义分析与字节码生成过程。 注解处理器的注解处理过程：插入式注解处理器可以在编译器时读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止。 注解处理器可以在第二个阶段处理注解，通过继承AbstractProcessor的方式来实现。 2、AbstractProcessor类继承于AbstractProcessor的类可以实现属于自己的注解处理器 1234567891011121314151617181920212223242526272829public class Processor extends AbstractProcessor &#123; private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; @Override public synchronized void init(ProcessingEnvironment env) &#123; super.init(processingEnv); elementUtils = env.getElementUtils(); filer = env.getFiler(); typeUtils = env.getTypeUtils(); messager = env.getMessager(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; &#125;&#125; init：整个处理器被初始化的时候被调用。 process 在每一次处理的时候被调用，如果处理器对语法树进行了修改，会多次调用 getSupportedAnnotationTypes 返回能处理的注解的全名,1.6有注解SupportedAnnotationTypes getSupportedSourceVersion 返回能支持的代码版本,1.6之后有注解SupportedSourceVersion 在init方法的入参有一个ProcessingEnvironment的对象，这里有提供几个工具类 Elements：一个用来处理Element的工具类 Types：一个用来处理TypeMirror的工具类 Filer：这个工具可以支持向当前工程输出新的Java代码 Messager：可以让Javac编译器输出错误提示 定义一个注解1234@Retention(value = RetentionPolicy.CLASS)@Target(&#123;ElementType.TYPE, ElementType.METHOD,ElementType.FIELD&#125;)public @interface Scaner &#123;&#125; 修饰的代码12345678910@Scanerpublic class TestScaner &#123; @Scaner String name; @Scaner public void setName(String name)&#123; this.name = name; &#125;&#125; 原理https://blog.csdn.net/lylwo317/article/details/52163304","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(七) — 反射","slug":"Java/Basic/Java基础(七) — 反射","date":"2019-11-04T03:48:49.848Z","updated":"2019-11-08T03:28:17.288Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(七) — 反射/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(七) — 反射/","excerpt":"","text":"一、概述反射允许运行中的Java程序获取自身的信息,并且可以操作类或者对象的内部属性 反射主要提供以下功能 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 一般来说，反射主要用于框架开发相对较多,理解底层机制有助于丰富编程思想 二、基本应用1、获取Class对象 使用Class类的forName静态方法 1public static Class&lt;?&gt; forName(String className) 直接获取某一个对象的Class 12Class&lt;?&gt; klass = int.class;Class&lt;?&gt; classInt = Integer.TYPE; 调用对象的getClass方法 12String str= \"string\";Class&lt;? extends String&gt; strClass = str.getClass(); 2、判断是否为某个类的实例有两种方法 使用关键字instance of Class对象的isInstance方法 1public native boolean isInstance(Object obj); 3、创建实例有两种方法 使用Class对象的newInstance方法 12Class&lt;?&gt; strClass = String.class;String s = strClass.newInstance(); 通过Class对象获取指定的构造器Constructor对象,再使用构造器的newInstance方法创建 1234Class&lt;?&gt; strClass = String.class;Constructor strConstructor = strClass.getConstructor(String.class);Object obj = constructor.newInstance(\"string\"); 4、获取方法通过Class的对象获取，主要有下面几个方法 getDeclaredMethods返回类或者接口声明的所有方法，包括所有修饰符的，不包括继承 1public Method[] getDeclaredMethods() throws SecurityException getDeclaredMethod返回类或者接口声明的一个方法，包括所有修饰符的，不包括继承 1public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) getMethods返回本身和父类所有public的方法 1public Method[] getMethods() throws SecurityException getMethod返回本身或父类的一个public方法，第一个参数为方法名，后面为参数对应的Class 1public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 5、获取构造器信息主要是通过Class对象的getConstructor方法获得Constructor对象，而且Constructor的newInstance方法可以通过传入的参数调用对应构造器进行创建实例 1public T newInstance(Object ... initargs) 6、获取类的成员变量信息与Method类似 getDeclaredFields:返回类或者接口声明的所有成员变量，包括所有修饰符的，不包括继承getDeclaredField:返回类或者接口声明的一个成员变量，包括所有修饰符的，不包括继承getFileds:返回本身和父类所有public的成员变量getFiled:返回本身或父类的一个public成员变量，第一个参数为方法名，后面为参数对应的Class 7、调用方法通过类获取到方法实例后，就可以使用invoke方法来调用1public Object invoke(Object obj, Object... args) 需要点细节深入···· 8、创建数组直接通过Array类的newInstance方法创建,通过Array的set去添加内容 1234public static Object newInstance(Class&lt;?&gt; componentType, int length) throws NegativeArraySizeException &#123; return newArray(componentType, length);&#125; 三、原理四、注意反射会消耗一定的系统资源，非必要的情况下慎用，并且反射调用方法会忽略权限检查，可能会破坏封装性导致安全问题","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(六) — 泛型","slug":"Java/Basic/Java基础(六) — 泛型","date":"2019-11-04T03:48:21.248Z","updated":"2019-11-06T03:27:47.913Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(六) — 泛型/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(六) — 泛型/","excerpt":"","text":"一、概述“泛型”简单的意思就是泛指的类型(参数化类型)。主要作用是限制只能往集合中添加一种类型的数据，让错误在编译期暴露，避免运行时异常的发生，提升代码的健壮性。 二、使用1、泛型类123456789101112public class GenericClass&lt;T&gt; &#123; T item; public void setData(T t) &#123; this.item = t; &#125; public T getData() &#123; return this.item; &#125;&#125; 泛型类定义时只需在类名后面加上类型参数，当然也可以添加多个参数，类似于&lt;T,S&gt;。这样就可以在类里面使用定义的类型参数。 2、泛型方法12345678910111213141516public class GenericClass&lt;T&gt; &#123; T item; public void setData(T t) &#123; this.item = t; &#125; public T getData() &#123; return this.item; &#125; public &lt;I&gt; void getInfo(I i) &#123; System.out.println(i); &#125;&#125; 泛型方法声明的方式就是在权限修饰符和返回值之间加上&lt;I&gt;或者任意其他的标识,而里面的I跟类T就算是用一样的标识，也不会是同一个类型，两者作用域不一样。 3、泛型接口1234567891011public interface GenericInterface&lt;T&gt; &#123; public T next();&#125;public class GenericClass implements GenericInterface&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125; 泛型接口在实现时，需要将实参传入，并且接口中使用了参数对应的地方类型也要与传入实参一致 三、类型擦除1、描述泛型在设计时，为了兼容旧版本，Java使用了类型擦除机制。即泛型的参数类型只存在于编译期，运行期获取不到任何已经声明的类型信息,但是会保证类和参数内部参数类型一致。如下 12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2));//true 泛型参数会被擦除到它的第一边界,如果没有边界。类型将被擦除到Object边界可以有多个，使用extends参数可以给参数类型添加一个边界 12345678910111213 public interface Color &#123; void c();&#125;public class Animal&lt;T extends Color&gt; &#123; T desc; public T getDesc() &#123; return desc; &#125; public void setDesc(T desc) &#123; this.descj = desc; &#125;&#125; extends关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到Color类型。 2、原理在编译过程中，类型变量信息还能获取到，所以set的时可以做类型检查，非法类型不能通过编译为了”还原”返回结果的类型，编译器在get之后添加了类型转换 3、缺陷与补救泛型不能显示地运用在运行时类型的操作中，类似于转型、instance of和new，当然也有相应的方法替换 类型判断使用时，把类型参数的Class对象记录 12345678910111213141516class GenericType&lt;T&gt;&#123; Class&lt;?&gt; classType; public GenericType(Class&lt;?&gt; type) &#123; classType=type; &#125; public boolean isInstance(Object object) &#123; return classType.isInstance(object); &#125;&#125;GenericType&lt;A&gt; genericType=new GenericType&lt;&gt;(A.class);System.out.println(\"------------\");System.out.println(genericType.isInstance(new A()));System.out.println(genericType.isInstance(new B())); 创建类型实例使用工厂模式和泛型方法来创建实例对象。代码变动的话，添加新的工厂即可 12345678910111213141516171819202122interface Factory&lt;T&gt;&#123; T create();&#125;class Creater&lt;T&gt;&#123; T instance; public &lt;F extends Factory&lt;T&gt;&gt; T newInstance(F f) &#123; instance=f.create(); return instance; &#125;&#125;class IntegerFactory implements Factory&lt;Integer&gt;&#123; @Override public Integer create() &#123; Integer integer=new Integer(9); return integer; &#125;&#125;Creater&lt;Integer&gt; creater=new Creater&lt;&gt;();System.out.println(creater.newInstance(new IntegerFactory())); 四、泛型通配符1、上界通配符&lt;? extends C&gt;这种形式的通配符，可以实现泛型的向上转型,以ArrayList为例，可以包含的元素就是C的一种子类型(包含C),称为子类型边界 其中能使用的方法有contains、indexOf等形参为Object的方法，还有get是可以，但是只能当做是Object处理但是add(T t)就不行,因为不清楚集合里面的元素是什么类型，所以无法加入任何对象 2、下界通配符&lt;? super C&gt;这种形式的通配符,以ArrayList为例，可以包含的元素就是C(包含C)的超类型,即从当前类的父类直至Object类,称为超类型边界 而能使用的方法只是add,能插入的元素要么是A，要么是A的父类，如果B和C继承于A,且A有一个父类D,那么D也是A和B的父类 不能get，因为不能确定操作的数据是属于哪种类型,除非拿出来当做Object处理 结合上下界通配符，可以这样写入元素,来自Collectoins#copy方法12345678910111213141516171819public static &lt;T&gt; void copy(List&lt;? super T&gt; destination, List&lt;? extends T&gt; source) &#123; if (destination.size() &lt; source.size()) &#123; throw new IndexOutOfBoundsException(\"destination.size() &lt; source.size(): \" + destination.size() + \" &lt; \" + source.size()); &#125; Iterator&lt;? extends T&gt; srcIt = source.iterator(); ListIterator&lt;? super T&gt; destIt = destination.listIterator(); while (srcIt.hasNext()) &#123; try &#123; destIt.next(); &#125; catch (NoSuchElementException e) &#123; // TODO: AssertionError? throw new IndexOutOfBoundsException(\"Source size \" + source.size() + \" does not fit into destination\"); &#125; destIt.set(srcIt.next()); &#125;&#125; PECS原则上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(五) — 异常","slug":"Java/Basic/Java基础(五) — 异常","date":"2019-11-04T03:46:59.700Z","updated":"2019-11-05T02:21:27.593Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(五) — 异常/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(五) — 异常/","excerpt":"","text":"一、异常分类1、继承关系分类 Throwable:所有异常的基类,指出了代码中可以用通过异常传播机制传输Java程序任何问题的共性 Error:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止 Exception:程序本身可以处理的错误，Exception还有一个重要的子类RunTimeException,RunTimeException及其子类用来表示JVM常用操作引发的错误(NullPointerException、ArithmeticException) 2、可查和不可查包含Exception和Error在内，Java异常可分为可查异常和不可查异常 可查异常:在程序正常运行中允许发生的异常，并且必须进行处理，否则Java编译器不会通过. 不可查异常:包含RunTimeException及其子类和Error 3、运行时和非运行时 运行时异常:都是RunTimeException及其子类,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException 非运行时异常(编译异常):RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException 二、异常处理机制1、异常处理机制 抛出异常:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中包括异常类型和异常信息 捕获异常:在抛出异常后，运行时系统就开始寻找合适的异常处理器(exception handler),寻找的地方就是依次留在调用方法栈中的方法的集合,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止 2、异常的处理方式 RunTimeException:由运行时系统抛出，可以忽略， Error:属于不允许发生情况，所以不捕捉 可查异常:必须捕捉、或者声明抛出 3、捕捉处理异常语句try-catch-finally 123456789try&#123;&#125; catch(Exception1 e)&#123;&#125; catch(Exception2 e)&#123;&#125; finally &#123;&#125; try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally catch:用于处理捕捉到的异常 finally:无论是否捕捉到异常,都会执行,如果try或者catch中有返回语句，那么finally会在返回之前执行 以下四种情况finally不会被执行 finally出现异常 前面代码使用System.exit()退出程序 程序所有线程死亡 关闭CPU 4、抛出异常 throws如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用throws抛出异常，给上一层处理 抛出规则 对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出 可查异常，要么try-catch捕获，要么使用throws声明抛出 抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(四) — 枚举","slug":"Java/Basic/Java基础(四) — 枚举","date":"2019-11-04T03:46:42.388Z","updated":"2019-11-06T03:49:35.535Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(四) — 枚举/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(四) — 枚举/","excerpt":"","text":"一、原理Enum实际上是一种特殊的类，编译后会转换成正常的类，如下简单定义一个枚举类 123public enum Color &#123; WHITE,BLACK&#125; 经过编译后就会转换成一下的样子 123456789101112131415161718192021222324252627282930313233343536//变成了final类并继承与Enumfinal class Color extends Enum&#123; //前面定义的2种枚举实例 public static final Color WHITE; public static final Color BLACK; private static final Color $VALUES[]; static &#123; //实例化枚举实例 WHITE = new Color(\"WHITE\", 0); BLACK = new Color(\"BLACK\", 1); $VALUES = (new Color[] &#123; WHITE, BLACK &#125;); &#125; //编译器为我们添加的静态的values()方法 public static Color[] values() &#123; return (Color[])$VALUES.clone(); &#125; //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法 public static Color valueOf(String s) &#123; return (Color)Enum.valueOf(Color, s); &#125; //私有构造函数 private Color(String s, int i) &#123; super(s, i); &#125; &#125; 二、常见方法 返回类型 方法名称 方法说明 int compareTo(E o) 比较此枚举与指定对象的顺序 boolean equals(Object other) 当指定对象等于此枚举常量时，返回 true。 Class&lt;?&gt; getDeclaringClass() 返回与此枚举常量的枚举类型相对应的 Class 对象 String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明 int ordinal() 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零） String toString() 返回枚举常量的名称，它包含在声明中 static&lt;T extends Enum&gt; T static valueOf(Class enumType, String name) 返回带指定名称的指定枚举类型的枚举常量 值得注意的是Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的 三、进阶用法1、结合抽象方法1234567891011121314151617181920public enum Color &#123; WHITE&#123; @Override public String getDesc() &#123; return \"我是白色\"; &#125; &#125;,BLACK &#123; @Override public String getDesc() &#123; return \"我是黑色\"; &#125; &#125;; public abstract String getDesc();&#125;public class Main &#123; public static void main(String argr[])&#123; String color = Color.WHITE.getDesc(); &#125;&#125; 2、结合接口1234567891011121314public interface Color &#123; enum DeepColor implements Color&#123; DEEP_BLUE,DEEP_GREEN &#125; enum LightColor implements Color&#123; LIGHT_BLUE,LIGHT_GREEN &#125;&#125;public class Main &#123; public static void main(String argr[])&#123; Color color = Color.DeepColor.DEEP_BLUE; &#125;&#125; 四、辅助类1、EnumMapkey为Enum类型的Map 2、EnumSet元素只能为Enum的Set","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(三) — 字符串","slug":"Java/Basic/Java基础(三) — 字符串","date":"2019-11-04T03:46:14.670Z","updated":"2019-11-06T11:45:08.305Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(三) — 字符串/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(三) — 字符串/","excerpt":"","text":"一、String的不可变性咱们先来看一下String类中一些关键的代码 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /` The value is used for character storage. */ private final char value[]; /` Cache the hash code for the string */ private int hash; // Default to 0 从上面代码中,首先知道的是String实际上内部维护的是char数组。这个数组和String一样，都用final修饰，证明String是不可变的和不可被继承的。也就是说,一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变,不能指向其他对象，指向的对象的状态也不能被改变。 那么这样设计的好处有什么呢?原因有以下 只有当String是不可变时，String常量池才有可能实现,并且为heap节省了空间 网络安全,否则黑客可以改变String指向的对象的值而造成安全漏洞问题 线程安全,可以被多个线程共享 性能,因为String不可变，所以String创建时的hashcode也具有唯一性，作为Map的键时比其他键对象快 二、常量池 JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即String Constant Pool(字符串常量池) 常量池底层方法是 String#intern() 使用StringTable数据结构保存字符串引用。StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， String#intern() 的性能由O(1)退化到O(n)。 深入解析String#internhttps://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html 在JDK6的版本中，String Pool使用固定容量的HashMap实现并存储在永久代中的，后面变为可配置，因为永久带内存有限，所以在JDK7开始就移动到heap(堆内存)中,这就意味着你可以通过调整堆大小来调整应用程序,通过JVM参数-XX:StringTableSize可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好 创建字符串对象的方式有两种 通过字面常量赋值 通过new关键字新建字符串对象 这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么 1、字面常量赋值123String s1 = \"abc\";String s2 = \"ab\"+\"c\";System.out.println(s1 == s2); //true 常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”; 采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的s1和s2指向的都是同一个对象，用 == 比较就会返回true,我们也可以通过字节码来进一步确认 123450 ldc #2 &lt;abc&gt; 2 astore_13 ldc #2 &lt;abc&gt;5 astore_26 return 当调用ldc #2,如果 #2 的symbol还没解析，则会调用C++底层的 StringTable::intern 方法生成char数组，并将引用保存在 StringTable和常量池中，当下次调用 ldc #2,通过将常量池中 #2对应的字符串推送到栈顶获取到 &quot;abc&quot;，避免再次到StringTable中查找。astore_1 将 &quot;abc&quot; 保存到 局部变量 2、使用new关键字新建123String s3 = new String(\"abc\");String s4 = \"abc\";System.out.println(s3 == s4); //false 我们来分析一下发生了什么①因为”abc”是用字面常量定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②由于使用了new，所以JVM会在 heap(堆) 中创建一个内容相同的String对象，然后返回堆中String对象的引用 下面是new String(“abc”)字节码123456 0 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;abc&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 return 所以s3指向的是堆中的对象，s4指向的是常量池中的对象,虽然内容相同，但是==比较的是对象，所以为false 3、使用变量连接的情况12String s5 = \"ab\";String s6 = s5 + \"c\"; 重点在s6,因为s5是一个变量，即使我们知道这个值，但是JVM仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 heap(堆) 中创建了一个内容为”abc”的对象并返回给s6而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现. 下面是字节码 123456789101112 0 ldc #2 &lt;ab&gt; 2 astore_1 3 new #3 &lt;java/lang/StringBuilder&gt; 6 dup 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;10 aload_111 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;14 ldc #6 &lt;c&gt;16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;22 astore_223 return 从字节码中也可以看出来，字符串变量的连接动作，在编译期会被转化成StringBuilder的append操作 4、使用final关键字修饰String12final String s7 = \"ab\";String s8 = s7 + \"c\"; 在这种情况下,final修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc” 下面是字节码123450 ldc #2 &lt;ab&gt;2 astore_13 ldc #3 &lt;abc&gt;5 astore_26 return 三、StringBuilder和StringBuffer String是字符串 常量，而 StringBuilder和StringBuffer都是字符串 变量 StringBuilder是 线程不安全 的，而StringBuffer是 线程安全 的(append方法使用了synchronized修饰)，所以StringBuilder的效率比StringBuffer高 String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认16个字节数组的大小。扩容就原来的大小 x 2 + 2,可以考虑初始化StringBuilder的大小来提高代码的效率。 四、一些题目下面程序运行的结果是什么123456789101112String s1 = \"abc\";StringBuffer s2 = new StringBuffer(s1);System.out.println(s1.equals(s2)); //false String的equals有对参数进行instance of String判断StringBuffer s3 = new StringBuffer(\"abc\");System.out.println(s3.equals(\"abc\")); //StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是System.out.println(s3.toString().equals(\"abc\")); //true 比较的是值String s4 = \"abc\";System.out.println(\"abc\"==s4.subString(0)); //true,如果subString的index是0，直接返回对象System.out.println(\"abc\"==s4.subString(1)); //false,不为0就new一个sub之后的对象返回 除此之外,toLowerCase和toUpperCase都是new一个对象返回 下面语句一共创建了多少个对象1String str = new String(\"xyz\"); 这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是两个,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(二) — 基本数据类型.md","slug":"Java/Basic/Java基础(二) — 基本数据类型","date":"2019-11-04T03:45:52.262Z","updated":"2019-11-06T03:49:35.525Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(二) — 基本数据类型/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(二) — 基本数据类型/","excerpt":"","text":"一、基本信息以下是八大基本数据类型大小、取值、默认值、对应包装类信息 数据类型 大小 封装类 默认值 可表示数据范围 byte 8 java.lang.Byte 0 -128~127(2^7) short 16 java.lang.Short 0 -32768~32767(2^15) int 32 java.lang.Integer 0 -2147483648 ~ 2147483647(2^31) long 64 java.lang.Long 0L -9223372036854775808 ~ 9223372036854775807 (2^63) float 32 java.lang.Float 0F 1.4E-45~3.4028235E38 double 64 java.lang.Double 0D 4.9E-324~1.7976931348623157E308 char 16 java.lang.Character 空 0~65535 boolean 8 java.lang.Boolean false true或false 包装类有对应最小值、最大值和大小的常量,如:Integer.MIN_VALUEInteger.MAX_VALUEInteger.SIZE 进一步可以分为以下四类 整型：byte(字节型)、short(短整型)、int(整型)、long(长整型) 浮点型：float(单精度浮点型)、double(双精度浮点型) 逻辑型：boolean(布尔型) 字符型：char(字符型) 二、数据类型转换根据取值范围的大小将数据类型排序,数据类型的转换也跟这个排序有关 1byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 数据类型之间的转换分为两种自动转换和 强制转换 1、自动转换在表达式中,当较”小”的数据与较”大”的数据一起进行运算时，系统会自动将”小”的数据转换成”大”的数据再进行运算在调用方式时,如果实参比形参&quot;小&quot;,也会将”小”的数据转换成”大”的数据 在表达式中，数据类型会出现自动提升，规则如下 所有的byte,short,char的值将被提升为int 如果有一个操作数是long，计算结果是long 如果有一个操作数是float，计算结果是float 如果有一个操作数是double，计算结果是double 2、强制转换将”大”数据转换成”小”数据时，就需要强制转换,并且会损失精度 三、包装类java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址 在JDK1.5以后，提供了自动装箱和自动拆箱功能这样的”语法糖” 1、自动装箱12345//这是自动装箱Integer i = 1; //转换成了Integer i = Integer.valueOf(1);//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException 从字节码看出也是一样的 1234567 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 iconst_1 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 9 astore_210 return 2、自动拆箱12345Integer i = 1;//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱int j = i;//后面一句转换成了int j = i.intValue(); 下面是字节码12345678910 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 aload_1 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt; 9 istore_210 aload_111 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;14 istore_315 return 由此也可以看出，自动拆装箱属于编译特性 3、缓存池在包装类中,为了避免频繁地创建和销毁对象，就有缓存池的出现，下面是各个包装类对应缓存池的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Byte valueOf(byte b) &#123; final int offset = 128; return ByteCache.cache[(int)b + offset];&#125;public static Short valueOf(short s) &#123; final int offset = 128; int sAsInt = s; if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache return ShortCache.cache[sAsInt + offset]; &#125; return new Short(s);&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125;public static Float valueOf(float f) &#123; return new Float(f);&#125;public static Double valueOf(double d) &#123; return new Double(d);&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 根据代码可以得知包装类的缓存池规则 Byte都是用缓存池里面的值 Short、Integer、Long会缓存 -128~127 Float和Double则直接返回，因为精度数不能每次都一样，所以缓存没有意义 Character则是缓存 &lt;=127 Boolean,只有两个值，直接就用常量的形式表示出来 四、注意 double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是false,所以在进行带精度计算时，需要用到BigDecimal switch中只能用byte、char、short、int，JDK1.7后可用String Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型 两边都是包装类的equals比较值，== 比较引用，其中一边是表达式的，== 就是比较值 char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(拓展资料) 五、题目下面语句做了什么12Integer i = 1; //valueOf()自动装箱成Integer类型i+=1;//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer 下面程序语句有什么问题12345678short s1 = 1;s1 = s1 + 1; //编译不通过、需要强转short s2 =1;s2 += 1; //正常编译,自动做了类型转换Integer i = null;int j = i; //NullPointException 下面程序的运行结果是什么1234567891011Integer i1 = 128;Integer i2 = 128;System.out.println(i1 == i2); //false 比较了对象Integer i1 = 127;Integer i2 = 127;System.out.println(i1 == i2); //true 缓存了-128~127Float f1 = 1f;Float f2 = 1f;System.out.println(f1 == f2) //false 始终new新对象","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(一) — 语法","slug":"Java/Basic/Java基础(一) — 基本概念和语法","date":"2019-11-04T03:45:24.520Z","updated":"2019-11-07T02:03:51.710Z","comments":true,"path":"2019/11/04/Java/Basic/Java基础(一) — 基本概念和语法/","link":"","permalink":"http://yoursite.com/2019/11/04/Java/Basic/Java基础(一) — 基本概念和语法/","excerpt":"","text":"一、基本概念1、面向对象继承性继承性是类的一种层次模型，提供了明确表述共性的方法,对象的新类在类中继承派生。类可以从他的基类继承方法和实例变量，并且类可以修改或者增加新的方法使之更适合特殊的需要 关键字:extends、class 多态性多态性是对象在不同时刻表现出来的多种状态,是一种编译时期状态和运行时期状态不一致的现象，多态包括参数多态和包含多态 关键字:interface 抽象性抽象是指对一类事物的高度提炼以得到的共性部分,抽象不需要了解全部细节，只是一种通用的描述约束,抽象可以是过程抽象或者数据抽象 关键字:abstract 封装性封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性 面向对象的特性:更多的实践使用就是设计模式 2、基本语法编写 Java 程序时，应注意以下几点： 大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 关于 Java 标识符，有以下几点需要注意： 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary 三、对象与类1、类类是描述一类对象的行为和状态,可以看作是创建对象的模板,如下是类的基本语法 12345678910111213public class Puppy&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 类可以包含一下类型的变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 2、构造方法每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 12345678public class Puppy&#123; public Puppy()&#123; &#125; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name &#125;&#125; 3、对象对象是类的一个实例，有状态和行为。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); &#125; public static void main(String[] args)&#123; // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); &#125;&#125; 运行输出小狗的名字是 : tommy 4、源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 包主要用来对类和接口进行分类Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类 四、基础修饰符1、权限修饰符 private:只能在定义它们的类中使用，在其他类中不能调用。 缺省(default):只能在定义它们的类中，以及同包的类中被调用 protected:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类 public:可以在任何一个类中被调用 2、final①类被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final ②变量被声明为final,必须在声明时初始化，且只能读取不能修改 ③方法被声明为final,不能被重载 一般会使用final和static组合来定义常量 3、staticstatic可以用来修饰的类成员变量、成员方法、代码块,将独立于对象 被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问) 静态方法不能访问类的非静态方法和成员变量 静态成员变量会被所有的对象共享 静态代码块会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作 4、this和superthis为当前类的引用对象，应用场景 构造方法:通过this的调用同类中指定参数类型的构造方法this(参数列表),只能用在构造方法体的第一行 变量:当成员变量与局部变量重名，使用this特指成员变量 方法:在方法中引用该方法所属类的当前对象，注意不能用于static方法(this对象级别，static类级别) super为父类存储空间标识 构造方法:在子类构造方法中调用父类构造方法super(参数列表),同样只能在构造方法体的第一行 5、instance ofinstance of运算符是用来在运行时指出对象是否是特定类的一个实例 五、内部类广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。，内部类实际上也是一种类，语法糖 1、成员内部类成员内部类，位于另一个类的内部，类似于成员变量这样的作用域下面的Draw就是成员内部类,相对来说Circle就是外部类12345678910111213class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(\"drawshape\"); &#125; &#125;&#125; 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：12外部类.this.成员变量外部类.this.成员方法 如果在外部类内要访问内部类，必须要new 成员内部类是依附外部类而存在的，也就是说，如果要在外部类以外创建成员内部类的对象12Outter outter = new Outter();Outter.Inner inner = outter.new Inner(); 并且成员内部类还可以使用任何权限修饰符修饰，并起到相应的作用 成员内部类可以无条件访问外部类的原因，通过反编译，可以看到内部类的构造方法持有外部类的引用1Outter$Inner(Outter); 2、局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内,类似于一个局部变量,不能有权限修饰符或者static123456789101112131415161718class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 3、匿名内部类大部分匿名内部类用于接口回调,类似于按钮监听 123456btnScan.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); 匿名内部类在编译的时候由系统起类似Outter$1.class这样的名 局部内部类和匿名内部类只能访问局部final变量的原因123456789public void test(final int b) &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); System.out.println(b); &#125;; &#125;.start(); &#125; 当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，Java采用了复制的手段来解决。如果run的过程中修改了变量a的值，就会出现数据不一致的问题，所以的局部变量和形参都必须用final进行限定，不允许对变量进行修改 4、静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个static关键字1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125; class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法 六、方法的重写和重载1、重写子类对父类允许访问的方法的方法体进行覆盖并重新实现 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 2、重载重载是在一个类里面，方法名字相同,而参数的类型和个数不同的方法 12345678public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; 六、其他1、变长参数在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用...表示 12345public class Varargs&#123; void method(String... args)&#123; &#125;&#125; 2、自增自减运算符这里主要需要注意一个陷阱12345int count = 0;for(int i = 0;i&lt;100;i++)&#123; count = count++;&#125; count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是 JVM把count值拷贝到临时变量区(0) count值加1,此时count为(1) 返回临时变量区的值(0) 此时count被重置为0 也就是不管count = count++多少次，count的值,都是一样。 Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全 synchronized代码块或者方法 使用Lock锁 使用JDK提供的线程安全类AtomicInteger(推荐)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"","slug":"Java/JVM/JVM回收","date":"2019-03-24T12:16:25.000Z","updated":"2019-10-30T02:07:36.803Z","comments":true,"path":"2019/03/24/Java/JVM/JVM回收/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/JVM回收/","excerpt":"","text":"判断对象是否存活主流的实现中使用的都是可达性分析(Reachability Analysis) 基本思想是,以一系列称为GC Roots的对象作为起始点,从这些节点往下开始搜索，搜索所走过的路称为引用链,当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用 在Java语言中,可作为GC Roots的对象包括 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 即使通过可达性分析算法中不可达的对象，并非”非死不可”。真正要宣告一个对象死亡，至少要经历两次标记过程 通过可达性分析被发现不可达后就会被标记，并且进行一次筛选筛选的条件是此对象是否有必要执行finalize()方法，判断条件如下 当对象没有覆盖finalize方法 已经被虚拟机执行过了 这两种情况都没有必要执行 如果对象被判断有必要执行，那么这个对象就会被放置到一个F-Queue中，并且由虚拟机创建一个低优先级的Finalizer执行。注意这里只会是触发，不会等待运行结束。 如果在finalize过程中与引用链中的对上建立了联系，那么这个对象就不会被回收。反之则会被第二次标记，进行回收 需要注意的是，任何对象的finalize方法只会被执行一次，面对下一次回收就不会被执行了 回收方法区(永久代)永久代的垃圾回收主要回收两部分 废弃常量 无用的类 废弃常量，以常量池中的字面量为例，比如字符串“abc”,如果当前系统中没有任何一个String对象是”abc”,那就会被清出常量池 要清出无用的类需要满足下面3个条件 该类所有的实例都已经被回收 加载该类的ClassLoader已经被回收 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问 垃圾回收算法标记-清除算法分为”标记”和”清除”两个阶段。首先标记处所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记的算法就是之前说的可达性算法。 这是最基础的收集算法,因为后续的算法都是基于这种思路并且对其不足进行优化，主要的不足有两个 效率标记和清除两个过程的效率都不高 空间标记清除之后会产生大量不连续的内存碎片。空间碎片太多会到导致后面需要分配大对象时，无法获得连续的内存而不得触发另一次垃圾回收 复制算法为了解决效率问题而出现，它将可用内存按容量划分为相等大小的两块，每次只使用其中一块，当着一块用完了，就把存活的对象复制到另一快，然后把使用过的内存空间一次清理 目前的商业虚拟机都采用的这种手机算法来回收新生代将内存分为一块较大的Eden空间和两块小的Survivor,每次使用Eden和其中一块Survivor当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一个Survivor，最后清理Eden和之前的Survivor，Eden和Survivor的比例是8:1因为无法保证回收时存活的对象少于10%，Survivor的空间不足时，需要依赖其他的内存进行分配担保那么这些对象将直接通过分配担保机制进入老年代。~to be continue 标记-整理算法复制收集算法在对象存活率较高时，需要较多的复制操作，效率会变低。另外，如果不想浪费50%的空间，就需要额外的空间做分配担保，应对对象100%存活率的极端标记还是使用可达性算法，整理是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存 分代收集算法一般是把Java堆分为新生代和老年代新生代，每次垃圾手机时都发现有大批对象死去，只有少量存活，那就复制复制算法老年代，因为存活率高，没有额外的空间分配担保，必须使用标记清理或标记整理算法","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/HotSpot的垃圾回收算法实现","date":"2019-03-24T12:16:25.000Z","updated":"2019-10-30T13:02:43.312Z","comments":true,"path":"2019/03/24/Java/JVM/HotSpot的垃圾回收算法实现/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/HotSpot的垃圾回收算法实现/","excerpt":"","text":"枚举根节点在可达性分析中，可作为GC Roots的节点主要在全局性的引用(常量或类静态属性)与执行上下文(栈帧中的局部变量表)中但是现在应用仅仅方法区就数百兆，要逐个检查完，那么必然消耗很多时间。 而且在这个工作还需要进行GC停顿，因为这项分析工作必须能保持一致性，就是不可以在分析过程中对象的关系还在变化 目前主流的Java虚拟机使用的都是准确式GC，也就是当执行系统停顿下来后，虚拟机有办法直接得知哪些方法存放着这些对象引用，hotspot中使用一组称为OopMap的数据结构来达到这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就直接知道这些信息了。 安全点需要关注的一个点事，如果为每一条指令都生成对应的OopMap，会需要大量的额外空间,但是hotspot很显然并没有这样做，只是在特定的位置记录了这些信息，而这些位置称为安全点。即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 安全点选定的标准是，是否具有让程序长时间运行的特征 另外一个需要考虑的问题，如何在GC发生时让所有线程，都跑到最近的安全点上再停顿下来，两种方案 抢先式中断GC发生时，把所有的线程中断，如果现有的线程中断不在安全点上，就恢复线程让它跑到安全点上(弃用) 主动式中断设置一个标志，各个线程在执行时主动去轮询这个标志，发现中断标志就自挂东南枝。实际情况会有线程处于block或sleep的状态,无法走到中断标志，这时候就需要安全区域 安全区域指的是，在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的，","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/JVM对象相关","date":"2019-03-24T12:16:25.000Z","updated":"2019-10-28T14:02:21.422Z","comments":true,"path":"2019/03/24/Java/JVM/JVM对象相关/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/JVM对象相关/","excerpt":"","text":"对象的创建检查当虚拟机遇到一条new指令时(克隆，反序列化)，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用,检查有没有被加载,解析和初始化过，如果没有，在执行相应的类加载的过程（疑问） 分配内存接下来虚拟机会为新生对象分配内存，分配的方式有两种 指针碰撞内存规整，用指针分开已用内存和空闲内存 空闲列表内存不规整，维护一个列表记录空闲的内存 防止并发 虚拟机会使用CAS配上失败重试的方式保持更新的原子性 还有另外一种方法，在每个线程的Java栈中分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，哪个线程需要分配内存，就在TLAB上分配，内存用完了,同步锁定是否使用TLAB，可以通过 -XX:+/-UserTLAB参数设定 分配完成之后，分配到的内存空间都会被初始化为零,并且为对象头赋值,从虚拟机的层面来说已经创建完成了 接下来执行&lt;init&gt;方法，按照程序员的意愿进行初始化 对象的内存布局对象在内存中存储的布局可以分为3块区域:对象头、实例数据、对齐填充 对象头对象头分两部分信息 对象自身的运行时数据(Mark Word)Hash码,GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时戳 类型指针，指向它的类元数据的指针 实例数据存储着程序代码中定义的各种类型的字段内容,包括父类的。 存储顺序收到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java中定义的顺序影响hotspot默认是longs/doubles,ints,shorts/chars,bytes/boolean,oops(Ordinary Object Pointers),也就是宽度的字段会分配到一起，在满足这个条件的情况下，父类定义的变量会在子类之前 对齐填充这部分不是不然存在的，也没有特殊含义，起到占位符的作用，对象大小必须为8字节的倍数，不够就补齐 对象的访问定位Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过什么方式去定位实际上主流的方式有两种 使用句柄这种方式会在Java堆中划分出一块内存作为句柄池,栈中的引用指向的就是对象的句柄地址而句柄中包含了对象实例数据与类型数据各自的地址信息 直接指针访问这种方式存储的直接就是对象地址 两种方式各有优势，使用句柄访问好处是对象被移动的时候，只需要修改句柄的实例数据指针直接指针访问最大的好处就是速度快","categories":[],"tags":[]},{"title":"Java项目基础模板","slug":"Java/JVM/Java项目基础模板","date":"2019-03-24T12:16:25.000Z","updated":"2019-09-29T00:48:10.726Z","comments":true,"path":"2019/03/24/Java/JVM/Java项目基础模板/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/Java项目基础模板/","excerpt":"","text":"功能 鉴权 全局异常处理 一、代码辅助类 lombok 代码简化 freemaker 生成代码引擎 二、监控类 log4j 日志输出","categories":[{"name":"Java项目","slug":"Java项目","permalink":"http://yoursite.com/categories/Java项目/"}],"tags":[]},{"title":"","slug":"Java/JVM/垃圾收集器","date":"2019-03-24T12:16:25.000Z","updated":"2019-10-31T07:01:42.093Z","comments":true,"path":"2019/03/24/Java/JVM/垃圾收集器/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/垃圾收集器/","excerpt":"","text":"Serial收集器最原始的收集器，用于新生代,单线程,没有线程交互的开销对于用在Client模式下的虚拟机是一个很好的选择 ParNew收集器这个实际上就是Serial收集器的多线程版本对于用在Server模式下的虚拟机的首选而且除了Serial收集器以外，只有ParNew能于CMS收集器(并发收集器)配合工作 并行:指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态并发:指用户线程与垃圾收集线程同时执行(不一定并行，可能交替执行),用户线程在继续运行，而垃圾收集程序运行于另一个CPU上 Parallel Scavenge收集器使用复制算法的新生代收集器,并行多线程这个收集器关注点是达到一个可控制的吞吐量 吞吐量:CPU用于运行用户代码的时间与CPU总消耗时间的比值即,吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 停顿时间越短越适合需要与用户交互的程序高吞吐量则可以高效率地利用CPU时间，尽快完成运算任务 提供了两个参数用于精确控制吞吐量 最大垃圾收集停顿时间-XX:MaxGCPauseMillis 设置吞吐量大小-XX:GCTimeRatio 停顿时间越少，吞吐量就越少 -XX:UseAdaptiveSizePolicy是一个开关参数会动态调整新生代的大小Eden与Survivor的比例，晋升老年代对象的年龄-XX:PretenureSizeThreshold,达到最合适的停顿时间或最大吞吐量,称为GC自适应的调节策略 Serial Old 收集器这是Serial收集器的老年代版本，单线程，使用”标记-整理”算法主要也是给Client模式下的虚拟机使用 Parallel Old 收集器Parallel Scavenge的老年代版本，使用多线程和”标记-整理”算法 注意吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器重视服务的相应速度，希望系统停顿时间最短，给用户带来较好的体验，CMS就非常符合这类应用 CMS是基于”标记-清除”算法实现的,运作过程分为4个步骤 初始标记(CMS initial mark) 并发标记(CMS concurrent mark) 重新标记(CMS remark) 并发清除(CMS concurrent sweep) CMS的缺点, 对CPU资源非常敏感，事实上并发设计的程序对CPU资源都比较敏感，并发虽然不会导致用户线程停顿，但是会因为占用了一些CPU资源而导致程序变慢，总吞吐量会降低。 CMS默认启动的回收线程数是(CPU数量+3)/4,也就是当CPU在4个以上时，将占用25%的CPU资源。CPU数越少，影响越大。于是出现了增量式并发收集器/i-CMS,也就是让GC线程和用户线程交替运行，尽量较少GC线程的独占资源的时间，垃圾回收时间会更长，但是对用户程序的影响就会显得少一些,速度下降没那么明显,但是效果一般 无法处理浮动垃圾。浮动垃圾就是GC过程中用户线程并发产生的垃圾，当次不能处理，只能留到下次。也是由于在垃圾收集阶段用户信息还需要运行，那么就需要预留空间给用户线程使用,因此不能等老年代几乎被塞满了再收集。参数-XX:CMSInitiatingOccupancyFraction调高可以降低内存回收次数获得更好的性能。过高的话，内存无法满足程序运行，就会取用Serial Old 标记-清除算法带来的碎片。CMS提供了-XX:UserCMSCompactAtFullCollection开关(默认开启),在CMS要Full GC的时候做碎片整理，碎片整理是无法并发的，所以停顿时间会加长，-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，再执行一次压缩的(默认0，每次进入Full GC都进行碎片整理) G1收集器与其他收集器相比,G1具备如下特点。 并发与并行:能通过多个CPU来缩短停顿时间,并且能通过并发的方式让Java程序继续执行 分代收集:G1不需要其他收集器配合就能独立管理整个GC堆 空间整合 可预测的停顿 Java对的内存布局与其他收集器有很大的差别它将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分区域的集合 可预测的停顿时间模型是因为可以避免对这个Java堆进行垃圾收集，G1会跟踪分析回收价值最大的一个Region，维护一个优先列表，按优先级回收","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/类文件结构","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-02T01:16:53.315Z","comments":true,"path":"2019/03/24/Java/JVM/类文件结构/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/类文件结构/","excerpt":"","text":"类结构Class文件是一组以8位字节为基础单位的二进制流,各个数据紧凑地排列，中间没有任何分割符，需要占用8位以上的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储 Class文件格式采用类似于C语言结构体的伪结构存储数据，且只有两种数据类型无符号数和表无符号数属于基本数据类型，使用u1,u2,u4,u8分别代表1一个字节，2个字节，4个字节，8个字节的无符号数无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值表是由多个无符号数或者其他表作为数据项构成的复合数据类型,表是由_info结尾,用于描述有层次关系的符合结构数据，整个Class文件本质上就是一张表 魔数与Class文件的版本每个Class文件的头4个字节称为魔数字，唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件,用作身份识别。他的值为0xCAFEBABE，魔数的4个字节存储的Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号,Java的版本号是从45开始的 常量池紧接着主版本号的是常量池入口，这个可以理解为Class文件的资源仓库,于其他项目关联最大，并且占用空间最大。常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值常量池第0项空出来的，目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义。Class文件结构中只有这个是从1开始计数的 常量池中主要存放两大类常量 字面量(Literal) 符号引用(Symbolic References)字面量接近Java语言常量的概念，符号引用属于编译原理方面的概念,包含了下面三类常量 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。 常量池的14种表类型,它们有一个共同特点，开始的第一位是一个u1类型的标志位tag，表示属于哪种常量类型。 各个常量表的字段及其表示含义 访问标志接下来就是访问标志 类索引、父类索引与接口索引类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合。Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名父类索引用于确定这个类的父类的全限定名 字段表集合字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量 字段表结构 字段访问标志 方法表集合","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/类加载机制","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-02T01:46:52.300Z","comments":true,"path":"2019/03/24/Java/JVM/类加载机制/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/类加载机制/","excerpt":"","text":"类加载的时机从被加载到虚拟机内存中开始到卸载出内存为止，生命周期包括七个阶段 加载(loading) 验证(Verification) 准备(Preparation) 解析(Resolution) 初始化(Initialization) 使用(Using) 卸载(Unloading) 其中验证、准备、解析三部分称为连接 为了支持Java语言的运行时绑定，某些情况下解析阶段会在初始化之后开始 虚拟机规范严格规定，出来下列五种情况，虚拟机必须对类进行初始化 遇到new、getstatic、putstatic和invokestatic这4条字节码指令时 使用java.lang.reflect包的方法对类进行反射调用时 初始化一个类时，发现父类没有初始化,先初始化父类 虚拟机启动时,用户需要制定一个要执行的主类 MethodHandle实例解析出REF_getStatic,REF_putStatic,REF_invokeStatic方法句柄，对应的类未初始化 类加载的过程加载在加载阶段，虚拟机需要完成以下3件事情 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 类和数组类加载 验证为了确保Class文件的字节流包含的信息符合当前虚拟机的要求验证阶段大致上会完成下面4个阶段的检验动作 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段","categories":[],"tags":[]},{"title":"","slug":"Java/JVM/Java虚拟机的内存分配","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-06T11:47:37.809Z","comments":true,"path":"2019/03/24/Java/JVM/Java虚拟机的内存分配/","link":"","permalink":"http://yoursite.com/2019/03/24/Java/JVM/Java虚拟机的内存分配/","excerpt":"","text":"程序计数器程序计数器是一块较小的内存空间， 在虚拟机的概念模型中，字节码解释器工作时就是通过这个计数器的值选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等 因为Java虚拟机的多线程机制是轮流切换的,因此为了线程切换后能恢复到正常的执行位置,每条线程都有独立的程序计数器并且互相不影响,这块内存称为线程私有 如果线程执行的是Java方法,那么计数器记录的是正在执行的虚拟机字节码指令的地址如果正在执行的是Native方法,那么计数器值为空 程序计数器这个内存区域是在Java虚拟机规范中唯一没有规定OutOfMemoryError情况的区域 Java虚拟机栈与程序计数器一样,Java虚拟机栈也是私有的, 生命周期与线程相同虚拟机栈描述的是Java方法执行的内存区域，每个方法在执行时都会`创建一个栈帧,用于存储 局部变量表 操作数栈 动态链接 方法出口 附加信息 方法从开始调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程 Java虚拟机规范中,对这个区域规定了两种异常情况 StackOverFlowError线程请求的栈深度大于虚拟机允许的深度 OutOfMemoryError如果虚拟机可以动态拓展，拓展无法申请到足够的内存 市面上流行的栈的说法指的只是虚拟机栈的局部变量表 局部变量表局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量) 局部变量表的容量以变量槽为最小单位，每个变量槽都可以存储32位长度的内存空间,其中long和double占用2个局部变量空间,其余数据类型占用1个 复用,方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用优点：节省栈帧空间缺点：影响垃圾回收 所以变量在对应的作用域执行完后,变量要注意置null 操作数栈与局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。 单位占用上与局部变量表一样 当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。 动态连接在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。 Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。 这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接 方法返回当一个方法开始执行时，可能有两种方式退出该方法： 正常完成出口 异常完成出口 正常完成出口:是指方法正常完成并退出，如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。 异常完成出口:是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。 无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。 方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有： 恢复上层方法的局部变量表和操作数栈， 把返回值(如果有的话)压入调用者的操作数栈中， 调整PC计数器的值以指向方法调用指令后的下一条指令。 一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。 附加信息虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现 本地方法栈与虚拟机栈类似作用的栈，不同的是本地方法栈执行的是Native方法,虚拟机栈执行Java方法(字节码)规定的异常情况也一样,包括StackOverFlowError和OutOfMemoryError Java堆对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的，被所有线程共享。在虚拟机启动时创建，此内存区域唯一存在的目的就是存放对象实例,Java虚拟机规范的描述是所有的对象实例以及数组都要在堆上分配随着JIT的发展，栈上分配、标量替换等优化，对象实例也不是绝对会在堆上 Java堆是垃圾收集器管理的主要区域(也叫GC堆,Collected Heap).从内存回收角度来看因为收集器基本采用分代收集算法，所以分为新生代和老年代再细致的有Eden空间,From Survivor空间,To Survivor空间等线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer) 存储的依然都是对象实例，进一步划分的目的是为了更好地回收内存，更快地分配内存 Java虚拟机规定,Java堆物理上不需要连续，逻辑上连续即可并且可以固定固定大小或者可拓展(-Xmx和-Xms)当堆中没有内存并且无法拓展，将抛出OutOfMemoryError 详细的回收与分配细节-&gt; 方法区Java虚拟机规范把方法区归为堆的一个逻辑部分,但它有一个别名叫Non-Heap(非堆),区别于Java堆 与Java堆一样，是线程共享的内存区域用于存储已经被虚拟机加载的 类信息(版本、字段、方法、接口) 常量 静态变量 即时编译器编译后的代码 Java虚拟机规范中，除了和Java堆一样不需要连续的内存和可固定大小或者可拓展外，可以选择不实现垃圾回收,但是事实上还是有必要去实现。曾经的HotSpot虚拟机未对此区域进行回收导致了内存泄露 当方法区无法满足内存分配时，将抛出OutOfMemoryError 运行时常量池运行时常量池是方法区的一部分, 用于存放编译器产生的各种字面量和符号引用,在类加载后进入方法区的运行时常量池。 Java虚拟机对Class文件每一部分的格式都有严格的规定，每一个字节用于存储那种数据都必须符合规范才能被虚拟机认可，装载并运行。但是对于运行时常量池，就没有做任何的细节要求。 运行时常量池对Class文件常量池另外一个重要特征就是具备动态性也就是运行期间也可以把新的常量放入常量池中，比如说String.intern() 既然运行时常量池是方法区一部分,无法满足内存分配时，将抛出OutOfMemoryError 直接内存这个部分不是Java虚拟机运行时数据区的一部分，也没有在Java虚拟机规范中定义，但是也被频繁地使用 在JDK1.4中引入了NIO，引入了基于通道和缓冲区的I/O方式它可以通过Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,提高性能，避免Java堆和Native来回切换","categories":[],"tags":[]}]}
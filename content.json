{"meta":{"title":"Wenk.Chan的个人博客","subtitle":null,"description":null,"author":"Wenk.Chan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java基础1.4 — 异常","slug":"Java基础3.2 — 异常","date":"2019-05-01T07:01:09.960Z","updated":"2019-09-19T13:18:32.809Z","comments":true,"path":"2019/05/01/Java基础3.2 — 异常/","link":"","permalink":"http://yoursite.com/2019/05/01/Java基础3.2 — 异常/","excerpt":"","text":"一、Java中异常分类1.继承关系分类 Throwable:所有异常的基类,指出了代码中可以用通过异常传播机制传输Java程序任何问题的共性 Error:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止 Exception:程序本身可以处理的错误，Exception还有一个重要的子类RunTimeException,RunTimeException及其子类用来表示JVM常用操作引发的错误(NullPointerException、ArithmeticException) 2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)包含Exception和Error在内，Java异常可分为可查异常和不可查异常 可查异常:在程序正常运行中允许发生的异常，并且必须进行处理，否则Java编译器不会通过. 不可查异常:包含RunTimeException及其子类和Error 3、运行时异常和非运行时异常(编译异常) 运行时异常:都是RunTimeException及其子类,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException 非运行时异常(编译异常):RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException 二、异常处理机制1、异常处理机制分为:抛出异常和捕捉异常 抛出异常:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中包括异常类型和异常信息 捕获异常:在抛出异常后，运行时系统就开始寻找合适的异常处理器(exception handler),寻找的地方就是依次留在调用方法栈中的方法的集合,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止 2、Java要求对异常的处理方式对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java基础1.3 — Java相关语法那些事","slug":"Java基础3.1 — Java相关语法","date":"2019-03-25T12:16:25.552Z","updated":"2019-09-19T13:15:53.566Z","comments":true,"path":"2019/03/25/Java基础3.1 — Java相关语法/","link":"","permalink":"http://yoursite.com/2019/03/25/Java基础3.1 — Java相关语法/","excerpt":"","text":"一、Java面向对象的四大特性1.继承性继承性是类的一种层次模型，提供了明确表述共性的方法,对象的新类在类中继承派生。类可以从他的基类继承方法和实例变量，并且类可以修改或者增加新的方法使之更适合特殊的需要 关键字:extends、class 2.多态性多态性是对象在不同时刻表现出来的多种状态,是一种编译时期状态和运行时期状态不一致的现象，多态包括参数多态和包含多态 关键字:interface 3.抽象性抽象是指对一类事物的高度提炼以得到的共性部分,抽象不需要了解全部细节，只是一种通用的描述约束,抽象可以是过程抽象或者数据抽象 关键字:abstract 4.封装性封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性 面向对象的特性:更多的实践使用就是设计模式 二、Java中的基础修饰符1.权限修饰符 private:只能在定义它们的类中使用，在其他类中不能调用。 缺省(default):只能在定义它们的类中，以及同包的类中被调用 protected:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类 public:可以在任何一个类中被调用 2.final①类被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final ②变量被声明为final,必须在声明时初始化，且只能读取不能修改 ③方法被声明为final,不能被重载 一般会使用final和static组合来定义常量 3.static修饰符static可以用来修饰的类成员变量、成员方法、代码块,将独立于对象 被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问) 静态方法不能访问类的非静态方法和成员变量 静态成员变量会被所有的对象共享 静态代码块会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作 关于static还有一个类内元素加载顺序的问题 1234567891011121314151617181920212223242526272829303132333435363738394041//定义一个构造代码块public class Block &#123; Block()&#123; System.out.println(\"block\"); &#125; //定义一个父类 public class Father &#123; Block block=new Block(); static &#123; System.out.println(\"father static block\"); &#125; Father()&#123; System.out.println(\"father static constructor\"); &#125;&#125;//定义一个子类public class Son extends Father &#123; Block block=new Block(); static &#123; System.out.println(\"son static block\"); &#125; Son()&#123; System.out.println(\"son static constructor\"); &#125;&#125;//运行public class Main &#123; public static void main(String argr[])&#123; Son son=new Son(); &#125;&#125; 输出结果为123456father static blockson static blockblockfather static constructorblockson static constructor 可以看出加载顺序是静态代码块-&gt;构造代码块-&gt;构造方法 4.this和superthis为当前类的引用对象，应用场景 构造方法:通过this的调用同类中指定参数类型的构造方法this(参数列表),只能用在构造方法体的第一行 变量:当成员变量与局部变量重名，使用this特指成员变量 方法:在方法中引用该方法所属类的当前对象，注意不能用于this方法(this对象级别，static类级别) super为父类存储空间标识 构造方法:在子类构造方法中调用父类构造方法super(参数列表),同样只能在构造方法体的第一行 三、Java的变长参数在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用...表示 12345public class Varargs&#123; void method(String... args)&#123; &#125;&#125; 四、Java的自增自减运算符这里主要需要注意一个陷阱12345int count = 0;for(int i = 0;i&lt;100;i++)&#123; count = count++;&#125; count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是 JVM把count值拷贝到临时变量区(0) count值加1,此时count为(1) 返回临时变量区的值(0) 此时count被重置为0 也就是不管count = count++多少次，count的值,都是一样。 Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全 synchronized代码块或者方法 使用Lock锁 使用JDK提供的线程安全类AtomicInteger(推荐) 五、equals和hasCode","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java基础1.2 — 关于字符串String、StringBuilder、StringBuffer那些事","slug":"Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事","date":"2019-03-24T02:33:10.360Z","updated":"2019-09-19T13:15:53.561Z","comments":true,"path":"2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/","excerpt":"","text":"一、String的不可变性咱们先来看一下String类的声明123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /` The value is used for character storage. */ private final char value[]; /` Cache the hash code for the string */ private int hash; // Default to 0 首先知道的是String实际上内部维护的是char数组,并且这个数组和String一样，都用final修饰，证明String是不可变的和不可被继承的，进一步解释就是一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变，不能指向其他对象，指向的对象的状态也不能被改变，那么这样设计的好处有什么呢?原因有以下 只有当String是不可变时，String常量池才有可能实现并且为heap节省了空间 网络安全,否则黑客可以改变String指向的对象的值而造成安全漏洞问题 线程安全,可以被多个线程共享 性能,因为String不可变，所以String创建时的hashcode也具有唯一性，作为Map的键时比其他键对象快 二、String Constant Pool(String常量池) JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即String Pool(字符串池) 常量池底层方法是 String#intern() 使用StringTable数据结构保存字符串引用，StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， String#intern() 的性能由O(1)退化到O(n)。 深入解析String#internhttps://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html 在JDK6的版本中，String Pool使用固定容量的HashMap实现并存储在永久代中的，后面变为可配置，因为永久带内存有限，所以在JDK7开始就移动到heap(堆内存)中,这就意味着你可以通过调整堆大小来调整应用程序,通过JVM参数-XX:StringTableSize可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好 创建字符串对象的方式有两种 通过字面常量赋值 通过new关键字新建字符串对象 这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么 1.字面常量赋值123String s1 = \"abc\";String s2 = \"ab\"+\"c\";System.out.println(s1 == s2); //true 常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”; 采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的s1和s2指向的都是同一个对象，用 == 比较就会返回true,我们也可以通过字节码来进一步确认 123450 ldc #2 &lt;abc&gt; 2 astore_13 ldc #2 &lt;abc&gt;5 astore_26 return 当调用ldc #2,如果 #2 的symbol还没解析，则会调用C++底层的 StringTable::intern 方法生成char数组，并将引用保存在 StringTable和常量池中，当下次调用 ldc #2,通过将常量池中 #2对应的字符串推送到栈顶获取到 &quot;abc&quot;，避免再次到StringTable中查找。astore_1 将 &quot;abc&quot; 保存到 局部变量 2.使用new关键字新建123String s3 = new String(\"abc\");String s4 = \"abc\";System.out.println(s3 == s4); //false 我们来分析一下发生了什么①因为”abc”是用字面常量定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②②由于使用了new，所以JVM会在 heap(堆) 中创建一个内容相同的String对象，然后返回堆中Sring对象的引用 下面是字节码123456 0 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;abc&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 return 所以，分别在常量池和堆中生成了两个内容相同的String对象 3.使用变量连接的情况12String s5 = \"ab\";String s6 = s5 + \"c\"; 重点在s6,因为s5是一个变量，即使我们知道这个值，但是Jvm仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 heap(堆) 中创建了一个内容为”abc”的对象并返回给s6,而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现. 下面是字节码 123456789101112 0 ldc #2 &lt;ab&gt; 2 astore_1 3 new #3 &lt;java/lang/StringBuilder&gt; 6 dup 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;10 aload_111 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;14 ldc #6 &lt;c&gt;16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;22 astore_223 return 字符串变量的连接动作，在编译期会被转化成StringBuilder的append操作 4.使用final关键字修饰String12final String s7 = \"ab\";String s8 = s7 + \"c\"; 在这种情况下,final修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc” 下面是字节码123450 ldc #2 &lt;ab&gt;2 astore_13 ldc #3 &lt;abc&gt;5 astore_26 return 三、String、StringBuilder和StringBuffer的区别 String是字符串 常量，而 tringBuilder和StringBuffer都是字符串 变量 StringBuilder是 线程不安全 的，而StringBuffer是 线程安全 的，这样就以为者后者会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高 String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认16个字节数组的大小。扩容就原来的大小 x 2 + 2,可以考虑初始化StringBuilder的大小来提高代码的效率。 四、一些题目1.下面程序运行的结果是什么123456789101112String s1 = \"abc\";StringBuffer s2 = new StringBuffer(s1);System.out.println(s1.equals(s2)); //false String的equals有对参数进行instance of String判断StringBuffer s3 = new StringBuffer(\"abc\");System.out.println(s3.equals(\"abc\")); //StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是System.out.println(s3.toString().equals(\"abc\")); //true 比较的是值String s4 = \"abc\";System.out.println(\"abc\"==s4.subString(0)); //true,如果subString的index是0，直接返回对象System.out.println(\"abc\"==s4.subString(1)); //false,不为0就new一个sub之后的对象返回 除此之外,toLowerCase和toUpperCase都是new一个对象返回 2.下面语句一共创建了多少个对象1String str = new String(\"xyz\"); 这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是两个,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java基础1.1 — Java八大基本数据类型及其包装类","slug":"Java基础1.1 — Java八大基本数据类型及其包装类","date":"2019-03-23T05:36:43.063Z","updated":"2019-09-19T13:15:53.555Z","comments":true,"path":"2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","link":"","permalink":"http://yoursite.com/2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","excerpt":"","text":"序号 数据类型 大小/位 封装类 默认值 可表示数据范围 1 byte 8 java.lang.Byte 0 -128~127 2 short 16 java.lang.Short 0 -32768~32767 3 int 32 java.lang.Integer 0 -2147483648 ~ 2147483647 4 long 64 java.lang.Long 0L -9223372036854775808 ~ 9223372036854775807 5 float 32 java.lang.Float 0F 1.4E-45~3.4028235E38 6 double 64 java.lang.Double 0D 4.9E-324~1.7976931348623157E308 7 char 16 java.lang.Character 空 0~65535 8 boolean 8 java.lang.Boolean false true或false 无需记忆可表示范围，在JDK里面数据类型可承载的最大最小值已经在包装类里面用常量的形式表示出来了如:Integer.MIN_VALUEInteger.MAX_VALUEInteger.SIZE 1、分类 整型：byte、short、int、long 浮点型：float、double 逻辑型：boolean 字符型：char 2、类型转换1byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 从左到右的数据类型转换都是隐式转换，无需强转。 从右到做的数据类型转换需要强转，并且会损失精度 二、包装类java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值,而包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址 1、自动拆箱和自动装箱在JDK1.5以后，提供了自动拆箱和自动装箱功能这样的”语法糖”,如12345//这是自动装箱Integer i = 1; //转换成了Integer i = Integer.valueOf(1);//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException 从字节码看出也是一样的 (通过idea搜索jclasslib bytecode viewer插件查看更方便，安装后在 View-&gt;Show Bytes Code With jclasslib)1234567 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 iconst_1 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 9 astore_210 return 同样地12345//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱Integer i = 1;int j = i;,//后面一句转换成了int j = i.intValue(); 下面是字节码12345678910 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 aload_1 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt; 9 istore_210 aload_111 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;14 istore_315 return 由此也可以看出，自动拆装箱属于编译特性 2、缓存池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Byte valueOf(byte b) &#123; final int offset = 128; return ByteCache.cache[(int)b + offset];&#125;public static Short valueOf(short s) &#123; final int offset = 128; int sAsInt = s; if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache return ShortCache.cache[sAsInt + offset]; &#125; return new Short(s);&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125;public static Float valueOf(float f) &#123; return new Float(f);&#125;public static Double valueOf(double d) &#123; return new Double(d);&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); Byte都是用缓存池里面的值 Short、Integer、Long会缓存 -128~127 Float和Double则直接返回，因为精度数不能每次都一样，所以缓存没有意义 Character则是缓存 &lt;=127 Boolean,只有两个值，直接就用常量的形式表示出来了 三、注意 double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是false,所以在进行带精度计算时，需要用到BigDecimal switch中只能用byte、char、short、int，JDK1.7后可用String Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型 两边都是包装类的equals比较值，== 比较引用，其中一边是表达式的，== 就是比较数值 四、题目1.下面语句做了什么12Integer i = 1; //valueOf()自动装箱成Integer类型i+=1;//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer 2.下面程序语句有什么问题12345678short s1 = 1;s1 = s1 + 1; //编译不通过、需要强转short s2 =1;s2 += 1; //正常编译Integer i = null;int j = i; //NullPointException 3.下面程序的运行结果是什么1234567891011Integer i1 = 128;Integer i2 = 128;System.out.println(i1 == i2); //false 比较了对象Integer i1 = 127;Integer i2 = 127;System.out.println(i1 == i2); //true 缓存了-128~127Float f1 = 1f;Float f2 = 1f;System.out.println(f1 == f2) //false 始终new新对象 https://blog.csdn.net/BuquTianya/article/details/80685437 char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"创建Hexo博客并部署到云主机","slug":"创建Hexo博客并部署到云主机","date":"2018-06-18T09:50:21.000Z","updated":"2019-09-19T13:20:57.137Z","comments":true,"path":"2018/06/18/创建Hexo博客并部署到云主机/","link":"","permalink":"http://yoursite.com/2018/06/18/创建Hexo博客并部署到云主机/","excerpt":"","text":"官方文档 一、云服务器配置(Ubuntu 16.04 LTS)安装git和nginx1apt-get install git-core nginx 配置Nginx创建目录用于存放静态文件 1mkdir /var/www/blog 创建一个Nginx配置文件 1vim /etc/nginx/conf.d/blog.conf 键入以下内容 12345server&#123;listen 8080;root /var/www/blog;&#125; 重启Nginx 1systemctl restart nginx 配置Git Hooks生成blog.git作为仓库，当本地Push过来时自动同步 12mkdir ~/blog.git &amp;&amp; cd ~/blog.gitgit init --bare 创建Hooks脚本，当blog.git收到Push时自动执行post-receive 1vim blog.git/hooks/post-receive 然后脚本里面做的操作就是自动clone 12sudo rm -rf /var/www/blogsudo git clone /root/blog.git /var/www/blog 最后再给个权限 1chmod +x blog.git/hooks/post-receive 二、本地相关配置(Mac OS)安装相关软件123brew install nodebrew install git 然后安装Hexo 1npm install -g hexo-cli 配置参数在自己想要的目录执行 1heox init . 目录如下 在目录下找到配置文件_config.yml并修改 123deploy:type: gitrepo: root@152.92.13.78:blog.git(例) 云服务器最好是使用SSH登录，那种比较方便，通过以下命令即可添加1ssh-add ~./ssh/id_dsa删除1ssh-add -d ./ssh/id_xxx.pub查看#1ssh-add -l 三、执行最后在本地生成静态文件后再进行部署即可 12hexo ghexo d 访问152.92.13.78:8080(例)即为博客站点","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[]},{"title":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","slug":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","date":"2018-06-18T06:48:11.000Z","updated":"2019-09-19T13:22:07.857Z","comments":true,"path":"2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","link":"","permalink":"http://yoursite.com/2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","excerpt":"","text":"一、下载官方链接 官方出厂包下载(FQ) 二、修改解压出来是这个样子 需要把里面的zip文件也解压并且放到同一目录 三、开始刷机最后利用adb进入bootfast模式重启并连接上手机 1adb reboot bootloader 直接运行flash-all.sh即可","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]}]}
{"meta":{"title":"Wenk.Chan的个人博客","subtitle":null,"description":null,"author":"Wenk.Chan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java集合(一) — HashMap","slug":"Java集合(一) — HashMap","date":"2019-11-06T03:49:13.907Z","updated":"2019-11-06T03:49:35.541Z","comments":true,"path":"2019/11/06/Java集合(一) — HashMap/","link":"","permalink":"http://yoursite.com/2019/11/06/Java集合(一) — HashMap/","excerpt":"","text":"一、概要HashMap是一个关联数组、哈希表，其中数组被称为哈希桶，每个桶里放的是单链表或红黑树，每个节点就是哈希表中的元素。 特点是 线程不安全(线程安全可使用ConcurrentHashMap) 遍历无序 允许单个null的key和多个null的值 JDK1.8后，新增了红黑树，当单个链表的元素达到8，就会转换成红黑树，提高查询和插入的效率，避免链表过长的问题 需要关注的问题 hash表，涉及到碰撞解决 数组，涉及到扩容机制 Hash知识补充Hash就是把任意长度的消息(预映射:pre-image)通过哈希算法压缩成固定长度的消息输出,输出的值就是Hash值。不同的输入可能有同样的输出,所以用Hash值得不到唯一值,同样的输出称为碰撞需要进行碰撞处理:一般有:拉链法(open hashing)、开放定址法(closed hashing)、再哈希法、建立公共溢出区 二、碰撞解决从源码可知，HashMap中非常重要的一个字段， Node[] table，即Hash桶数组，Node的数组。 12345678910111213 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用于定位索引 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个Node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125; public final K getKey() &#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了Map.Entry接口，本质是就是一个键值对。每一个节点存储的就是一个Node HashMap使用的是Hash表存储，并且使用拉链法解决碰撞。简单来说，就是数组加链表的结合.当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表。如果发生了碰撞，就会把数据插到对应链表的尾部(JDK1.7是插到头部，插到尾部避免了逆序，环形链表,后文会讲到) 三、扩容机制 理解扩容机制之前需要看一下几个重要的参数 12345678910111213//容量默认为16,且必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//负载默认因子为0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//扩容阈值int threshold; //负载因子final float loadFactor; //结构变化次数int modCount; //实际存储的键值对int size; threshold是HashMap所能容纳的最大数据量,计算公式是threshold = length * loadFactor当存储个数size大于threshold,容量扩大为原来的两倍 modCount用来记录HashMap内部结构发生变化的次数,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value被覆盖不属于结构变化 loadFactor 负载因子默认值是0.75,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重 DEFAULT_INITIAL_CAPACITY 初始容量为16,且为2的幂,采用这种非常规设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 下面来分析一下resize的源码，鉴于红黑树比较复杂，这里先看JDK1.71234567891011121314151617181920 //传入新的容量 void resize(int newCapacity) &#123; //引用扩容前的Entry数组 Entry[] oldTable = table; int oldCapacity = oldTable.length; //扩容前的数组大小如果已经达到最大(2^30)了 if (oldCapacity == MAXIMUM_CAPACITY) &#123; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 threshold = Integer.MAX_VALUE; return; &#125; //初始化一个新的Entry数组 Entry[] newTable = new Entry[newCapacity]; //！！将数据转移到新的Entry数组里 transfer(newTable); //HashMap的table属性引用新的Entry数组 table = newTable; //修改阈值 threshold = (int)(newCapacity * loadFactor);&#125; 本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程 12345678910111213141516171819202122232425void transfer(Entry[] newTable) &#123; //src引用了旧的Entry数组 Entry[] src = table; int newCapacity = newTable.length; //遍历旧的Entry数组 for (int j = 0; j &lt; src.length; j++) &#123; //取得旧Entry数组的每个元素 Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; //释放旧Entry数组的对象引用，防止对象游离 src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; //！！重新计算每个元素在数组中的位置 int i = indexFor(e.hash, newCapacity); //标记 e.next = newTable[i]; //将元素放在数组上 newTable[i] = e; //访问下一个Entry链上的元素 e = next; &#125; while (e != null); &#125; &#125; &#125; e的引用复制给了newTable[i],也就是说这里使用了单链表的头插法，而且需要重新计算每个元素的hash值，这两点与JDK1.8有区别, 下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为原来的2倍1newThr = oldThr &lt;&lt; 1; // double threshold 所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，下图就可以看的出来a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化 我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成&quot;原索引+oldCap&quot; 1newTab[e.hash &amp; (newCap - 1)] = e 下图为16扩充为32的resize示意图 这样，既省去了重新计算hash值的时间，同时，由于新增的1bit可以认为是随机的，因此resize的过程，均匀地把之前的冲突的节点分散到新的bucket了。 JDK1.7的环形链表死循环问题扩容时，当线程A运行到Entry&lt;K,V&gt; next = e.next被挂起，线程B完成了扩容操作后，会出现主要原因是新链表头插操作,导致逆序,JDK1.8之后改用尾插修复，但是仍然是线程不安全 下面是JDK1.8扩容的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果原容量的两倍小于最大容量，且元容量大于默认容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //新容量为原容量的两倍 newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 四、操作方法增put 如果table为null则创建 根据hash计算出元素index(length - 1 &amp; hash效果等同于取模,效率提高),并处理null值 如果key存在,直接覆盖Value 判断是否为红黑树 判断是否为链表 判断是否需要扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; //对key进行hash操作 return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1、如果table为null则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3、如果key存在,直接覆盖Value if (p。hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4、判断是否为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5、判断是否为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表大于阈值则转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在直接覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.alue; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6、判断是否需要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; Java 8系列之重新认识HashMap https://tech.meituan.com/2016/06/24/java-hashmap.htmlHashMap在JDK7和JDK8中的区别 https://zhuanlan.zhihu.com/p/59250175Map 综述（一）：彻头彻尾理解 HashMap https://blog.csdn.net/justloveyou_/article/details/62893086面试必备：HashMap源码解析（JDK8） https://blog.csdn.net/zxt0601/article/details/77413921解决哈希冲突的常用方法分析 https://www.jianshu.com/p/4d3cb99d7580","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java基础(十一) — 序列化","slug":"Java基础(十一) — 序列化","date":"2019-11-06T03:47:25.322Z","updated":"2019-11-06T03:49:35.530Z","comments":true,"path":"2019/11/06/Java基础(十一) — 序列化/","link":"","permalink":"http://yoursite.com/2019/11/06/Java基础(十一) — 序列化/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(十) — 引用","slug":"Java基础(十) — 引用","date":"2019-11-06T03:44:34.425Z","updated":"2019-11-06T03:45:13.379Z","comments":true,"path":"2019/11/06/Java基础(十) — 引用/","link":"","permalink":"http://yoursite.com/2019/11/06/Java基础(十) — 引用/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(九) — 注解","slug":"Java基础(九) — 注解","date":"2019-11-04T04:33:30.879Z","updated":"2019-11-04T04:33:46.911Z","comments":true,"path":"2019/11/04/Java基础(九) — 注解/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(九) — 注解/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(八) — 克隆","slug":"Java基础(八) — 克隆","date":"2019-11-04T04:32:45.667Z","updated":"2019-11-06T03:43:31.645Z","comments":true,"path":"2019/11/04/Java基础(八) — 克隆/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(八) — 克隆/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(七) — 反射","slug":"Java基础(七) — 反射","date":"2019-11-04T03:48:49.848Z","updated":"2019-11-04T03:49:16.339Z","comments":true,"path":"2019/11/04/Java基础(七) — 反射/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(七) — 反射/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(六) — 泛型","slug":"Java基础(六) — 泛型","date":"2019-11-04T03:48:21.248Z","updated":"2019-11-06T03:27:47.913Z","comments":true,"path":"2019/11/04/Java基础(六) — 泛型/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(六) — 泛型/","excerpt":"","text":"一、概述“泛型”简单的意思就是泛指的类型(参数化类型)。主要作用是限制只能往集合中添加一种类型的数据，让错误在编译期暴露，避免运行时异常的发生，提升代码的健壮性。 二、使用1、泛型类123456789101112public class GenericClass&lt;T&gt; &#123; T item; public void setData(T t) &#123; this.item = t; &#125; public T getData() &#123; return this.item; &#125;&#125; 泛型类定义时只需在类名后面加上类型参数，当然也可以添加多个参数，类似于&lt;T,S&gt;。这样就可以在类里面使用定义的类型参数。 2、泛型方法12345678910111213141516public class GenericClass&lt;T&gt; &#123; T item; public void setData(T t) &#123; this.item = t; &#125; public T getData() &#123; return this.item; &#125; public &lt;I&gt; void getInfo(I i) &#123; System.out.println(i); &#125;&#125; 泛型方法声明的方式就是在权限修饰符和返回值之间加上&lt;I&gt;或者任意其他的标识,而里面的I跟类T就算是用一样的标识，也不会是同一个类型，两者作用域不一样。 3、泛型接口1234567891011public interface GenericInterface&lt;T&gt; &#123; public T next();&#125;public class GenericClass implements GenericInterface&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125; 泛型接口在实现时，需要将实参传入，并且接口中使用了参数对应的地方类型也要与传入实参一致 三、类型擦除1、描述泛型在设计时，为了兼容旧版本，Java使用了类型擦除机制。即泛型的参数类型只存在于编译期，运行期获取不到任何已经声明的类型信息,但是会保证类和参数内部参数类型一致。如下 12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2));//true 泛型参数会被擦除到它的第一边界,如果没有边界。类型将被擦除到Object边界可以有多个，使用extends参数可以给参数类型添加一个边界 12345678910111213 public interface Color &#123; void c();&#125;public class Animal&lt;T extends Color&gt; &#123; T desc; public T getDesc() &#123; return desc; &#125; public void setDesc(T desc) &#123; this.descj = desc; &#125;&#125; extends关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到Color类型。 2、原理在编译过程中，类型变量信息还能获取到，所以set的时可以做类型检查，非法类型不能通过编译为了”还原”返回结果的类型，编译器在get之后添加了类型转换 3、缺陷与补救泛型不能显示地运用在运行时类型的操作中，类似于转型、instance of和new，当然也有相应的方法替换 类型判断使用时，把类型参数的Class对象记录 12345678910111213141516class GenericType&lt;T&gt;&#123; Class&lt;?&gt; classType; public GenericType(Class&lt;?&gt; type) &#123; classType=type; &#125; public boolean isInstance(Object object) &#123; return classType.isInstance(object); &#125;&#125;GenericType&lt;A&gt; genericType=new GenericType&lt;&gt;(A.class);System.out.println(\"------------\");System.out.println(genericType.isInstance(new A()));System.out.println(genericType.isInstance(new B())); 创建类型实例使用工厂模式和泛型方法来创建实例对象。代码变动的话，添加新的工厂即可 12345678910111213141516171819202122interface Factory&lt;T&gt;&#123; T create();&#125;class Creater&lt;T&gt;&#123; T instance; public &lt;F extends Factory&lt;T&gt;&gt; T newInstance(F f) &#123; instance=f.create(); return instance; &#125;&#125;class IntegerFactory implements Factory&lt;Integer&gt;&#123; @Override public Integer create() &#123; Integer integer=new Integer(9); return integer; &#125;&#125;Creater&lt;Integer&gt; creater=new Creater&lt;&gt;();System.out.println(creater.newInstance(new IntegerFactory())); 四、泛型通配符1、上界通配符&lt;? extends C&gt;这种形式的通配符，可以实现泛型的向上转型,以ArrayList为例，可以包含的元素就是C的一种子类型(包含C),称为子类型边界 其中能使用的方法有contains、indexOf等形参为Object的方法，还有get是可以，但是只能当做是Object处理但是add(T t)就不行,因为不清楚集合里面的元素是什么类型，所以无法加入任何对象 2、下界通配符&lt;? super C&gt;这种形式的通配符,以ArrayList为例，可以包含的元素就是C(包含C)的超类型,即从当前类的父类直至Object类,称为超类型边界 而能使用的方法只是add,能插入的元素要么是A，要么是A的父类，如果B和C继承于A,且A有一个父类D,那么D也是A和B的父类 不能get，因为不能确定操作的数据是属于哪种类型,除非拿出来当做Object处理 结合上下界通配符，可以这样写入元素,来自Collectoins#copy方法12345678910111213141516171819public static &lt;T&gt; void copy(List&lt;? super T&gt; destination, List&lt;? extends T&gt; source) &#123; if (destination.size() &lt; source.size()) &#123; throw new IndexOutOfBoundsException(\"destination.size() &lt; source.size(): \" + destination.size() + \" &lt; \" + source.size()); &#125; Iterator&lt;? extends T&gt; srcIt = source.iterator(); ListIterator&lt;? super T&gt; destIt = destination.listIterator(); while (srcIt.hasNext()) &#123; try &#123; destIt.next(); &#125; catch (NoSuchElementException e) &#123; // TODO: AssertionError? throw new IndexOutOfBoundsException(\"Source size \" + source.size() + \" does not fit into destination\"); &#125; destIt.set(srcIt.next()); &#125;&#125; PECS原则上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(五) — 异常","slug":"Java基础(五) — 异常","date":"2019-11-04T03:46:59.700Z","updated":"2019-11-05T02:21:27.593Z","comments":true,"path":"2019/11/04/Java基础(五) — 异常/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(五) — 异常/","excerpt":"","text":"一、异常分类1、继承关系分类 Throwable:所有异常的基类,指出了代码中可以用通过异常传播机制传输Java程序任何问题的共性 Error:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止 Exception:程序本身可以处理的错误，Exception还有一个重要的子类RunTimeException,RunTimeException及其子类用来表示JVM常用操作引发的错误(NullPointerException、ArithmeticException) 2、可查和不可查包含Exception和Error在内，Java异常可分为可查异常和不可查异常 可查异常:在程序正常运行中允许发生的异常，并且必须进行处理，否则Java编译器不会通过. 不可查异常:包含RunTimeException及其子类和Error 3、运行时和非运行时 运行时异常:都是RunTimeException及其子类,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException 非运行时异常(编译异常):RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException 二、异常处理机制1、异常处理机制 抛出异常:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中包括异常类型和异常信息 捕获异常:在抛出异常后，运行时系统就开始寻找合适的异常处理器(exception handler),寻找的地方就是依次留在调用方法栈中的方法的集合,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止 2、异常的处理方式 RunTimeException:由运行时系统抛出，可以忽略， Error:属于不允许发生情况，所以不捕捉 可查异常:必须捕捉、或者声明抛出 3、捕捉处理异常语句try-catch-finally 123456789try&#123;&#125; catch(Exception1 e)&#123;&#125; catch(Exception2 e)&#123;&#125; finally &#123;&#125; try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally catch:用于处理捕捉到的异常 finally:无论是否捕捉到异常,都会执行,如果try或者catch中有返回语句，那么finally会在返回之前执行 以下四种情况finally不会被执行 finally出现异常 前面代码使用System.exit()退出程序 程序所有线程死亡 关闭CPU 4、抛出异常 throws如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用throws抛出异常，给上一层处理 抛出规则 对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出 可查异常，要么try-catch捕获，要么使用throws声明抛出 抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(四) — 枚举","slug":"Java基础(四) — 枚举","date":"2019-11-04T03:46:42.388Z","updated":"2019-11-06T03:49:35.535Z","comments":true,"path":"2019/11/04/Java基础(四) — 枚举/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(四) — 枚举/","excerpt":"","text":"一、原理Enum实际上是一种特殊的类，编译后会转换成正常的类，如下简单定义一个枚举类 123public enum Color &#123; WHITE,BLACK&#125; 经过编译后就会转换成一下的样子 123456789101112131415161718192021222324252627282930313233343536//变成了final类并继承与Enumfinal class Color extends Enum&#123; //前面定义的2种枚举实例 public static final Color WHITE; public static final Color BLACK; private static final Color $VALUES[]; static &#123; //实例化枚举实例 WHITE = new Color(\"WHITE\", 0); BLACK = new Color(\"BLACK\", 1); $VALUES = (new Color[] &#123; WHITE, BLACK &#125;); &#125; //编译器为我们添加的静态的values()方法 public static Color[] values() &#123; return (Color[])$VALUES.clone(); &#125; //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法 public static Color valueOf(String s) &#123; return (Color)Enum.valueOf(Color, s); &#125; //私有构造函数 private Color(String s, int i) &#123; super(s, i); &#125; &#125; 二、常见方法 返回类型 方法名称 方法说明 int compareTo(E o) 比较此枚举与指定对象的顺序 boolean equals(Object other) 当指定对象等于此枚举常量时，返回 true。 Class&lt;?&gt; getDeclaringClass() 返回与此枚举常量的枚举类型相对应的 Class 对象 String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明 int ordinal() 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零） String toString() 返回枚举常量的名称，它包含在声明中 static&lt;T extends Enum&gt; T static valueOf(Class enumType, String name) 返回带指定名称的指定枚举类型的枚举常量 值得注意的是Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的 三、进阶用法1、结合抽象方法1234567891011121314151617181920public enum Color &#123; WHITE&#123; @Override public String getDesc() &#123; return \"我是白色\"; &#125; &#125;,BLACK &#123; @Override public String getDesc() &#123; return \"我是黑色\"; &#125; &#125;; public abstract String getDesc();&#125;public class Main &#123; public static void main(String argr[])&#123; String color = Color.WHITE.getDesc(); &#125;&#125; 2、结合接口1234567891011121314public interface Color &#123; enum DeepColor implements Color&#123; DEEP_BLUE,DEEP_GREEN &#125; enum LightColor implements Color&#123; LIGHT_BLUE,LIGHT_GREEN &#125;&#125;public class Main &#123; public static void main(String argr[])&#123; Color color = Color.DeepColor.DEEP_BLUE; &#125;&#125; 四、辅助类1、EnumMapkey为Enum类型的Map 2、EnumSet元素只能为Enum的Set","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(三) — 字符串","slug":"Java基础(三) — 字符串","date":"2019-11-04T03:46:14.670Z","updated":"2019-11-06T03:49:35.519Z","comments":true,"path":"2019/11/04/Java基础(三) — 字符串/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(三) — 字符串/","excerpt":"","text":"一、String的不可变性咱们先来看一下String类中一些关键的代码 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /` The value is used for character storage. */ private final char value[]; /` Cache the hash code for the string */ private int hash; // Default to 0 从上面代码中,首先知道的是String实际上内部维护的是char数组。这个数组和String一样，都用final修饰，证明String是不可变的和不可被继承的。也就是说,一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变,不能指向其他对象，指向的对象的状态也不能被改变。 那么这样设计的好处有什么呢?原因有以下 只有当String是不可变时，String常量池才有可能实现,并且为heap节省了空间 网络安全,否则黑客可以改变String指向的对象的值而造成安全漏洞问题 线程安全,可以被多个线程共享 性能,因为String不可变，所以String创建时的hashcode也具有唯一性，作为Map的键时比其他键对象快 二、常量池 JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即String Constant Pool(字符串常量池) 常量池底层方法是 String#intern() 使用StringTable数据结构保存字符串引用。StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， String#intern() 的性能由O(1)退化到O(n)。 深入解析String#internhttps://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html 在JDK6的版本中，String Pool使用固定容量的HashMap实现并存储在永久代中的，后面变为可配置，因为永久带内存有限，所以在JDK7开始就移动到heap(堆内存)中,这就意味着你可以通过调整堆大小来调整应用程序,通过JVM参数-XX:StringTableSize可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好 创建字符串对象的方式有两种 通过字面常量赋值 通过new关键字新建字符串对象 这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么 1、字面常量赋值123String s1 = \"abc\";String s2 = \"ab\"+\"c\";System.out.println(s1 == s2); //true 常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”; 采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的s1和s2指向的都是同一个对象，用 == 比较就会返回true,我们也可以通过字节码来进一步确认 123450 ldc #2 &lt;abc&gt; 2 astore_13 ldc #2 &lt;abc&gt;5 astore_26 return 当调用ldc #2,如果 #2 的symbol还没解析，则会调用C++底层的 StringTable::intern 方法生成char数组，并将引用保存在 StringTable和常量池中，当下次调用 ldc #2,通过将常量池中 #2对应的字符串推送到栈顶获取到 &quot;abc&quot;，避免再次到StringTable中查找。astore_1 将 &quot;abc&quot; 保存到 局部变量 2、使用new关键字新建123String s3 = new String(\"abc\");String s4 = \"abc\";System.out.println(s3 == s4); //false 我们来分析一下发生了什么①因为”abc”是用字面常量定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②由于使用了new，所以JVM会在 heap(堆) 中创建一个内容相同的String对象，然后返回堆中String对象的引用 下面是new String(“abc”)字节码123456 0 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;abc&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 return 所以s3指向的是堆中的对象，s4指向的是常量池中的对象,虽然内容相同，但是==比较的是对象，所以为false 3、使用变量连接的情况12String s5 = \"ab\";String s6 = s5 + \"c\"; 重点在s6,因为s5是一个变量，即使我们知道这个值，但是JVM仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 heap(堆) 中创建了一个内容为”abc”的对象并返回给s6而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现. 下面是字节码 123456789101112 0 ldc #2 &lt;ab&gt; 2 astore_1 3 new #3 &lt;java/lang/StringBuilder&gt; 6 dup 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;10 aload_111 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;14 ldc #6 &lt;c&gt;16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;22 astore_223 return 从字节码中也可以看出来，字符串变量的连接动作，在编译期会被转化成StringBuilder的append操作 4、使用final关键字修饰String12final String s7 = \"ab\";String s8 = s7 + \"c\"; 在这种情况下,final修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc” 下面是字节码123450 ldc #2 &lt;ab&gt;2 astore_13 ldc #3 &lt;abc&gt;5 astore_26 return 三、StringBuilder和StringBuffer String是字符串 常量，而 StringBuilder和StringBuffer都是字符串 变量 StringBuilder是 线程不安全 的，而StringBuffer是 线程安全 的(append方法使用了synchronized修饰)，所以StringBuilder的效率比StringBuffer高 String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认16个字节数组的大小。扩容就原来的大小 x 2 + 2,可以考虑初始化StringBuilder的大小来提高代码的效率。 四、一些题目下面程序运行的结果是什么123456789101112String s1 = \"abc\";StringBuffer s2 = new StringBuffer(s1);System.out.println(s1.equals(s2)); //false String的equals有对参数进行instance of String判断StringBuffer s3 = new StringBuffer(\"abc\");System.out.println(s3.equals(\"abc\")); //StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是System.out.println(s3.toString().equals(\"abc\")); //true 比较的是值String s4 = \"abc\";System.out.println(\"abc\"==s4.subString(0)); //true,如果subString的index是0，直接返回对象System.out.println(\"abc\"==s4.subString(1)); //false,不为0就new一个sub之后的对象返回 除此之外,toLowerCase和toUpperCase都是new一个对象返回 下面语句一共创建了多少个对象1String str = new String(\"xyz\"); 这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是两个,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(二) — 基本数据类型.md","slug":"Java基础(二) — 基本数据类型","date":"2019-11-04T03:45:52.262Z","updated":"2019-11-06T03:49:35.525Z","comments":true,"path":"2019/11/04/Java基础(二) — 基本数据类型/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(二) — 基本数据类型/","excerpt":"","text":"一、基本信息以下是八大基本数据类型大小、取值、默认值、对应包装类信息 数据类型 大小 封装类 默认值 可表示数据范围 byte 8 java.lang.Byte 0 -128~127(2^7) short 16 java.lang.Short 0 -32768~32767(2^15) int 32 java.lang.Integer 0 -2147483648 ~ 2147483647(2^31) long 64 java.lang.Long 0L -9223372036854775808 ~ 9223372036854775807 (2^63) float 32 java.lang.Float 0F 1.4E-45~3.4028235E38 double 64 java.lang.Double 0D 4.9E-324~1.7976931348623157E308 char 16 java.lang.Character 空 0~65535 boolean 8 java.lang.Boolean false true或false 包装类有对应最小值、最大值和大小的常量,如:Integer.MIN_VALUEInteger.MAX_VALUEInteger.SIZE 进一步可以分为以下四类 整型：byte(字节型)、short(短整型)、int(整型)、long(长整型) 浮点型：float(单精度浮点型)、double(双精度浮点型) 逻辑型：boolean(布尔型) 字符型：char(字符型) 二、数据类型转换根据取值范围的大小将数据类型排序,数据类型的转换也跟这个排序有关 1byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 数据类型之间的转换分为两种自动转换和 强制转换 1、自动转换在表达式中,当较”小”的数据与较”大”的数据一起进行运算时，系统会自动将”小”的数据转换成”大”的数据再进行运算在调用方式时,如果实参比形参&quot;小&quot;,也会将”小”的数据转换成”大”的数据 在表达式中，数据类型会出现自动提升，规则如下 所有的byte,short,char的值将被提升为int 如果有一个操作数是long，计算结果是long 如果有一个操作数是float，计算结果是float 如果有一个操作数是double，计算结果是double 2、强制转换将”大”数据转换成”小”数据时，就需要强制转换,并且会损失精度 三、包装类java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址 在JDK1.5以后，提供了自动装箱和自动拆箱功能这样的”语法糖” 1、自动装箱12345//这是自动装箱Integer i = 1; //转换成了Integer i = Integer.valueOf(1);//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException 从字节码看出也是一样的 1234567 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 iconst_1 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 9 astore_210 return 2、自动拆箱12345Integer i = 1;//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱int j = i;//后面一句转换成了int j = i.intValue(); 下面是字节码12345678910 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 aload_1 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt; 9 istore_210 aload_111 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;14 istore_315 return 由此也可以看出，自动拆装箱属于编译特性 3、缓存池在包装类中,为了避免频繁地创建和销毁对象，就有缓存池的出现，下面是各个包装类对应缓存池的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Byte valueOf(byte b) &#123; final int offset = 128; return ByteCache.cache[(int)b + offset];&#125;public static Short valueOf(short s) &#123; final int offset = 128; int sAsInt = s; if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache return ShortCache.cache[sAsInt + offset]; &#125; return new Short(s);&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125;public static Float valueOf(float f) &#123; return new Float(f);&#125;public static Double valueOf(double d) &#123; return new Double(d);&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 根据代码可以得知包装类的缓存池规则 Byte都是用缓存池里面的值 Short、Integer、Long会缓存 -128~127 Float和Double则直接返回，因为精度数不能每次都一样，所以缓存没有意义 Character则是缓存 &lt;=127 Boolean,只有两个值，直接就用常量的形式表示出来 四、注意 double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是false,所以在进行带精度计算时，需要用到BigDecimal switch中只能用byte、char、short、int，JDK1.7后可用String Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型 两边都是包装类的equals比较值，== 比较引用，其中一边是表达式的，== 就是比较值 char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(拓展资料) 五、题目下面语句做了什么12Integer i = 1; //valueOf()自动装箱成Integer类型i+=1;//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer 下面程序语句有什么问题12345678short s1 = 1;s1 = s1 + 1; //编译不通过、需要强转short s2 =1;s2 += 1; //正常编译,自动做了类型转换Integer i = null;int j = i; //NullPointException 下面程序的运行结果是什么1234567891011Integer i1 = 128;Integer i2 = 128;System.out.println(i1 == i2); //false 比较了对象Integer i1 = 127;Integer i2 = 127;System.out.println(i1 == i2); //true 缓存了-128~127Float f1 = 1f;Float f2 = 1f;System.out.println(f1 == f2) //false 始终new新对象","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础(一) — 语法","slug":"Java基础(一) — 语法","date":"2019-11-04T03:45:24.520Z","updated":"2019-11-06T03:49:35.514Z","comments":true,"path":"2019/11/04/Java基础(一) — 语法/","link":"","permalink":"http://yoursite.com/2019/11/04/Java基础(一) — 语法/","excerpt":"","text":"一、面向对象的四大特性1、继承性继承性是类的一种层次模型，提供了明确表述共性的方法,对象的新类在类中继承派生。类可以从他的基类继承方法和实例变量，并且类可以修改或者增加新的方法使之更适合特殊的需要 关键字:extends、class 2、多态性多态性是对象在不同时刻表现出来的多种状态,是一种编译时期状态和运行时期状态不一致的现象，多态包括参数多态和包含多态 关键字:interface 3、抽象性抽象是指对一类事物的高度提炼以得到的共性部分,抽象不需要了解全部细节，只是一种通用的描述约束,抽象可以是过程抽象或者数据抽象 关键字:abstract 4、封装性封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性 面向对象的特性:更多的实践使用就是设计模式 二、类三、基础修饰符1、权限修饰符 private:只能在定义它们的类中使用，在其他类中不能调用。 缺省(default):只能在定义它们的类中，以及同包的类中被调用 protected:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类 public:可以在任何一个类中被调用 2、final①类被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final ②变量被声明为final,必须在声明时初始化，且只能读取不能修改 ③方法被声明为final,不能被重载 一般会使用final和static组合来定义常量 3、staticstatic可以用来修饰的类成员变量、成员方法、代码块,将独立于对象 被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问) 静态方法不能访问类的非静态方法和成员变量 静态成员变量会被所有的对象共享 静态代码块会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作 关于static还有一个类内元素加载顺序的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//定义一个构造代码块public class Block &#123; Block(String who) &#123; System.out.println(who+\" new\"); &#125;&#125; //定义一个父类 public class Father &#123; static Block staticblock = new Block(\"father static\"); Block block = new Block(\"father\"); static &#123; System.out.println(\"father static block\"); &#125; &#123; System.out.println(\"father block\"); &#125; Father() &#123; System.out.println(\"father constructor\"); &#125;&#125;//定义一个子类public class Son extends Father &#123; static Block staticblock = new Block(\"son static\"); Block block = new Block(\"son\"); static &#123; System.out.println(\"son static block\"); &#125; &#123; System.out.println(\"son block\"); &#125; Son() &#123; System.out.println(\"son constructor\"); &#125;&#125;//运行public class Main &#123; public static void main(String argr[])&#123; Son son=new Son(); &#125;&#125; 输出结果为12345678910father static newfather static blockson static newson static blockfather newfather blockfather constructorson newson blockson constructor 可以看出加载顺序是 父类静态成员变量 父类静态代码块 子类静态成员变量 子类静态代码块 父类非静态成员变量 父类非静态代码块 父类构造方法 子类非静态成员变量 子类非静态代码块 子类构造方法 由此也可以得知执行子类构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误 4、this和superthis为当前类的引用对象，应用场景 构造方法:通过this的调用同类中指定参数类型的构造方法this(参数列表),只能用在构造方法体的第一行 变量:当成员变量与局部变量重名，使用this特指成员变量 方法:在方法中引用该方法所属类的当前对象，注意不能用于static方法(this对象级别，static类级别) super为父类存储空间标识 构造方法:在子类构造方法中调用父类构造方法super(参数列表),同样只能在构造方法体的第一行 5、instance ofinstance of运算符是用来在运行时指出对象是否是特定类的一个实例 四、方法的重写和重载1、重写子类对父类允许访问的方法的方法体进行覆盖并重新实现 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 2、重载重载是在一个类里面，方法名字相同,而参数的类型和个数不同的方法 12345678public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; 五、变长参数在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用...表示 12345public class Varargs&#123; void method(String... args)&#123; &#125;&#125; 六、自增自减运算符这里主要需要注意一个陷阱12345int count = 0;for(int i = 0;i&lt;100;i++)&#123; count = count++;&#125; count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是 JVM把count值拷贝到临时变量区(0) count值加1,此时count为(1) 返回临时变量区的值(0) 此时count被重置为0 也就是不管count = count++多少次，count的值,都是一样。 Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全 synchronized代码块或者方法 使用Lock锁 使用JDK提供的线程安全类AtomicInteger(推荐) 七、其他1、== 与 equals==:基础数据类型比较的是值，引用比较的是内存地址，即两个对象是否同一个equals:默认情况下，equals的作用与==一样是比较对象。有些类会将equals方法重写，如String重写比较的是对象的值 2、equals 与 hashCodehashCode方法定义在Object.java中，说明任何一个Java类都有hashCode方法hashCode的作用是获取哈希码,特点是能够根据”key”迅速获取对应的”value”,而且hashCode相等的两个对象不一定相等(碰撞)，所以比较两个对象是否相等时 先判断hashCode是否存在相同的 发现了相同hashCode的对象才会时候equals去判断 这样会大大减少equals使用的频率，提高执行速度","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"","slug":"类加载机制","date":"2019-11-02T01:17:51.419Z","updated":"2019-11-02T01:46:52.300Z","comments":true,"path":"2019/11/02/类加载机制/","link":"","permalink":"http://yoursite.com/2019/11/02/类加载机制/","excerpt":"","text":"类加载的时机从被加载到虚拟机内存中开始到卸载出内存为止，生命周期包括七个阶段 加载(loading) 验证(Verification) 准备(Preparation) 解析(Resolution) 初始化(Initialization) 使用(Using) 卸载(Unloading) 其中验证、准备、解析三部分称为连接 为了支持Java语言的运行时绑定，某些情况下解析阶段会在初始化之后开始 虚拟机规范严格规定，出来下列五种情况，虚拟机必须对类进行初始化 遇到new、getstatic、putstatic和invokestatic这4条字节码指令时 使用java.lang.reflect包的方法对类进行反射调用时 初始化一个类时，发现父类没有初始化,先初始化父类 虚拟机启动时,用户需要制定一个要执行的主类 MethodHandle实例解析出REF_getStatic,REF_putStatic,REF_invokeStatic方法句柄，对应的类未初始化 类加载的过程加载在加载阶段，虚拟机需要完成以下3件事情 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 类和数组类加载 验证为了确保Class文件的字节流包含的信息符合当前虚拟机的要求验证阶段大致上会完成下面4个阶段的检验动作 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段","categories":[],"tags":[]},{"title":"","slug":"类文件结构","date":"2019-10-31T07:57:16.076Z","updated":"2019-11-02T01:16:53.315Z","comments":true,"path":"2019/10/31/类文件结构/","link":"","permalink":"http://yoursite.com/2019/10/31/类文件结构/","excerpt":"","text":"类结构Class文件是一组以8位字节为基础单位的二进制流,各个数据紧凑地排列，中间没有任何分割符，需要占用8位以上的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储 Class文件格式采用类似于C语言结构体的伪结构存储数据，且只有两种数据类型无符号数和表无符号数属于基本数据类型，使用u1,u2,u4,u8分别代表1一个字节，2个字节，4个字节，8个字节的无符号数无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值表是由多个无符号数或者其他表作为数据项构成的复合数据类型,表是由_info结尾,用于描述有层次关系的符合结构数据，整个Class文件本质上就是一张表 魔数与Class文件的版本每个Class文件的头4个字节称为魔数字，唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件,用作身份识别。他的值为0xCAFEBABE，魔数的4个字节存储的Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号,Java的版本号是从45开始的 常量池紧接着主版本号的是常量池入口，这个可以理解为Class文件的资源仓库,于其他项目关联最大，并且占用空间最大。常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值常量池第0项空出来的，目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义。Class文件结构中只有这个是从1开始计数的 常量池中主要存放两大类常量 字面量(Literal) 符号引用(Symbolic References)字面量接近Java语言常量的概念，符号引用属于编译原理方面的概念,包含了下面三类常量 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。 常量池的14种表类型,它们有一个共同特点，开始的第一位是一个u1类型的标志位tag，表示属于哪种常量类型。 各个常量表的字段及其表示含义 访问标志接下来就是访问标志 类索引、父类索引与接口索引类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合。Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名父类索引用于确定这个类的父类的全限定名 字段表集合字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量 字段表结构 字段访问标志 方法表集合","categories":[],"tags":[]},{"title":"","slug":"垃圾收集器","date":"2019-10-30T13:04:20.382Z","updated":"2019-10-31T07:01:42.093Z","comments":true,"path":"2019/10/30/垃圾收集器/","link":"","permalink":"http://yoursite.com/2019/10/30/垃圾收集器/","excerpt":"","text":"Serial收集器最原始的收集器，用于新生代,单线程,没有线程交互的开销对于用在Client模式下的虚拟机是一个很好的选择 ParNew收集器这个实际上就是Serial收集器的多线程版本对于用在Server模式下的虚拟机的首选而且除了Serial收集器以外，只有ParNew能于CMS收集器(并发收集器)配合工作 并行:指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态并发:指用户线程与垃圾收集线程同时执行(不一定并行，可能交替执行),用户线程在继续运行，而垃圾收集程序运行于另一个CPU上 Parallel Scavenge收集器使用复制算法的新生代收集器,并行多线程这个收集器关注点是达到一个可控制的吞吐量 吞吐量:CPU用于运行用户代码的时间与CPU总消耗时间的比值即,吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 停顿时间越短越适合需要与用户交互的程序高吞吐量则可以高效率地利用CPU时间，尽快完成运算任务 提供了两个参数用于精确控制吞吐量 最大垃圾收集停顿时间-XX:MaxGCPauseMillis 设置吞吐量大小-XX:GCTimeRatio 停顿时间越少，吞吐量就越少 -XX:UseAdaptiveSizePolicy是一个开关参数会动态调整新生代的大小Eden与Survivor的比例，晋升老年代对象的年龄-XX:PretenureSizeThreshold,达到最合适的停顿时间或最大吞吐量,称为GC自适应的调节策略 Serial Old 收集器这是Serial收集器的老年代版本，单线程，使用”标记-整理”算法主要也是给Client模式下的虚拟机使用 Parallel Old 收集器Parallel Scavenge的老年代版本，使用多线程和”标记-整理”算法 注意吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器重视服务的相应速度，希望系统停顿时间最短，给用户带来较好的体验，CMS就非常符合这类应用 CMS是基于”标记-清除”算法实现的,运作过程分为4个步骤 初始标记(CMS initial mark) 并发标记(CMS concurrent mark) 重新标记(CMS remark) 并发清除(CMS concurrent sweep) CMS的缺点, 对CPU资源非常敏感，事实上并发设计的程序对CPU资源都比较敏感，并发虽然不会导致用户线程停顿，但是会因为占用了一些CPU资源而导致程序变慢，总吞吐量会降低。 CMS默认启动的回收线程数是(CPU数量+3)/4,也就是当CPU在4个以上时，将占用25%的CPU资源。CPU数越少，影响越大。于是出现了增量式并发收集器/i-CMS,也就是让GC线程和用户线程交替运行，尽量较少GC线程的独占资源的时间，垃圾回收时间会更长，但是对用户程序的影响就会显得少一些,速度下降没那么明显,但是效果一般 无法处理浮动垃圾。浮动垃圾就是GC过程中用户线程并发产生的垃圾，当次不能处理，只能留到下次。也是由于在垃圾收集阶段用户信息还需要运行，那么就需要预留空间给用户线程使用,因此不能等老年代几乎被塞满了再收集。参数-XX:CMSInitiatingOccupancyFraction调高可以降低内存回收次数获得更好的性能。过高的话，内存无法满足程序运行，就会取用Serial Old 标记-清除算法带来的碎片。CMS提供了-XX:UserCMSCompactAtFullCollection开关(默认开启),在CMS要Full GC的时候做碎片整理，碎片整理是无法并发的，所以停顿时间会加长，-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，再执行一次压缩的(默认0，每次进入Full GC都进行碎片整理) G1收集器与其他收集器相比,G1具备如下特点。 并发与并行:能通过多个CPU来缩短停顿时间,并且能通过并发的方式让Java程序继续执行 分代收集:G1不需要其他收集器配合就能独立管理整个GC堆 空间整合 可预测的停顿 Java对的内存布局与其他收集器有很大的差别它将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分区域的集合 可预测的停顿时间模型是因为可以避免对这个Java堆进行垃圾收集，G1会跟踪分析回收价值最大的一个Region，维护一个优先列表，按优先级回收","categories":[],"tags":[]},{"title":"","slug":"HotSpot的垃圾回收算法实现","date":"2019-10-30T02:11:14.271Z","updated":"2019-10-30T13:02:43.312Z","comments":true,"path":"2019/10/30/HotSpot的垃圾回收算法实现/","link":"","permalink":"http://yoursite.com/2019/10/30/HotSpot的垃圾回收算法实现/","excerpt":"","text":"枚举根节点在可达性分析中，可作为GC Roots的节点主要在全局性的引用(常量或类静态属性)与执行上下文(栈帧中的局部变量表)中但是现在应用仅仅方法区就数百兆，要逐个检查完，那么必然消耗很多时间。 而且在这个工作还需要进行GC停顿，因为这项分析工作必须能保持一致性，就是不可以在分析过程中对象的关系还在变化 目前主流的Java虚拟机使用的都是准确式GC，也就是当执行系统停顿下来后，虚拟机有办法直接得知哪些方法存放着这些对象引用，hotspot中使用一组称为OopMap的数据结构来达到这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就直接知道这些信息了。 安全点需要关注的一个点事，如果为每一条指令都生成对应的OopMap，会需要大量的额外空间,但是hotspot很显然并没有这样做，只是在特定的位置记录了这些信息，而这些位置称为安全点。即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 安全点选定的标准是，是否具有让程序长时间运行的特征 另外一个需要考虑的问题，如何在GC发生时让所有线程，都跑到最近的安全点上再停顿下来，两种方案 抢先式中断GC发生时，把所有的线程中断，如果现有的线程中断不在安全点上，就恢复线程让它跑到安全点上(弃用) 主动式中断设置一个标志，各个线程在执行时主动去轮询这个标志，发现中断标志就自挂东南枝。实际情况会有线程处于block或sleep的状态,无法走到中断标志，这时候就需要安全区域 安全区域指的是，在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的，","categories":[],"tags":[]},{"title":"","slug":"JVM回收","date":"2019-10-29T02:46:58.393Z","updated":"2019-10-30T02:07:36.803Z","comments":true,"path":"2019/10/29/JVM回收/","link":"","permalink":"http://yoursite.com/2019/10/29/JVM回收/","excerpt":"","text":"判断对象是否存活主流的实现中使用的都是可达性分析(Reachability Analysis) 基本思想是,以一系列称为GC Roots的对象作为起始点,从这些节点往下开始搜索，搜索所走过的路称为引用链,当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用 在Java语言中,可作为GC Roots的对象包括 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 即使通过可达性分析算法中不可达的对象，并非”非死不可”。真正要宣告一个对象死亡，至少要经历两次标记过程 通过可达性分析被发现不可达后就会被标记，并且进行一次筛选筛选的条件是此对象是否有必要执行finalize()方法，判断条件如下 当对象没有覆盖finalize方法 已经被虚拟机执行过了 这两种情况都没有必要执行 如果对象被判断有必要执行，那么这个对象就会被放置到一个F-Queue中，并且由虚拟机创建一个低优先级的Finalizer执行。注意这里只会是触发，不会等待运行结束。 如果在finalize过程中与引用链中的对上建立了联系，那么这个对象就不会被回收。反之则会被第二次标记，进行回收 需要注意的是，任何对象的finalize方法只会被执行一次，面对下一次回收就不会被执行了 回收方法区(永久代)永久代的垃圾回收主要回收两部分 废弃常量 无用的类 废弃常量，以常量池中的字面量为例，比如字符串“abc”,如果当前系统中没有任何一个String对象是”abc”,那就会被清出常量池 要清出无用的类需要满足下面3个条件 该类所有的实例都已经被回收 加载该类的ClassLoader已经被回收 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问 垃圾回收算法标记-清除算法分为”标记”和”清除”两个阶段。首先标记处所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记的算法就是之前说的可达性算法。 这是最基础的收集算法,因为后续的算法都是基于这种思路并且对其不足进行优化，主要的不足有两个 效率标记和清除两个过程的效率都不高 空间标记清除之后会产生大量不连续的内存碎片。空间碎片太多会到导致后面需要分配大对象时，无法获得连续的内存而不得触发另一次垃圾回收 复制算法为了解决效率问题而出现，它将可用内存按容量划分为相等大小的两块，每次只使用其中一块，当着一块用完了，就把存活的对象复制到另一快，然后把使用过的内存空间一次清理 目前的商业虚拟机都采用的这种手机算法来回收新生代将内存分为一块较大的Eden空间和两块小的Survivor,每次使用Eden和其中一块Survivor当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一个Survivor，最后清理Eden和之前的Survivor，Eden和Survivor的比例是8:1因为无法保证回收时存活的对象少于10%，Survivor的空间不足时，需要依赖其他的内存进行分配担保那么这些对象将直接通过分配担保机制进入老年代。~to be continue 标记-整理算法复制收集算法在对象存活率较高时，需要较多的复制操作，效率会变低。另外，如果不想浪费50%的空间，就需要额外的空间做分配担保，应对对象100%存活率的极端标记还是使用可达性算法，整理是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存 分代收集算法一般是把Java堆分为新生代和老年代新生代，每次垃圾手机时都发现有大批对象死去，只有少量存活，那就复制复制算法老年代，因为存活率高，没有额外的空间分配担保，必须使用标记清理或标记整理算法","categories":[],"tags":[]},{"title":"","slug":"JVM对象相关","date":"2019-10-28T04:11:45.311Z","updated":"2019-10-28T14:02:21.422Z","comments":true,"path":"2019/10/28/JVM对象相关/","link":"","permalink":"http://yoursite.com/2019/10/28/JVM对象相关/","excerpt":"","text":"对象的创建检查当虚拟机遇到一条new指令时(克隆，反序列化)，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用,检查有没有被加载,解析和初始化过，如果没有，在执行相应的类加载的过程（疑问） 分配内存接下来虚拟机会为新生对象分配内存，分配的方式有两种 指针碰撞内存规整，用指针分开已用内存和空闲内存 空闲列表内存不规整，维护一个列表记录空闲的内存 防止并发 虚拟机会使用CAS配上失败重试的方式保持更新的原子性 还有另外一种方法，在每个线程的Java栈中分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，哪个线程需要分配内存，就在TLAB上分配，内存用完了,同步锁定是否使用TLAB，可以通过 -XX:+/-UserTLAB参数设定 分配完成之后，分配到的内存空间都会被初始化为零,并且为对象头赋值,从虚拟机的层面来说已经创建完成了 接下来执行&lt;init&gt;方法，按照程序员的意愿进行初始化 对象的内存布局对象在内存中存储的布局可以分为3块区域:对象头、实例数据、对齐填充 对象头对象头分两部分信息 对象自身的运行时数据(Mark Word)Hash码,GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时戳 类型指针，指向它的类元数据的指针 实例数据存储着程序代码中定义的各种类型的字段内容,包括父类的。 存储顺序收到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java中定义的顺序影响hotspot默认是longs/doubles,ints,shorts/chars,bytes/boolean,oops(Ordinary Object Pointers),也就是宽度的字段会分配到一起，在满足这个条件的情况下，父类定义的变量会在子类之前 对齐填充这部分不是不然存在的，也没有特殊含义，起到占位符的作用，对象大小必须为8字节的倍数，不够就补齐 对象的访问定位Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过什么方式去定位实际上主流的方式有两种 使用句柄这种方式会在Java堆中划分出一块内存作为句柄池,栈中的引用指向的就是对象的句柄地址而句柄中包含了对象实例数据与类型数据各自的地址信息 直接指针访问这种方式存储的直接就是对象地址 两种方式各有优势，使用句柄访问好处是对象被移动的时候，只需要修改句柄的实例数据指针直接指针访问最大的好处就是速度快","categories":[],"tags":[]},{"title":"","slug":"2019-10-25","date":"2019-10-25T04:01:25.815Z","updated":"2019-10-25T04:01:50.876Z","comments":true,"path":"2019/10/25/2019-10-25/","link":"","permalink":"http://yoursite.com/2019/10/25/2019-10-25/","excerpt":"","text":"# 线程之间的通信机制有两种：共享内存和消息传递","categories":[],"tags":[]},{"title":"Java多线程 - synchronized关键字 3.2","slug":"Java多线程 - synchronized关键字 3.2","date":"2019-10-24T05:28:16.971Z","updated":"2019-11-04T03:38:55.720Z","comments":true,"path":"2019/10/24/Java多线程 - synchronized关键字 3.2/","link":"","permalink":"http://yoursite.com/2019/10/24/Java多线程 - synchronized关键字 3.2/","excerpt":"","text":"synchronized的作用是保证方法或代码在运时，同一时刻只有一个方法可以进到临界区,同时还可以保证共享变量的内存可见性 synchronized可修饰的对象有 代码块synchronized(){}，范围是大括号{}括起来的部分,作用对象是小括号里的对象 方法，范围是整个方法,作用对象是调用这个方法的对象 静态方法,范围是整个静态方法,作用对象是这个类的所有对象 类，作用范围是synchronized后面括号部分，作用对象是类的所有对象 底层语义原理Java虚拟机中的同步基于进入和退出monitor对象实现,显式同步和隐式同步都是 (monitorenter和monitorexit指令)二同步方法是由方法调用指令，读取运行时常量池中方法的ACC_SYNCHRONIZED标志来隐式实现的。对理解synchronized原理来说，Java对象头的概念很重要 Java对象头在JVM中，对象在内存中的布局分为三块区域对象头、实例数据、填充数据 实例变量:存放类的属性数据信息，包括父类的属性信息，数组还包括数组长度，按4字节对齐 填充数据:由于虚拟机要求对象的起始地址必须是8字节的倍数,所以就有了填充,为了字节对齐 JVM中采用2个字存储对象头(数组是3个,多一个记录数组长度) 其主要结构是由Mark Word和Class Metadata Address组成 虚拟机位数 头对象结构 说明 32/64bit Mark Word 存储对象的HashCode、锁信息或分代年龄或GC标志 32/64bit Class Metadata Address 类型指针指向对象的类元数据，确认该对象是哪个类的实例 各种锁状态下Mark Word存储情况 锁状态 25bit 4bit 1bit 是否是偏向锁 2bit 锁标志位 无锁状态 对象HashCode 对象分代年龄 0 01 偏向锁 线程ID(23bit) Epoch(2bit) 对象分代年龄 0 01 轻量级锁 指向锁记录的指针 对象分代年龄 0 00 重量级锁 指向重量级锁的指针 对象分代年龄 0 10 GC标记 空 对象分代年龄 1 11 synchronized在JDK1.6优化之后才出现偏向锁和轻量级锁 synchronized的三种锁的状态及升级原理偏向锁偏向锁的意思是如果一个线程获取了一个偏向锁,在接下来的一段时间没有其他线程来竞争，那么持有偏向锁的线程再次进入同步代码时，不再需要抢占锁和释放锁的操作 偏向锁获取方式 首先判断目标对象的对象头，根据标识和epoch判断是否处于可偏向状态 是的话，通过自旋锁的方式将自己的线程ID复制到对象头的Mark Work,继续执行 不是的话，判断自己的线程ID跟对象头Mark Work中的是否相等，相等证明已获得,继续执行不用进行竞争和释放操作 如果不相等，需要撤销偏向锁 轻量级锁当偏向锁撤销，有两种情况 线程已经退出同步代码,接下来就是撤销偏向锁,升级为轻量级锁 线程正在执行同步代码，原来的线程会继续持有锁并且升级为轻量级锁 轻量级锁获取方式 JVM会在当前的线程栈帧中创建一个用于存储锁记录的空间 将对象头的Mark Work的记录复制到锁记录中 线程尝试用自旋锁的方式将对象头Mark Work替换为指向所记录空间的指针 替换成功,则当前线程获取轻量级锁 替换失败，则存在其他线程竞争，自旋若干次失败后，会升级成重量级锁 重量级锁重量级锁依赖对象内部的monitor锁实现，而monitor又依赖操作系统的MutexLock(互斥锁) 重量级锁开销比较大的原因是，阻塞和唤醒一个线程，都需要通过操作系统完成，从用户态转换到内核态相对耗时 https://blog.csdn.net/javazejian/article/details/72828483https://blog.csdn.net/chenssy/article/details/54883355https://zhuanlan.zhihu.com/p/53080541 reentrantlockhttps://juejin.im/post/5aeb0a8b518825673a2066f0 atomichttps://www.cnblogs.com/nullzx/p/4967931.html","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java多线程 - volatile关键字 3.1","slug":"Java多线程 - volatile关键字","date":"2019-09-30T10:30:22.358Z","updated":"2019-10-03T10:35:28.204Z","comments":true,"path":"2019/09/30/Java多线程 - volatile关键字/","link":"","permalink":"http://yoursite.com/2019/09/30/Java多线程 - volatile关键字/","excerpt":"","text":"由于volatile关键字涉及到内存模型，所以了解内存模型也很关键 一、内存模型的相关概念volatile关键字涉及到内存模型主要就是CPU的高速缓存 1i = i + 1; 当线程执行这条语句时 复制一份到高速缓存 执行完+1操作后的值，写入高速缓存 最后再把高速缓存中的值刷新到主内存中 在单核CPU中是没问题的，但是多核CPU就不一样了线程A和线程B有可能同时读取一份到高速缓存，然后分别操作和写入到主内存中期望结果是2，但是最后出来的是1 这就是缓存一致性的问题 通常解决的方法有两个(硬件提供的) 在CPU总线上加LOCK#锁 通过缓存一致性协议(MESI协议) 因为LOCK#锁的效率低下，所以才会有缓存一致性协议出现具体表现为，当发现操作的变量是共享变量，也就是其他CPU中存在变量的副本，那么这些CPU对应的缓存行就会无效,再次操作时，需要从主内存中重新读取 二、并发编程中的三个概念 原子性:一个或多个操作，要么全部执行，要么全部不执行，不会别任何因素打断 可见性:当多个线程访问一个变量时，一个线程修改了变量，其他线程能立即看到 有序性:即程序执行的顺序按照代码的先后顺序执行 关于有序性的一些拓展1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 语句1和语句2不一定按顺序执行，因为可能会发生指令重排序指令重排序是为了提高运行效率，不保证允许顺序一致，但是保证运行的结果一致 当然前提是数据之间没有数据依赖性，而且是单线程运行 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 三、volatile关键字剖析语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 volatile是无法保证原子性，可以采用方法有 synchronized关键字 Lock AtomicInteger等原子操作类 原理和实现机制加入volatile关键字后,汇编代码会多出一个lock前缀命令，lock前缀命令实际上相当于一个内存屏障,内存屏障提供了3个功能 保证了指令重排序时，后面的不会排到内存屏障前，前面的也不会排到内存屏障后，也就是说，运行到内存屏障时，前面的操作都已经完成 强制对缓存的修改立即写入主存 写操作时，会导致其他CPU的缓存行无效 使用场景 对变量的写操作不依赖当前值 该变量没有包含在具有其他变量的不变式中 这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 状态标记量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; Java并发编程：volatile关键字解析 https://www.cnblogs.com/dolphin0520/p/3920373.html","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java项目基础模板","slug":"Java项目基础模板","date":"2019-09-29T00:34:14.093Z","updated":"2019-09-29T00:48:10.726Z","comments":true,"path":"2019/09/29/Java项目基础模板/","link":"","permalink":"http://yoursite.com/2019/09/29/Java项目基础模板/","excerpt":"","text":"功能 鉴权 全局异常处理 一、代码辅助类 lombok 代码简化 freemaker 生成代码引擎 二、监控类 log4j 日志输出","categories":[{"name":"Java项目","slug":"Java项目","permalink":"http://yoursite.com/categories/Java项目/"}],"tags":[]},{"title":"Java基础2.3 — Map家族之TreeMap","slug":"Java基础2.3 — Map家族之TreeMap","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-04T03:38:55.748Z","comments":true,"path":"2019/03/24/Java基础2.3 — Map家族之TreeMap/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础2.3 — Map家族之TreeMap/","excerpt":"","text":"TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 该映射根据其键的自然顺序(字母排序)进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap是非线程安全的。 它的iterator 方法返回的迭代器是fail-fast的。","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java基础2.2 — Map家族之LinkedHashMap","slug":"Java基础2.2 — Map家族之LinkedHashMap","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-04T03:38:55.742Z","comments":true,"path":"2019/03/24/Java基础2.2 — Map家族之LinkedHashMap/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础2.2 — Map家族之LinkedHashMap/","excerpt":"","text":"一、概要LinkHashMap继承自HashMap 特点 线程不安全(线程安全可使用ConcurrentHashMap) 允许单个null的key和多个null的值 新增遍历有序 存储结构同样是数组+链表+红黑树，为了实现有序,单链表改成了双向链表,Entry继承了HashMap.Node,并且新增了两个参数,记录节点前后的节点信息 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 而且还新增了head,tail这两个成员变量记录了链表的头部和尾部accessOrder就是控制输出顺序。默认false123456//链表头部transient LinkedHashMap.Entry&lt;K,V&gt; head;//链表尾部transient LinkedHashMap.Entry&lt;K,V&gt; tail;//遍历时的顺序，true 访问顺序 false 插入顺序final boolean accessOrder; 总的来说，相对HashMap，多了遍历有序 二、操作方法增put这里没有对put方法进行重写，重写的是构建新节点的的方法newNode(),并通过linkNodeLast将新节点连接到内部双向链表的尾部 1234567891011121314151617Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;// 把节点添加到链表尾部private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; 以及HashMap专门留下来的回调方法 afterNodeAccess afterNodeInsertion afterNodeRemoval 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//被访问后回调，会将被访问的节点移到链表尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; //回调函数，新节点插入之后回调,根据evict和设定是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。void afterNodeInsertion(boolean evict) &#123; LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125;//回调函数，将节点从双向链表中删除void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。 lrucache","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]},{"title":"Java基础3.1 — 线程基础","slug":"Java基础3.1 — 线程的基本概念","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-04T03:38:55.727Z","comments":true,"path":"2019/03/24/Java基础3.1 — 线程的基本概念/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础3.1 — 线程的基本概念/","excerpt":"","text":"一、线程的基本概念并行(Parallel)和并发(concurrent) 并发是相对一个CPU,分时间片执行任务,同一时间间隔事件 并行是相对多个CPU,分别同时执行任务,同一时间点事件 并行和串行 串行是执行完一个任务再去执行下一个 并行是多个任务同时执行 同步和异步 同步是顺序进行，需要进行等待，协调 异步在等待某一个任务执行过程中继续执行自己的任务,线程是实现异步的一个方式 多线程多线程是程序设计的逻辑概念，指的是在进程中并发运行的一段代码，实现多个线程间切换执行 二、线程的状态在Java类库,Thread类中有一个State的枚举类列出了线程的6个状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 可运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统地称为”运行”。调用了start()方法。线程位于可运行线程池中,等待被线程调度选中，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 并发编程艺术并行并发不一定就比串行快，因为线程的创建和上下文切换也需要开销 lmbench3可以测量上下文切换的时长 vmstat可以测量上下文切换的次数 减少上下文切换的方法 无锁并发编程:使用一些方法来避免用锁 CAS:使用Atomic包的CAS算法更新数据，不用加锁 避免使用不必要的线程 协程:单线程实现多任务调度 减少waiting线 使用jstack工具dump出对应进程的线程信息 查看哪些线程waiting比较多 根据线程对应的程序调整 避免死锁的方法 避免一个线程获取多个锁 避免一个线程在锁内获取多个资源 尝试使用定时锁 数据库锁，加锁解锁都必须在同一个数据库连接 各种操作的一些资源利用下载文件 带宽 硬盘读写速度 数据库操作 数据库连接数 volatilevolatile是轻量级的synchronized,能在多处理器开发中保证共享变量的&quot;可见性&quot;,意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果一个变量被声明为volatile，那么Java线程内存模型确保所有线程看到这个变量的值是一致的。 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000","categories":[{"name":"Java多线程","slug":"Java多线程","permalink":"http://yoursite.com/categories/Java多线程/"}],"tags":[]},{"title":"Java基础2.4 — Map家族之HashTable","slug":"Java基础2.4 — Map家族之HashTable","date":"2019-03-24T12:16:25.000Z","updated":"2019-11-04T03:38:55.732Z","comments":true,"path":"2019/03/24/Java基础2.4 — Map家族之HashTable/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础2.4 — Map家族之HashTable/","excerpt":"","text":"判断 value 是否为空，为空则抛出异常；计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value；否则，我们可以将其插入到 table[index] 位置。 HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。 Hashtable 的 key 和 value 都不允许为 null。Hashtable遇到 null，直接返回 NullPointerException。 Hashtable 方法是同步，几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。","categories":[{"name":"Java集合","slug":"Java集合","permalink":"http://yoursite.com/categories/Java集合/"}],"tags":[]}]}
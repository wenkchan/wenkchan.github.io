{"meta":{"title":"Wenk.Chan的个人博客","subtitle":null,"description":null,"author":"Wenk.Chan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java基础2.2 — Map家族之LinkedHashMap","slug":"Java基础2.2 — Map家族之LinkedHashMap","date":"2019-09-24T06:26:51.963Z","updated":"2019-09-24T06:37:51.079Z","comments":true,"path":"2019/09/24/Java基础2.2 — Map家族之LinkedHashMap/","link":"","permalink":"http://yoursite.com/2019/09/24/Java基础2.2 — Map家族之LinkedHashMap/","excerpt":"","text":"一、概要LinkHashMap继承自HashMap(),只是在HashMap的基础上多保证了顺序","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础2.1 — Map家族之HashMap","slug":"Java基础2.1 — Map家族之HashMap","date":"2019-09-22T10:35:45.895Z","updated":"2019-09-24T06:29:44.387Z","comments":true,"path":"2019/09/22/Java基础2.1 — Map家族之HashMap/","link":"","permalink":"http://yoursite.com/2019/09/22/Java基础2.1 — Map家族之HashMap/","excerpt":"","text":"一、概要根据key的hashCode值存储数据,大多数情况下(碰撞)可以直接定位到它的值,因此访问快,但不保证遍历顺序。 只允许一条记录的键为null,允许多条记录的值为null。 HashMap非线程安全,如果需要线程安全,可以用 Collections的synchronizedMap,或者使用ConcurrentHashMap。 二、存储结构从结构实现来讲HashMap就是数组+链表+红黑树(JDK1.8新增了红黑树) 要搞明白的两个问题: 数据底层存储的是什么? 这种存储方式有什么优缺点? 从源码可知，HashMap中非常重要的一个字段， Node[] table，即Hash桶数组，Node的数组。 12345678910111213 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用于定位索引 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个Node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125; public final K getKey() &#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了Map.Entry接口，本质是就是一个键值对。每一个节点存储的就是一个Node Hash补充Hash就是把任意长度的消息(预映射:pre-image)通过哈希算法压缩成固定长度的消息输出,输出的值就是Hash值。不同的输入可能有同样的输出,所以用Hash值得不到唯一值,同样的输出称为碰撞需要进行碰撞处理:一般是两种:拉链法(open hashing)和开地址法(closed hashing) HashMap使用的就是Hash表存储，并且使用拉链法解决碰撞 从图中可以看出,左边是数组,右边是链表。结合了数组寻址容易和链表插入、删除容易的优点，使用方法就是根据key的特征把value分配到对应的链表中,同样,也可以根据key去寻找到对应的元素。而根据key特征计算出所属数组下标的方法就是Hash算法。 好的Hash算法配合好的扩容机制，就可以使分布均匀，碰撞概率降低，查询效率上升，减少占用空间 三、分析1、扩容机制 理解扩容机制之前需要看一下几个重要的参数 12345678910111213//容量默认为16,且必须为2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//负载默认因子为0.75static final float DEFAULT_LOAD_FACTOR = 0。75f;//扩容阈值int threshold; //负载因子final float loadFactor; //结构变化次数int modCount; //实际存储的键值对int size; threshold是HashMap所能容纳的最大数据量,计算公式是threshold = length * loadFactor当存储个数size大于threshold,容量扩大为原来的两倍 modCount用来记录HashMap内部结构发生变化的次数,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value被覆盖不属于结构变化 loadFactor 负载因子默认值是0.75,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重 DEFAULT_INITIAL_CAPACITY 初始容量为16,且为2的幂,采用这种非常规设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 下面来分析一下resize的源码，鉴于红黑树比较复杂，这里先看JDK1.712345678910111213 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125; &#125; e的引用复制给了newTable[i],也就是说这里使用了单链表的头插法，而且需要重新计算每个元素的hash值，这两点与JDK1.8有区别 下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为原来的2倍1newThr = oldThr &lt;&lt; 1; // double threshold 所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，下图就可以看的出来a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化 我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap” 1newTab[e.hash &amp; (newCap - 1)] = e 下图为16扩充为32的resize示意图 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀地把之前的冲突的节点分散到新的bucket了。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置,且JDK1.8不会 在多线程使用场景中使用HashMap会导致环形链表的出现，从而导致死循环 2、put方法 如果table为null则创建 根据hash计算出元素index(length - 1 &amp; hash效果等同于取模,效率提高),并处理null值 如果key存在,直接覆盖Value 判断是否为红黑树 判断是否为链表 判断是否需要扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; //对key进行hash操作 return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1、如果table为null则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3、如果key存在,直接覆盖Value if (p。hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4、判断是否为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5、判断是否为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表大于阈值则转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //key存在直接覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.alue; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6、判断是否需要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 四、JDK8新增优化 新增红黑树 单链表头插改尾插,避免出现逆序，环形链表 扩容机制优化效率 Java 8系列之重新认识HashMap https://tech.meituan.com/2016/06/24/java-hashmap.htmlHashMap在JDK7和JDK8中的区别 https://zhuanlan.zhihu.com/p/59250175Map 综述（一）：彻头彻尾理解 HashMap https://blog.csdn.net/justloveyou_/article/details/62893086面试必备：HashMap源码解析（JDK8） https://blog.csdn.net/zxt0601/article/details/77413921","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础1.4 — 异常","slug":"Java基础3.2 — 异常","date":"2019-05-01T07:01:09.960Z","updated":"2019-09-21T03:11:20.868Z","comments":true,"path":"2019/05/01/Java基础3.2 — 异常/","link":"","permalink":"http://yoursite.com/2019/05/01/Java基础3.2 — 异常/","excerpt":"","text":"一、Java中异常分类1.继承关系分类 Throwable:所有异常的基类,指出了代码中可以用通过异常传播机制传输Java程序任何问题的共性 Error:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止 Exception:程序本身可以处理的错误，Exception还有一个重要的子类RunTimeException,RunTimeException及其子类用来表示JVM常用操作引发的错误(NullPointerException、ArithmeticException) 2、可查异常(checked exceptions)和不可查异常(unchecked exceptions)包含Exception和Error在内，Java异常可分为可查异常和不可查异常 可查异常:在程序正常运行中允许发生的异常，并且必须进行处理，否则Java编译器不会通过. 不可查异常:包含RunTimeException及其子类和Error 3、运行时异常和非运行时异常(编译异常) 运行时异常:都是RunTimeException及其子类,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException 非运行时异常(编译异常):RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException 二、异常处理机制1、异常处理机制分为:抛出异常和捕捉异常 抛出异常:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中包括异常类型和异常信息 捕获异常:在抛出异常后，运行时系统就开始寻找合适的异常处理器(exception handler),寻找的地方就是依次留在调用方法栈中的方法的集合,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止 2、Java要求对异常的处理方式 RunTimeException:由运行时系统抛出，可以忽略， Error:属于不允许发生情况，所以不捕捉 可查异常:必须捕捉、或者声明抛出 3、捕捉处理异常语句try-catch-finally123456789try&#123;&#125; catch(Exception1 e)&#123;&#125; catch(Exception2 e)&#123;&#125; finally &#123;&#125; try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally catch:用于处理捕捉到的异常 finally:无论是否捕捉到异常,都会执行,如果try或者catch中有返回语句，那么finally会在返回之前执行 以下四种情况finally不会被执行 finally出现异常 前面代码使用System.exit()退出程序 程序所有线程死亡 关闭CPU 4、抛出异常 throws如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用throws抛出异常，给上一层处理 ###抛出规则 对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出 可查异常，要么try-catch捕获，要么使用throws声明抛出 抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础1.3 — Java相关语法那些事","slug":"Java基础3.1 — Java相关语法","date":"2019-03-25T12:16:25.552Z","updated":"2019-09-19T13:24:21.190Z","comments":true,"path":"2019/03/25/Java基础3.1 — Java相关语法/","link":"","permalink":"http://yoursite.com/2019/03/25/Java基础3.1 — Java相关语法/","excerpt":"","text":"一、Java面向对象的四大特性1.继承性继承性是类的一种层次模型，提供了明确表述共性的方法,对象的新类在类中继承派生。类可以从他的基类继承方法和实例变量，并且类可以修改或者增加新的方法使之更适合特殊的需要 关键字:extends、class 2.多态性多态性是对象在不同时刻表现出来的多种状态,是一种编译时期状态和运行时期状态不一致的现象，多态包括参数多态和包含多态 关键字:interface 3.抽象性抽象是指对一类事物的高度提炼以得到的共性部分,抽象不需要了解全部细节，只是一种通用的描述约束,抽象可以是过程抽象或者数据抽象 关键字:abstract 4.封装性封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性 面向对象的特性:更多的实践使用就是设计模式 二、Java中的基础修饰符1.权限修饰符 private:只能在定义它们的类中使用，在其他类中不能调用。 缺省(default):只能在定义它们的类中，以及同包的类中被调用 protected:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类 public:可以在任何一个类中被调用 2.final①类被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final ②变量被声明为final,必须在声明时初始化，且只能读取不能修改 ③方法被声明为final,不能被重载 一般会使用final和static组合来定义常量 3.static修饰符static可以用来修饰的类成员变量、成员方法、代码块,将独立于对象 被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问) 静态方法不能访问类的非静态方法和成员变量 静态成员变量会被所有的对象共享 静态代码块会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作 关于static还有一个类内元素加载顺序的问题 1234567891011121314151617181920212223242526272829303132333435363738394041//定义一个构造代码块public class Block &#123; Block()&#123; System.out.println(\"block\"); &#125; //定义一个父类 public class Father &#123; Block block=new Block(); static &#123; System.out.println(\"father static block\"); &#125; Father()&#123; System.out.println(\"father static constructor\"); &#125;&#125;//定义一个子类public class Son extends Father &#123; Block block=new Block(); static &#123; System.out.println(\"son static block\"); &#125; Son()&#123; System.out.println(\"son static constructor\"); &#125;&#125;//运行public class Main &#123; public static void main(String argr[])&#123; Son son=new Son(); &#125;&#125; 输出结果为123456father static blockson static blockblockfather static constructorblockson static constructor 可以看出加载顺序是静态代码块-&gt;构造代码块-&gt;构造方法 4.this和superthis为当前类的引用对象，应用场景 构造方法:通过this的调用同类中指定参数类型的构造方法this(参数列表),只能用在构造方法体的第一行 变量:当成员变量与局部变量重名，使用this特指成员变量 方法:在方法中引用该方法所属类的当前对象，注意不能用于this方法(this对象级别，static类级别) super为父类存储空间标识 构造方法:在子类构造方法中调用父类构造方法super(参数列表),同样只能在构造方法体的第一行 三、Java的变长参数在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用...表示 12345public class Varargs&#123; void method(String... args)&#123; &#125;&#125; 四、Java的自增自减运算符这里主要需要注意一个陷阱12345int count = 0;for(int i = 0;i&lt;100;i++)&#123; count = count++;&#125; count++是一个有返回值的表达式，返回值是count自加之前的值，具体步骤是 JVM把count值拷贝到临时变量区(0) count值加1,此时count为(1) 返回临时变量区的值(0) 此时count被重置为0 也就是不管count = count++多少次，count的值,都是一样。 Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全 synchronized代码块或者方法 使用Lock锁 使用JDK提供的线程安全类AtomicInteger(推荐) 五、equals和hasCode","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础1.2 — 关于字符串String、StringBuilder、StringBuffer那些事","slug":"Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事","date":"2019-03-24T02:33:10.360Z","updated":"2019-09-19T13:24:21.186Z","comments":true,"path":"2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/","link":"","permalink":"http://yoursite.com/2019/03/24/Java基础2.1 — 关于字符串String、StringBuilder、StringBuffer那些事/","excerpt":"","text":"一、String的不可变性咱们先来看一下String类的声明123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /` The value is used for character storage. */ private final char value[]; /` Cache the hash code for the string */ private int hash; // Default to 0 首先知道的是String实际上内部维护的是char数组,并且这个数组和String一样，都用final修饰，证明String是不可变的和不可被继承的，进一步解释就是一旦String对象被创建，那么内部的成员变量的值包括基本数据类型都不能被改变，不能指向其他对象，指向的对象的状态也不能被改变，那么这样设计的好处有什么呢?原因有以下 只有当String是不可变时，String常量池才有可能实现并且为heap节省了空间 网络安全,否则黑客可以改变String指向的对象的值而造成安全漏洞问题 线程安全,可以被多个线程共享 性能,因为String不可变，所以String创建时的hashcode也具有唯一性，作为Map的键时比其他键对象快 二、String Constant Pool(String常量池) JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即String Pool(字符串池) 常量池底层方法是 String#intern() 使用StringTable数据结构保存字符串引用，StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中HashMap相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， String#intern() 的性能由O(1)退化到O(n)。 深入解析String#internhttps://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html 在JDK6的版本中，String Pool使用固定容量的HashMap实现并存储在永久代中的，后面变为可配置，因为永久带内存有限，所以在JDK7开始就移动到heap(堆内存)中,这就意味着你可以通过调整堆大小来调整应用程序,通过JVM参数-XX:StringTableSize可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好 创建字符串对象的方式有两种 通过字面常量赋值 通过new关键字新建字符串对象 这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么 1.字面常量赋值123String s1 = \"abc\";String s2 = \"ab\"+\"c\";System.out.println(s1 == s2); //true 常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”; 采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的s1和s2指向的都是同一个对象，用 == 比较就会返回true,我们也可以通过字节码来进一步确认 123450 ldc #2 &lt;abc&gt; 2 astore_13 ldc #2 &lt;abc&gt;5 astore_26 return 当调用ldc #2,如果 #2 的symbol还没解析，则会调用C++底层的 StringTable::intern 方法生成char数组，并将引用保存在 StringTable和常量池中，当下次调用 ldc #2,通过将常量池中 #2对应的字符串推送到栈顶获取到 &quot;abc&quot;，避免再次到StringTable中查找。astore_1 将 &quot;abc&quot; 保存到 局部变量 2.使用new关键字新建123String s3 = new String(\"abc\");String s4 = \"abc\";System.out.println(s3 == s4); //false 我们来分析一下发生了什么①因为”abc”是用字面常量定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入②②由于使用了new，所以JVM会在 heap(堆) 中创建一个内容相同的String对象，然后返回堆中Sring对象的引用 下面是字节码123456 0 new #2 &lt;java/lang/String&gt; 3 dup 4 ldc #3 &lt;abc&gt; 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt; 9 astore_110 return 所以，分别在常量池和堆中生成了两个内容相同的String对象 3.使用变量连接的情况12String s5 = \"ab\";String s6 = s5 + \"c\"; 重点在s6,因为s5是一个变量，即使我们知道这个值，但是Jvm仍然认为这是一个变量，所以在编译期，这个值是未知的。在运行期，JVM就在 heap(堆) 中创建了一个内容为”abc”的对象并返回给s6,而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现. 下面是字节码 123456789101112 0 ldc #2 &lt;ab&gt; 2 astore_1 3 new #3 &lt;java/lang/StringBuilder&gt; 6 dup 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;10 aload_111 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;14 ldc #6 &lt;c&gt;16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;22 astore_223 return 字符串变量的连接动作，在编译期会被转化成StringBuilder的append操作 4.使用final关键字修饰String12final String s7 = \"ab\";String s8 = s7 + \"c\"; 在这种情况下,final修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc” 下面是字节码123450 ldc #2 &lt;ab&gt;2 astore_13 ldc #3 &lt;abc&gt;5 astore_26 return 三、String、StringBuilder和StringBuffer的区别 String是字符串 常量，而 tringBuilder和StringBuffer都是字符串 变量 StringBuilder是 线程不安全 的，而StringBuffer是 线程安全 的，这样就以为者后者会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高 String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认16个字节数组的大小。扩容就原来的大小 x 2 + 2,可以考虑初始化StringBuilder的大小来提高代码的效率。 四、一些题目1.下面程序运行的结果是什么123456789101112String s1 = \"abc\";StringBuffer s2 = new StringBuffer(s1);System.out.println(s1.equals(s2)); //false String的equals有对参数进行instance of String判断StringBuffer s3 = new StringBuffer(\"abc\");System.out.println(s3.equals(\"abc\")); //StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是System.out.println(s3.toString().equals(\"abc\")); //true 比较的是值String s4 = \"abc\";System.out.println(\"abc\"==s4.subString(0)); //true,如果subString的index是0，直接返回对象System.out.println(\"abc\"==s4.subString(1)); //false,不为0就new一个sub之后的对象返回 除此之外,toLowerCase和toUpperCase都是new一个对象返回 2.下面语句一共创建了多少个对象1String str = new String(\"xyz\"); 这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是两个,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"Java基础1.1 — Java八大基本数据类型及其包装类","slug":"Java基础1.1 — Java八大基本数据类型及其包装类","date":"2019-03-23T05:36:43.063Z","updated":"2019-09-20T15:11:07.094Z","comments":true,"path":"2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","link":"","permalink":"http://yoursite.com/2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","excerpt":"","text":"序号 数据类型 大小/位 封装类 默认值 可表示数据范围 1 byte 8 java.lang.Byte 0 -128~127 2 short 16 java.lang.Short 0 -32768~32767 3 int 32 java.lang.Integer 0 -2147483648 ~ 2147483647 4 long 64 java.lang.Long 0L -9223372036854775808 ~ 9223372036854775807 5 float 32 java.lang.Float 0F 1.4E-45~3.4028235E38 6 double 64 java.lang.Double 0D 4.9E-324~1.7976931348623157E308 7 char 16 java.lang.Character 空 0~65535 8 boolean 8 java.lang.Boolean false true或false 无需记忆可表示范围，在JDK里面数据类型可承载的最大最小值已经在包装类里面用常量的形式表示出来了如:Integer.MIN_VALUEInteger.MAX_VALUEInteger.SIZE 1、分类 整型：byte、short、int、long 浮点型：float、double 逻辑型：boolean 字符型：char 2、类型转换1byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 从左到右的数据类型转换都是隐式转换，无需强转。 从右到做的数据类型转换需要强转，并且会损失精度 二、包装类java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值,而包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址 1、自动拆箱和自动装箱在JDK1.5以后，提供了自动拆箱和自动装箱功能这样的”语法糖”,如12345//这是自动装箱Integer i = 1; //转换成了Integer i = Integer.valueOf(1);//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException 从字节码看出也是一样的 (通过idea搜索jclasslib bytecode viewer插件查看更方便，安装后在 View-&gt;Show Bytes Code With jclasslib)1234567 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 iconst_1 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 9 astore_210 return 同样地12345//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱Integer i = 1;int j = i;,//后面一句转换成了int j = i.intValue(); 下面是字节码12345678910 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 aload_1 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt; 9 istore_210 aload_111 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;14 istore_315 return 由此也可以看出，自动拆装箱属于编译特性 2、缓存池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Byte valueOf(byte b) &#123; final int offset = 128; return ByteCache.cache[(int)b + offset];&#125;public static Short valueOf(short s) &#123; final int offset = 128; int sAsInt = s; if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache return ShortCache.cache[sAsInt + offset]; &#125; return new Short(s);&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125;public static Float valueOf(float f) &#123; return new Float(f);&#125;public static Double valueOf(double d) &#123; return new Double(d);&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); Byte都是用缓存池里面的值 Short、Integer、Long会缓存 -128~127 Float和Double则直接返回，因为精度数不能每次都一样，所以缓存没有意义 Character则是缓存 &lt;=127 Boolean,只有两个值，直接就用常量的形式表示出来了 三、注意 double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是false,所以在进行带精度计算时，需要用到BigDecimal switch中只能用byte、char、short、int，JDK1.7后可用String Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型 两边都是包装类的equals比较值，== 比较引用，其中一边是表达式的，== 就是比较数值 四、题目1.下面语句做了什么12Integer i = 1; //valueOf()自动装箱成Integer类型i+=1;//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer 2.下面程序语句有什么问题12345678short s1 = 1;s1 = s1 + 1; //编译不通过、需要强转short s2 =1;s2 += 1; //正常编译Integer i = null;int j = i; //NullPointException 3.下面程序的运行结果是什么1234567891011Integer i1 = 128;Integer i2 = 128;System.out.println(i1 == i2); //false 比较了对象Integer i1 = 127;Integer i2 = 127;System.out.println(i1 == i2); //true 缓存了-128~127Float f1 = 1f;Float f2 = 1f;System.out.println(f1 == f2) //false 始终new新对象 char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(拓展资料)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java基础/"}],"tags":[]},{"title":"创建Hexo博客并部署到云主机","slug":"创建Hexo博客并部署到云主机","date":"2018-06-18T09:50:21.000Z","updated":"2019-09-19T13:20:57.137Z","comments":true,"path":"2018/06/18/创建Hexo博客并部署到云主机/","link":"","permalink":"http://yoursite.com/2018/06/18/创建Hexo博客并部署到云主机/","excerpt":"","text":"官方文档 一、云服务器配置(Ubuntu 16.04 LTS)安装git和nginx1apt-get install git-core nginx 配置Nginx创建目录用于存放静态文件 1mkdir /var/www/blog 创建一个Nginx配置文件 1vim /etc/nginx/conf.d/blog.conf 键入以下内容 12345server&#123;listen 8080;root /var/www/blog;&#125; 重启Nginx 1systemctl restart nginx 配置Git Hooks生成blog.git作为仓库，当本地Push过来时自动同步 12mkdir ~/blog.git &amp;&amp; cd ~/blog.gitgit init --bare 创建Hooks脚本，当blog.git收到Push时自动执行post-receive 1vim blog.git/hooks/post-receive 然后脚本里面做的操作就是自动clone 12sudo rm -rf /var/www/blogsudo git clone /root/blog.git /var/www/blog 最后再给个权限 1chmod +x blog.git/hooks/post-receive 二、本地相关配置(Mac OS)安装相关软件123brew install nodebrew install git 然后安装Hexo 1npm install -g hexo-cli 配置参数在自己想要的目录执行 1heox init . 目录如下 在目录下找到配置文件_config.yml并修改 123deploy:type: gitrepo: root@152.92.13.78:blog.git(例) 云服务器最好是使用SSH登录，那种比较方便，通过以下命令即可添加1ssh-add ~./ssh/id_dsa删除1ssh-add -d ./ssh/id_xxx.pub查看#1ssh-add -l 三、执行最后在本地生成静态文件后再进行部署即可 12hexo ghexo d 访问152.92.13.78:8080(例)即为博客站点","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[]},{"title":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","slug":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","date":"2018-06-18T06:48:11.000Z","updated":"2019-09-19T13:22:07.857Z","comments":true,"path":"2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","link":"","permalink":"http://yoursite.com/2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","excerpt":"","text":"一、下载官方链接 官方出厂包下载(FQ) 二、修改解压出来是这个样子 需要把里面的zip文件也解压并且放到同一目录 三、开始刷机最后利用adb进入bootfast模式重启并连接上手机 1adb reboot bootloader 直接运行flash-all.sh即可","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]}]}
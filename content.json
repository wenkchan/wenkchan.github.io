{"meta":{"title":"Wenk.Chan的个人博客","subtitle":null,"description":null,"author":"Wenk.Chan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"Java基础1.1 — Java八大基本数据类型及其包装类","date":"2019-03-23T05:36:43.063Z","updated":"2019-09-19T12:30:56.379Z","comments":true,"path":"2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","link":"","permalink":"http://yoursite.com/2019/03/23/Java基础1.1 — Java八大基本数据类型及其包装类/","excerpt":"","text":"Java基础1.1 — Java八大基本数据类型及其包装类一、Java的八大基本数据类型 序号 数据类型 大小/位 封装类 默认值 可表示数据范围 1 byte 8 java.lang.Byte 0 -128~127 2 short 16 java.lang.Short 0 -32768~32767 3 int 32 java.lang.Integer 0 -2147483648 ~ 2147483647 4 long 64 java.lang.Long 0L -9223372036854775808 ~ 9223372036854775807 5 float 32 java.lang.Float 0F 1.4E-45~3.4028235E38 6 double 64 java.lang.Double 0D 4.9E-324~1.7976931348623157E308 7 char 16 java.lang.Character 空 0~65535 8 boolean 8 java.lang.Boolean false true或false 无需记忆可表示范围，在JDK里面数据类型可承载的最大最小值已经在包装类里面用常量的形式表示出来了如:Integer.MAX_VALUE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//byteSystem.out.println(\"基本类型：byte二进制位数：\"+Byte.SIZE);System.out.println(\"包装类：java.lang.Byte\");System.out.println(\"最小值：Byte.MIN_VALUE=\"+Byte.MIN_VALUE);System.out.println(\"最大值：Byte.MAX_VALUE=\"+Byte.MAX_VALUE);System.out.println();//shortSystem.out.println(\"基本类型：short二进制位数：\"+Short.SIZE);System.out.println(\"包装类：java.lang.Short\");System.out.println(\"最小值：Short.MIN_VALUE=\"+Short.MIN_VALUE);System.out.println(\"最大值：Short.MAX_VALUE=\"+Short.MAX_VALUE);System.out.println();//intSystem.out.println(\"基本类型：int二进制位数：\"+Integer.SIZE);System.out.println(\"包装类：java.lang.Integer\");System.out.println(\"最小值：Integer.MIN_VALUE=\"+Integer.MIN_VALUE);System.out.println(\"最大值：Integer.MAX_VALUE=\"+Integer.MAX_VALUE);System.out.println();//longSystem.out.println(\"基本类型：long二进制位数：\"+Long.SIZE);System.out.println(\"包装类：java.lang.Long\");System.out.println(\"最小值：Long.MIN_VALUE=\"+Long.MIN_VALUE);System.out.println(\"最大值：Long.MAX_VALUE=\"+Long.MAX_VALUE);System.out.println();//floatSystem.out.println(\"基本类型：float二进制位数：\"+Float.SIZE);System.out.println(\"包装类：java.lang.Float\");System.out.println(\"最小值：Float.MIN_VALUE=\"+Float.MIN_VALUE);System.out.println(\"最大值：Float.MAX_VALUE=\"+Float.MAX_VALUE);System.out.println();//doubleSystem.out.println(\"基本类型：double二进制位数：\"+Double.SIZE);System.out.println(\"包装类：java.lang.Double\");System.out.println(\"最小值：Double.MIN_VALUE=\"+Double.MIN_VALUE);System.out.println(\"最大值：Double.MAX_VALUE=\"+Double.MAX_VALUE);System.out.println();//charSystem.out.println(\"基本类型：char二进制位数：\"+Character.SIZE);System.out.println(\"包装类：java.lang.Character\");//以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台System.out.println(\"最小值：Character.MIN_VALUE=\"+(int)Character.MIN_VALUE);//以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台System.out.println(\"最大值：Character.MAX_VALUE=\"+(int)Character.MAX_VALUE);&#125; 1、进一步分类 整型：byte、short、int、long 浮点型：float、double 逻辑型：boolean 字符型：char 2、基本数据类型的转换1byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 从左到右的数据类型转换都是隐式转换，无需强转。 从右到做的数据类型转换需要强转，并且会损失精度 二、包装类java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在栈中分配空间,存储数值,而包装类是对象，需要在堆内存中分配空间,栈中存放着对应的堆空间地址 1、自动拆箱和自动装箱在JDK1.5以后，提供了自动拆箱和自动装箱功能这样的”语法糖”,如12345//这是自动装箱Integer i = 1; //转换成了Integer i = Integer.valueOf(1);//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException 从字节码看出也是一样的 (通过idea搜索jclasslib bytecode viewer插件查看更方便，安装后在 View-&gt;Show Bytes Code With jclasslib)1234567 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 iconst_1 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 9 astore_210 return 同样地12345//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱Integer i = 1;int j = i;,//后面一句转换成了int j = i.intValue(); 下面是字节码12345678910 0 iconst_1 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 4 astore_1 5 aload_1 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt; 9 istore_210 aload_111 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;14 istore_315 return 由此也可以看出，自动拆装箱属于编译特性 2、包装类的valueOf方法的缓存池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Byte valueOf(byte b) &#123; final int offset = 128; return ByteCache.cache[(int)b + offset];&#125;public static Short valueOf(short s) &#123; final int offset = 128; int sAsInt = s; if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache return ShortCache.cache[sAsInt + offset]; &#125; return new Short(s);&#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l);&#125;public static Float valueOf(float f) &#123; return new Float(f);&#125;public static Double valueOf(double d) &#123; return new Double(d);&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125;public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); Byte都是用缓存池里面的值 Short、Integer、Long会缓存 -128~127 Float和Double则直接返回，因为精度数不能每次都一样，所以缓存没有意义 Character则是缓存 &lt;=127 Boolean,只有两个值，直接就用常量的形式表示出来了 三、一些需要注意的地方 double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是false,所以在进行带精度计算时，需要用到BigDecimal switch中只能用byte、char、short、int，JDK1.7后可用String Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型 两边都是包装类的equals比较值，== 比较引用，其中一边是表达式的，== 就是比较数值 四、一些题目1.下面语句做了什么12Integer i = 1; //valueOf()自动装箱成Integer类型i+=1;//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer 2.下面程序语句有什么问题12345678short s1 = 1;s1 = s1 + 1; //编译不通过、需要强转short s2 =1;s2 += 1; //正常编译Integer i = null;int j = i; //NullPointException 3.下面程序的运行结果是什么1234567891011Integer i1 = 128;Integer i2 = 128;System.out.println(i1 == i2); //false 比较了对象Integer i1 = 127;Integer i2 = 127;System.out.println(i1 == i2); //true 缓存了-128~127Float f1 = 1f;Float f2 = 1f;System.out.println(f1 == f2) //false 始终new新对象 https://blog.csdn.net/BuquTianya/article/details/80685437 char存储的是unicode编码字符，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示","categories":[],"tags":[]},{"title":"创建Hexo博客并部署到云主机","slug":"创建Hexo博客并部署到云主机","date":"2018-06-18T09:50:21.000Z","updated":"2018-06-18T10:15:23.312Z","comments":true,"path":"2018/06/18/创建Hexo博客并部署到云主机/","link":"","permalink":"http://yoursite.com/2018/06/18/创建Hexo博客并部署到云主机/","excerpt":"","text":"官方文档 一、云服务器配置(Ubuntu 16.04 LTS)安装git和nginx1apt-get install git-core nginx 配置Nginx创建目录用于存放静态文件 1mkdir /var/www/blog 创建一个Nginx配置文件 1vim /etc/nginx/conf.d/blog.conf 键入以下内容 12345server&#123;listen 8080;root /var/www/blog;&#125; 重启Nginx 1systemctl restart nginx 配置Git Hooks生成blog.git作为仓库，当本地Push过来时自动同步 12mkdir ~/blog.git &amp;&amp; cd ~/blog.gitgit init --bare 创建Hooks脚本，当blog.git收到Push时自动执行post-receive 1vim blog.git/hooks/post-receive 然后脚本里面做的操作就是自动clone 12sudo rm -rf /var/www/blogsudo git clone /root/blog.git /var/www/blog 最后再给个权限 1chmod +x blog.git/hooks/post-receive 二、本地相关配置(Mac OS)安装相关软件123brew install nodebrew install git 然后安装Hexo 1npm install -g hexo-cli 配置参数在自己想要的目录执行 1heox init . 目录如下 在目录下找到配置文件_config.yml并修改 123deploy:type: gitrepo: root@152.92.13.78:blog.git(例) 云服务器最好是使用SSH登录，那种比较方便，通过以下命令即可添加1ssh-add ~./ssh/id_dsa删除1ssh-add -d ./ssh/id_xxx.pub查看#1ssh-add -l 三、执行最后在本地生成静态文件后再进行部署即可 12hexo ghexo d 访问152.92.13.78:8080(例)即为博客站点","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[]},{"title":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","slug":"Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)","date":"2018-06-18T06:48:11.000Z","updated":"2018-06-18T07:23:36.837Z","comments":true,"path":"2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","link":"","permalink":"http://yoursite.com/2018/06/18/Android 谷歌亲儿子系列线刷官方出厂包(Nexus 6P为例)/","excerpt":"","text":"一、下载官方链接 官方出厂包下载(FQ) 二、修改解压出来是这个样子 需要把里面的zip文件也解压并且放到同一目录 然后修改flash-all.sh里面的内容，把目录下所有的img文件都包括进去，还有android-info,并删除最后一句解压zip的 三、开始刷机最后利用adb进入bootfast模式重启并连接上手机 1adb reboot bootloader 直接运行flash-all.sh即可","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"Android源码以及内核下载","slug":"Android源码下载","date":"2018-06-17T10:37:36.000Z","updated":"2018-06-18T09:41:35.026Z","comments":true,"path":"2018/06/17/Android源码下载/","link":"","permalink":"http://yoursite.com/2018/06/17/Android源码下载/","excerpt":"","text":"I am Source","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]}]}
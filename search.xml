<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2019/11/21/Java/Thread/2019-11-21/"/>
      <url>/2019/11/21/Java/Thread/2019-11-21/</url>
      <content type="html"><![CDATA[<p>新军事系列(801~830)<br>801 小飞机<br>802 挎斗摩托<br>803 小军车<br>804 侦察机<br>805 小坦克<br>806 追击<br>807 吹号兵<br>808 哨站<br>809 堵截军车<br>810 战斗机<br>811 载兵车<br>812 火箭炮<br>813 两栖车<br>814 装甲车<br>815 冲锋艇<br>816 潜艇<br>817 悍马<br>818 武装直升机<br>819 海兵炮营<br>820 护卫舰<br>821 导弹巡洋舰<br>822 导弹车<br>823 坦克<br>824 军官指挥车<br>825 指挥部<br>826 航母<br>827 老特务<br>828 炮兵<br>829 探雷兵<br>830 小战车</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/11/19/Java/Collections/2019-11-19/"/>
      <url>/2019/11/19/Java/Collections/2019-11-19/</url>
      <content type="html"><![CDATA[<h1 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/11/09/Algorithm/%E6%A0%91/"/>
      <url>/2019/11/09/Algorithm/%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>二叉树:每个节点最多包含两棵子树，分别为左子树和右子树</p><p>满二叉树</p><ul><li>国内定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。<pre><code>也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</code></pre></li><li>国外定义：满二叉树的结点要么是叶子结点，度为0，要么是度为2的结点，不存在度为1的结点。</li></ul><p>完全二叉树:从根结点开始，依次从左到右填充树结点</p><p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java集合(七) — Queue</title>
      <link href="/2019/11/08/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%83)%20%E2%80%94%20Queue/"/>
      <url>/2019/11/08/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%83)%20%E2%80%94%20Queue/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Queue一般用来存放<code>等待处理</code>元素，这种场景一般<code>用于缓冲、并发访问</code></p><p>下面是Queue的一些基本方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入（抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入（返回特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来看一下Java中的一些非并发Queue</p><h1 id="二、PriorityQueue"><a href="#二、PriorityQueue" class="headerlink" title="二、PriorityQueue"></a>二、PriorityQueue</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>PriorityQueue也叫做<code>优先级队列</code>，每次取出的元素都是队列中优先级最高的</p><p>下面是它的特性</p><ol><li>基于<code>优先级堆</code>实现的无界优先队列</li><li>元素自然排序，或者在构造方法传入实现的<code>Comparator</code>排序</li><li>不允许null元素</li><li>不允许不可比较的元素</li><li>非线程安全</li><li>迭代器的迭代顺序无法保证</li></ol><p>PriorityQueue是基于<code>堆</code>实现的，而堆是用<code>完全二叉树</code>处理数据的</p><blockquote><p>完全二叉树:若二叉树的深度是h，那么除第h层外，其他各层（1～h-1）层的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树</p></blockquote><p>堆也分为<code>最大堆</code>和<code>最小堆</code></p><blockquote><p>最大堆:根节点是所有节点中最大的元素,而且每个节点的值都比子节点大<br>最小堆:根节点是所有节点中最小的元素,而且每个节点的值都比子节点小</p></blockquote><p>而PriorityQueue默认是基于<code>最小堆</code>实现的,而且底层通过<code>数组</code>来构建数据结构</p><h2 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用数组来构造堆，也就是优先级队列</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">    <span class="comment">// 数组默认的初始化容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">// 队列的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 结构化修改次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组最大容量限制，Integer最大值-8是说一些虚拟机可能会在数组中保留一些header words的空间，</span></span><br><span class="line">    <span class="comment">// 所以没有取Integer最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue是继承自AbstractQueue,AbstractQueue实现了Queue接口，封装了一些队列基础的方法。</p><p>注释里面有写到父节点和子节点下标值之间的关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childLeftNode= <span class="number">2</span> * parentNode + <span class="number">1</span>; </span><br><span class="line">childRightNode= <span class="number">2</span> * (parentNode + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h2 id="4、构造方法"><a href="#4、构造方法" class="headerlink" title="4、构造方法"></a>4、构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法，初始化容量为11，比较器为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定具体容量的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量和比较器的构造方法，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将集合转换为队列，根据集合类型不同，又分为三种情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、重点方法"><a href="#5、重点方法" class="headerlink" title="5、重点方法"></a>5、重点方法</h2><p>add方法内部都是通过offer来实现的</p><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//2.结构化修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">//3.判断是否扩容</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//4.首个元素直接添加</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//5.不是首个元素则上浮</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容grow"><a href="#扩容grow" class="headerlink" title="扩容grow"></a>扩容grow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 如果容量小于64，则翻倍，大于则增加原来的一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据是否有比较器选用对应的处理方法,处理方法类似</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 1.通过无符号右移，计算并获取父级结点下标，</span></span><br><span class="line">         <span class="comment">//  -&gt; parent = (thisNode -1) / 2</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">         <span class="comment">// 2.如果入参大于父节点，则不需要移动，结束</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 3.小于父节点,则父节点下沉</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        <span class="comment">// 4.改变下标</span></span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.把当前节点值放到对应位置上</span></span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队peek和poll"><a href="#出队peek和poll" class="headerlink" title="出队peek和poll"></a>出队peek和poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出堆中最小值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 1.取堆中最小值</span></span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 2.取数组中最后一个元素的值</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    <span class="comment">// 3.将堆中最后一个值设置为null</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 4.如果数组不是只有一个元素，执行下沉操作</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 下沉操作</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="comment">// 计算非叶子结点元素的最大位置，循环的终止条件（在最后一个非叶子节点处结束）</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 计算k位置处的左子结点</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="comment">// 右子结点等于左子结点下标加1</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取左右孩子中值较小的值 </span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 然后重新和父结点进行比较，如果大于父结点，不需要移动，结束</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父结点下移</span></span><br><span class="line">        queue[k] = c;</span><br><span class="line">        <span class="comment">// 改变下标，循环此操作</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取元素的下标    </span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行移除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="comment">// 如果要移除的就是最后一个元素，赋值为null</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取队列尾元素</span></span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        <span class="comment">// 将队尾元素置为null</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 下沉操作</span></span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="comment">// 如果下移后元素位置没发生变化，说明moved的左右子结点都大于moved，这时就需要上浮操作</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">            <span class="comment">// 上浮操作</span></span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="comment">// 如果上浮之后发生了元素位置</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、-ArrayDeque"><a href="#三、-ArrayDeque" class="headerlink" title="三、 ArrayDeque"></a>三、 ArrayDeque</h2><p>另外，<code>Deque</code>是双端队列，在Queue的基础上增加了针对双端添加和删除元素的方法<br>实现了ArrayDeque的非并发集合有<code>ArrayDeque</code>,还有LinkedArrayList<br>下面是Deque的一些基本方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//从头部插入（抛异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//从尾部插入（抛异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//从头部插入（特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//从尾部插入（特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//从头部移除（抛异常）</span></span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从尾部移除（抛异常）</span></span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从头部移除（特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从尾部移除（特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从头部查询（抛异常）</span></span><br><span class="line">    <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从尾部查询（抛异常）</span></span><br><span class="line">    <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从头部查询（特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//从尾部查询（特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//（从头到尾遍历列表时，移除列表中第一次出现的指定元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//（从头到尾遍历列表时，移除列表中最后一次出现的指定元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayDeque比较值得关注的可能就是构造方法分配容量<br>因为ArrayDeque需要满足容量是<code>2^n</code>，所以就有了以下算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">    <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>2^n</code>不管n是多少，转换为二进制的话，所有位都是1，然后+1，<br>所以，这个算法是把传入参数的所有位都置为1，然后再加1</p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(六) — Set</title>
      <link href="/2019/11/08/Java/Collections/Java%E9%9B%86%E5%90%88(%E5%85%AD)%20%E2%80%94%20Set/"/>
      <url>/2019/11/08/Java/Collections/Java%E9%9B%86%E5%90%88(%E5%85%AD)%20%E2%80%94%20Set/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Set是由<code>无重复对象</code>组成的集合,标准是</p><ol><li>不能有两个引用指向同一个对象</li><li>不能有两个引用指向null</li><li>使用<code>equals</code>方法比较两个对象不相等</li></ol><p>Set的实现通常都是基于<code>Map</code>的，因为Map的<code>key</code>是唯一的，<code>value</code>没有用到，只需要占位即可。</p><h1 id="二、HashSet"><a href="#二、HashSet" class="headerlink" title="二、HashSet"></a>二、HashSet</h1><p>HashSet是<code>基于HashMap</code>实现的，所以也具有HashMap的特性</p><ol><li>允许使用null</li><li>不保证顺序</li><li>非同步</li></ol><h2 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">       map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过构造方法，一下子就知道，HashSet就是通过HashMap来实现的</p><h2 id="2、API操作"><a href="#2、API操作" class="headerlink" title="2、API操作"></a>2、API操作</h2><p>HashSet的操作方法基本都是通过HashMap来实现的<br>值是存放在HashMap的key上，<code>value</code>是<code>PRESENT</code>的固定值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、LinkedHashSet"><a href="#四、LinkedHashSet" class="headerlink" title="四、LinkedHashSet"></a>四、LinkedHashSet</h1><p>LinkedHashSet是继承于HashSet的，而且在HashSet里面有一个专门提供给<code>LinkedHashSet</code>的构造方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以LinkedHashSet是基于LinkedHashMap的，所以也拥有LinkedHashMap的特性，可以保证有序</p><p>下面是LinkedHashSet的内容，其实也只有构造方法，使用的都是父类HashSet的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、TreeSet"><a href="#五、TreeSet" class="headerlink" title="五、TreeSet"></a>五、TreeSet</h1>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(九) — 其他</title>
      <link href="/2019/11/07/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B9%9D)%20%E2%80%94%20%E5%85%B6%E4%BB%96/"/>
      <url>/2019/11/07/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B9%9D)%20%E2%80%94%20%E5%85%B6%E4%BB%96/</url>
      <content type="html"><![CDATA[<h1 id="一、-与equals"><a href="#一、-与equals" class="headerlink" title="一、==与equals"></a>一、==与equals</h1><p><code>==</code>:基础数据类型比较的是<code>值</code>，引用比较的是内存地址，即两个对象是否同一个<br><code>equals</code>:默认情况下，equals的作用与<code>==</code>一样是比较对象。<br>有些类会将equals方法重写，如<code>String</code>重写比较的是对象的值</p><h1 id="二、equals与hashCode"><a href="#二、equals与hashCode" class="headerlink" title="二、equals与hashCode"></a>二、equals与hashCode</h1><p><code>hashCode</code>方法定义在Object.java中，说明任何一个Java类都有<code>hashCode</code>方法<br>hashCode的作用是获取哈希码,特点是能够根据”key”迅速获取对应的”value”,而且hashCode相等的两个对象不一定相等(碰撞)，所以比较两个对象是否相等时</p><ol><li>先判断hashCode是否存在相同的</li><li>发现了相同hashCode的对象才会时候equals去判断</li></ol><p>这样会大大减少equals使用的频率，提高执行速度</p><h1 id="三、类内元素加载顺序"><a href="#三、类内元素加载顺序" class="headerlink" title="三、类内元素加载顺序"></a>三、类内元素加载顺序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个构造代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    Block(String who) &#123;</span><br><span class="line">        System.out.println(who+<span class="string">" new"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义一个父类    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Block staticblock = <span class="keyword">new</span> Block(<span class="string">"father static"</span>);</span><br><span class="line">    Block block = <span class="keyword">new</span> Block(<span class="string">"father"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"father static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"father block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(<span class="string">"father  constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Block staticblock = <span class="keyword">new</span> Block(<span class="string">"son static"</span>);</span><br><span class="line">     Block block = <span class="keyword">new</span> Block(<span class="string">"son"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"son block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        System.out.println(<span class="string">"son constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">father <span class="keyword">static</span> <span class="keyword">new</span></span><br><span class="line">father <span class="keyword">static</span> block</span><br><span class="line">son <span class="keyword">static</span> <span class="keyword">new</span></span><br><span class="line">son <span class="keyword">static</span> block</span><br><span class="line">father <span class="keyword">new</span></span><br><span class="line">father block</span><br><span class="line">father constructor</span><br><span class="line">son <span class="keyword">new</span></span><br><span class="line">son block</span><br><span class="line">son constructor</span><br></pre></td></tr></table></figure></p><p>可以看出加载顺序是</p><ol><li>父类静态成员变量</li><li>父类静态代码块</li><li>子类静态成员变量</li><li>子类静态代码块</li><li>父类非静态成员变量</li><li>父类非静态代码块</li><li>父类构造方法</li><li>子类非静态成员变量</li><li>子类非静态代码块</li><li>子类构造方法</li></ol><p>由此也可以得知<br>执行子类构造方法之前，如果没有用 <code>super()</code> 来调用父类<code>特定的构造方</code>法，则会调用父类中<code>没有参数的构造方法</code>。因此，如果父类中只定义了<code>有参数的构造方法</code>，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误</p><h1 id="四、引用类型"><a href="#四、引用类型" class="headerlink" title="四、引用类型"></a>四、引用类型</h1><p>在Java中，Java.lang.ref是Java类库中比较特殊的一个包，它提供了与Java垃圾回收器密切相关的引用类，分别有以下四种</p><table><thead><tr><th>引用类型</th><th>取得对象的方式</th><th>垃圾回收条件</th><th>是否可能内存泄露</th></tr></thead><tbody><tr><td>强引用</td><td>调用new</td><td>不回收</td><td>可能</td></tr><tr><td>软引用</td><td>通过get()方法</td><td>内存低时回收</td><td>不可能</td></tr><tr><td>弱引用</td><td>通过get()方法</td><td>下一次GC</td><td>不可能</td></tr><tr><td>虚引用</td><td>无法获得</td><td>不回收</td><td>可能</td></tr></tbody></table><h2 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h2><p>如果一个对象具有强引用，那么垃圾回收器绝对不会回收他，即时抛出异常</p><h2 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h2><p>如果一个对象具有软引用，内存足够的不会被回收，内存不足时就会被回收，可以用于实现内存敏感的高速缓存<br>软引用可以与引用队列(ReferenceQueue)联合使用，如果软引用被回收了，就会被加入这个队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h2 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h2><p>弱引用，一旦被发现一定会回收。但是垃圾回收器线程优先级比较低，不一样会马上发现<br>弱引用也可以与引用队列(ReferenceQueue)联合使用，如果弱引用被回收了，就会被加入这个队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">WeakReference&lt;String[]&gt; softBean = <span class="keyword">new</span> WeakReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h2 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h2><p>“虚引用”顾名思义，就是形同虚设。那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用<code>必须</code>和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">PhantomReference&lt;String[]&gt; referent = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h1 id="五、克隆"><a href="#五、克隆" class="headerlink" title="五、克隆"></a>五、克隆</h1><p>为了快速构造一个和原有对象相同的副本，不比手动进行复制，所以就有了克隆这个操作<br>克隆涉及到的方法就是<code>Obejct的clone</code>方法,任何克隆的过程都得经过这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>克隆分为<code>浅克隆</code>和<code>深克隆</code>,下面定义两个类来做一下实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String course;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, String course)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.course = course;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、浅克隆"><a href="#1、浅克隆" class="headerlink" title="1、浅克隆"></a>1、浅克隆</h2><p>浅克隆的效果是复制出来的对象的<code>所有变量与原来对象相同</code>,而所有的对其他对象的引用仍然指向原对象<br><img src="/media/15730947779220.jpg" alt="-w500"></p><p>克隆对象实现一下<code>Cloneable</code>接口，并且在克隆的方法里面调用<code>super.clone()</code>就会返回克隆后的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span>  </span>&#123;</span><br><span class="line">      Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"王老师"</span>, <span class="string">"英语"</span>);</span><br><span class="line">      Student student = <span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">11</span>, teacher);</span><br><span class="line"></span><br><span class="line">      Student clone = student.clone();</span><br><span class="line">      clone.setName(<span class="string">"小强"</span>);</span><br><span class="line">      clone.setAge(<span class="number">20</span>);</span><br><span class="line">      clone.getTeacher().setName(<span class="string">"李老师"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(student.getName() + <span class="string">" "</span> + student.getAge());</span><br><span class="line">      System.out.println(clone.getName() + <span class="string">" "</span> + clone.getAge());</span><br><span class="line">      System.out.println(clone.getTeacher() == student.getTeacher());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后输出结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明 <span class="number">11</span></span><br><span class="line">小强 <span class="number">20</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>由上面的结果可知道，克隆出来的对象name和age都是新的，而对象引用teacher还是原来的</p><h2 id="2、普通深克隆"><a href="#2、普通深克隆" class="headerlink" title="2、普通深克隆"></a>2、普通深克隆</h2><p>深克隆的效果是，克隆出来所有变量都含有与原来对象相同的值，而引用指向的对象也是新创建的。</p><p>如果要实现深克隆，克隆对象里面的对象类型也<code>必须</code>要实现Cloneable接口并调用clone()<br>对Teacher类进行修改<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String course;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, String course)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.course = course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Teacher <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Teacher clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = (Teacher) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"王老师"</span>, <span class="string">"英语"</span>);</span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">11</span>, teacher);</span><br><span class="line"></span><br><span class="line">Student clone = student.clone();</span><br><span class="line">clone.setName(<span class="string">"小强"</span>);</span><br><span class="line">clone.setAge(<span class="number">20</span>);</span><br><span class="line">clone.getTeacher().setName(<span class="string">"李老师"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(student.getName() + <span class="string">" "</span> + student.getAge());</span><br><span class="line">System.out.println(clone.getName() + <span class="string">" "</span> + clone.getAge());</span><br><span class="line">System.out.println(clone.getTeacher() == student.getTeacher());</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明 <span class="number">11</span></span><br><span class="line">小强 <span class="number">20</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>从输出结果就可以得知，两个对象的Teacher已经不是同一个了，但是，如果克隆的对象存在比较长的继承链，实现深克隆就必须每一层去实现Cloneable方法。但是有一个简便的方法，序列化克隆</p><h2 id="3、serializable深克隆"><a href="#3、serializable深克隆" class="headerlink" title="3、serializable深克隆"></a>3、serializable深克隆</h2><p>把对象序列化写进一个流里面，再读取出来，就是一个新的对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span>  <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, Teacher teacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">serializableClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Student clone;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">        oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line">        ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">        clone = (Student) oi.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(十一) — 线程池</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%80)%20%E2%80%94%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81%E4%B8%80)%20%E2%80%94%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>当提交一个任务到线程池后，线程池处理任务的顺序</p><ol><li>判断<code>核心线程池</code>是否都在执行任务。如果不是则新建一个执行任务，如果进入下一个判断</li><li>判断<code>工作队列</code>是否已满，如果未满，则加入工作队列，如果已满，进入下一个判断</li><li>判断<code>线程池的线程</code>是否都处于工作状态，如果不是，新建一个线程来执行任务，如果满了，执行<code>饱和策略</code></li></ol><p>如何合理选择线程池的参数</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(十) — 并发工具类</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81)%20%E2%80%94%20%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%8D%81)%20%E2%80%94%20%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、CountDownLatch"><a href="#一、CountDownLatch" class="headerlink" title="一、CountDownLatch"></a>一、CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作再执行。<br>内部有一个通过共享锁实现的计数器<br>初始化时需要传入一个int值作为计数器的初始值，也可以理解为共享锁的获取次数</p><p>当某个线程调用await()方法，程序首先判断count的值是否为0，如果不会0的话则会一直等待直到为0为止。</p><p>当其他线程调用countDown()方法时，则执行释放共享锁状态，使count值 - 1。</p><p>当在创建CountDownLatch时初始化的count参数，必须要有count线程调用countDown方法才会使计数器count等于0，锁才会释放，前面等待的线程才会继续运行。注意CountDownLatch不能回滚重置。</p><h1 id="二、CyclicBarrier"><a href="#二、CyclicBarrier" class="headerlink" title="二、CyclicBarrier"></a>二、CyclicBarrier</h1><p>它要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量</p><p>每个线程调用await方法告诉CyclicBarrier我已经到达了屏障    </p><p>可以应用于合并计算结果的场景</p><p>不同CountDownLatch的是，CyclicBarrier可以对计数器进行reset</p><h1 id="三、Semaphore"><a href="#三、Semaphore" class="headerlink" title="三、Semaphore"></a>三、Semaphore</h1><p>Semaphore(信号量)是用来控制同时访问特定资源的线程数量</p><h1 id="四、Exchanger"><a href="#四、Exchanger" class="headerlink" title="四、Exchanger"></a>四、Exchanger</h1><p>Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(九) — 原子操作</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B9%9D)%20%E2%80%94%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B9%9D)%20%E2%80%94%20%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Java从JDK1.5开始提供了除synchronized以外的方法来保证原子性，<code>java.util.concurrent.atomic</code>包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。Atomic包里一共提供了13个类，属于4种类型的原子更新方式</p><ol><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新属性<br>Atomic包里的类基本都是使用<code>Unsafe</code>实现的包装类</li></ol><h1 id="二、原子更新基本类型类"><a href="#二、原子更新基本类型类" class="headerlink" title="二、原子更新基本类型类"></a>二、原子更新基本类型类</h1><ul><li>AtomicBoolean:原子更新布尔类型。</li><li>AtomicInteger:原子更新整型。</li><li>AtomicLong:原子更新长整型。</li></ul><p>以上3个类提供的方法几乎一模一样,以<code>AtomicInteger</code>为例</p><ul><li>int addAndGet(int delta):以原子方式将输入的数值与实例中的值(AtomicInteger里的 value)相加，并返回结果。</li><li>boolean compareAndSet(int expect，int update):如果输入的数值等于预期值，则以原子方式将该值设为输入的值。</li><li>int getAndIncrement():以原子方式将当前值加1，注意，这里返回的是<code>自增前</code>的值。</li><li>void lazySet(int newValue):最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li><li>int getAndSet(int newValue):以原子方式设置为newValue的值，并返回旧值。</li></ul><p>除了以上之外的基本类型，char、float和double等，可以参照<code>AtomicBoolean</code>的方式进行原子操作<br>因为Unsafe类关于基本类型的只有这三个方法，AtomicBoolean是先转换成整形再进行操作的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AtomicBoolean的compareAndSet方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="三、原子更新数组"><a href="#三、原子更新数组" class="headerlink" title="三、原子更新数组"></a>三、原子更新数组</h1><ul><li>AtomicIntegerArray:原子更新整型数组里的元素。</li><li>AtomicLongArray:原子更新长整型数组里的元素。</li><li>AtomicReferenceArray:原子更新引用类型数组里的元素。</li></ul><p>以<code>AtomicIntegerArray</code>为例，方法也是类似与基本数据类型，对应操作对象换成对象索引罢了</p><h1 id="四、原子更新引用类型"><a href="#四、原子更新引用类型" class="headerlink" title="四、原子更新引用类型"></a>四、原子更新引用类型</h1><ul><li>AtomicReference:原子更新引用类型。 </li><li>AtomicReferenceFieldUpdater:原子更新引用类型里的字段。</li><li>AtomicMarkableReference:原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef，boolean initialMark)。</li></ul><h1 id="五、原子更新字段类"><a href="#五、原子更新字段类" class="headerlink" title="五、原子更新字段类"></a>五、原子更新字段类</h1><ul><li>AtomicIntegerFieldUpdater:原子更新整型的字段的更新器。 </li><li>AtomicLongFieldUpdater:原子更新长整型字段的更新器。</li><li>AtomicStampedReference:原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</li></ul>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(八) — 并发容器</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AB)%20%E2%80%94%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AB)%20%E2%80%94%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="一、CopyOnWriteArrayList"><a href="#一、CopyOnWriteArrayList" class="headerlink" title="一、CopyOnWriteArrayList"></a>一、CopyOnWriteArrayList</h1><p>一般来说，CopyOnWriteArrayList是ArrayList的线程安全版本,适合读多写少的并发场景</p><p>在添加或者修改时，会复制出一个数组来完成操作，然后再将引用指向新数组，过程中用重入锁。<br>如果增删改比较多，会占用很多内存</p><p>get或者遍历时，不加锁。读取的是旧的数据，因此只有数据只有最终一致性，没有实时一致性</p><h1 id="二、CopyOnWriteArraySet"><a href="#二、CopyOnWriteArraySet" class="headerlink" title="二、CopyOnWriteArraySet"></a>二、CopyOnWriteArraySet</h1><p>CopyOnWriteArraySet内部容器是CopyOnWriteArrayList，在加入容器时，进行了addIfAbsent的判断，防止加入相同元素</p><h1 id="三、ConcurrentSkipListMap"><a href="#三、ConcurrentSkipListMap" class="headerlink" title="三、ConcurrentSkipListMap"></a>三、ConcurrentSkipListMap</h1><p>ConcurrentSkipListMap一般来说是TreeMap的线程安全版本，内部通过链表的<code>跳表</code>和<code>CAS</code>来实现的</p><blockquote><p>##跳表<br>跳表是一种使用”空间换时间”的概念用来提高查询效率的链表<br><img src="/media/15743077510829.jpg" alt=""><br>特性:<br>1.由很多层组成，level越搞的层级点越少<br>2.每一层的节点数据也都是有顺序的<br>3.上面层的节点肯定会在下面层出现<br>4.每一个节点都有两个指针，分别是同一层的下一个节点和下一层节点的指针</p><p>查询元素的时候从最上层开始找，根据比较逐渐往下缩小范围</p><p>新增元素会先确定Level层，在当前level和以下的level都加入新的元素<br>而层数是通过一种随机算法获取的,如果Level大于跳表的层数,那么会新增一层</p></blockquote><h1 id="四、ConcurrentSkipListSet"><a href="#四、ConcurrentSkipListSet" class="headerlink" title="四、ConcurrentSkipListSet"></a>四、ConcurrentSkipListSet</h1><p>ConcurrentSkipListSet内部是基于ConcurrentSkipListMap实现的，在加入容器时，进行了putIfAbsent的判断，防止加入相同元素</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(七) — Queue</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%83)%20%E2%80%94%20Queue/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%83)%20%E2%80%94%20Queue/</url>
      <content type="html"><![CDATA[<h1 id="一、ConcurrentLinkedQueue"><a href="#一、ConcurrentLinkedQueue" class="headerlink" title="一、ConcurrentLinkedQueue"></a>一、ConcurrentLinkedQueue</h1><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程队列，使用FIFO规则对节点进行排序，采用了CAS算法进行实现出队入队，判空时要使用<code>isEmpty</code></p><h1 id="二、BlockingQueue"><a href="#二、BlockingQueue" class="headerlink" title="二、BlockingQueue"></a>二、BlockingQueue</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>阻塞队列是在一个支持两个附加操作的队列</p><ul><li>当队列满时，队列会阻塞插入元素的线程，直到不满</li><li>当队列空时，获取元素的线程会等待队列变为非空</li></ul><h2 id="2、JDK提供的阻塞队列"><a href="#2、JDK提供的阻塞队列" class="headerlink" title="2、JDK提供的阻塞队列"></a>2、JDK提供的阻塞队列</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>由<code>数组</code>组成的<code>有界</code>阻塞队列,内部使用<code>ReentrantLock</code>实现了公平、非公平锁,默认是不公平<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>用<code>链表</code>实现的<code>有界</code>阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>支持<code>优先级</code>的<code>无界</code>阻塞队列。默认情况下元素采取自然顺序升序排列。可以通过Comparator进行自定义，不保证同等级的元素的优先级<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>支持延时获取元素的<code>无界</code>阻塞队列,使用<code>PriorityQueue</code>实现，队列中的元素必须实现Delayed接口，应用场景</p><ul><li>缓存系统:保存缓存元素的有效期，线程循环查询，一旦能从中获取元素，表示缓存过期</li><li>定时任务调度:保存当天将会执行的任务和执行时间，一旦从中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p><code>不存储元素</code>的阻塞队列,每一个put操作必须等待一个take操作,否则不能继续添加元素,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>支持公平访问，适合传递性场景，吞吐量高</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>由<code>链表</code>结构组成的<code>无界</code>阻塞队列,与其他阻塞队列相比，多了tryTransfer和transfer方法</p><ul><li>transfer<br>如果有正在等待的消费者，可以通过transfer马上传递给消费者，没有则放到队尾</li><li>tryTransfer<br>尝试是否直接传给消费者，如果没有则返回false<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3>由<code>链表</code>结构组成的双向阻塞队列,可以从队列的两端插入和移出元素,而且可以运用在<code>工作窃取模式</code>中</li></ul><blockquote><p>####工作窃取算法<br>把一个大任务分割(fork)成<code>互不依赖</code>的小任务，减少线程间的竞争，<br>然后把子任务放到不同的队列中，每个队列创建一个线程去执行任务<br>有的线程把自己的任务执行完毕，回去别的队列<code>窃取</code>任务进行执行<br>因为访问同一个队列，为了减少线程竞争，会使用<code>双端队列</code>，一头窃取，一头正常运行<br>都完成之后合并结果(join)</p></blockquote><p>对于这种模式，JDK中提供了<code>Fork/Join框架</code>的实现</p><ol><li>ForkJoinTask<br>使用Fork/Join框架，必须首先创建一个ForkJoin任务,一般会使用继承于ForkJoinTask的两个子类</li></ol><ul><li>RecursiveAction:用于没有返回结果的任务。 </li><li>RecursiveTask:用于有返回结果的任务。</li></ul><ol start="2"><li>ForkJoinPool<br>ForkJoinTask需要通过ForkJoinPool来执行,内部维护了一个双端队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;  <span class="comment">// 阈值   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为无法在主线程抛出异常，内部提供了<code>isCompletedAbnormally</code>方法来判断是否抛出了异常获取任务已取消</p><h2 id="3、实现原理"><a href="#3、实现原理" class="headerlink" title="3、实现原理"></a>3、实现原理</h2><p>比如使用Condition，队列满了生产者会停止生产并且阻塞(<code>LockSupport.park(this)</code>)，这时消费者如果消费了队列中的元素，就会<code>通知</code>生产者队列可以用,继续生产</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(六) — ConcurrentHashMap</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AD)%20%E2%80%94%20ConcurrentHashMap/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AD)%20%E2%80%94%20ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>ConcurrentHashMap是一个线程安全的K-V集合。因为HashMap不是线程安全还有HashTable效率过低出现的.</p><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="1、JDK1-7"><a href="#1、JDK1-7" class="headerlink" title="1、JDK1.7"></a>1、JDK1.7</h2><h3 id="内部基本结构"><a href="#内部基本结构" class="headerlink" title="内部基本结构"></a>内部基本结构</h3><p>ConcurrentHashMap JDK 1.7是由<code>Segment数组结构</code>和<code>HashEntry数组结构</code>组成,采取<code>分段锁</code>的方式实现线程安全<br><code>Segment</code>继承于<code>ReentrantLock</code>，扮演锁的角色</p><p>一个<code>Segment</code>对应一个<code>HashEntry数组</code>,每个<code>HashEntry</code>都是一个<code>链表</code><br><img src="/media/15741534481813.jpg" alt=""></p><h3 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于根据给定的key的hash值定位到一个Segment</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于根据给定的key的hash值定位到一个Segment</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashEntry[]初始容量：决定了HashEntry数组的初始容量和初始阀值大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment对象下HashEntry[]的初始加载因子：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment对象下HashEntry[]最大容量：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment[]初始并发等级：决定了Segment[]的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小Segment[]容量：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大Segement[]容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment[]</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>其中<br><code>DEFAULT_INITIAL_CAPACITY、DEFAULT_LOAD_FACTOR、MAXIMUM_CAPACITY</code>与<code>HashEntry[]</code>的构建有关。</p><p><code>DEFAULT_CONCURRENCY_LEVEL、MIN_SEGMENT_TABLE_CAPACITY、MAX_SEGMENTS</code>与<code>Segment[]</code>的构建有关。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//限制不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//并发等级不能大于segment[]长度</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录按位左移次数</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录segment数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<span class="comment">//对ssize进行二次方处理，服务hash算法</span></span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>; <span class="comment">//左移一位就是乘以2,</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//segmentShift、segmentMask用于元素在Segment[]数组的定位</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始容量不能大于HashEntry最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//c影响了每个Segment[]上要放置多少个HashEntry;</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//创建第一个segment对象，并创建该对象下HashEntry[]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    <span class="comment">//创建Segment[]，指定segment数组的长度</span></span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">//使用CAS方式，将上面创建的segment对象放入segment[]数组中;</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="comment">//对ConcurrentHashMap中的segment数组赋值</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据hash值定位Segment[]的index</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//使用CAS方式，从Segment[]中获取index所在的segment对象</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">         <span class="comment">//index处没有元素，则新建一个</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">//调用segment的put方法</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">            scanAndLockForPut(key, hash, value);</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取Segment中的HashEntry数组</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            <span class="comment">//根据index获取HashEntry对象</span></span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    K k;</span><br><span class="line">                    <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        oldValue = e.value;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                            e.value = value;</span><br><span class="line">                            ++modCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                        node.setNext(first);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                    <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                        <span class="comment">//对HashEntry进行扩容</span></span><br><span class="line">                        rehash(node);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    count = c;</span><br><span class="line">                    oldValue = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">//使用volatile的方式保持可见性进行get</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//尝试计算三次之后，才进行加锁运算</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前面三次前后计算如果相等，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="内部基本结构-1"><a href="#内部基本结构-1" class="headerlink" title="内部基本结构"></a>内部基本结构</h3><p>ConcurrentHashMap JDK1.8采用<code>Node+CAS+Synchronized</code>来保证并发安全进行实现<br>底层采用<code>数组+链表+红黑树</code>的存储结构<br><img src="/media/15742119499516.jpg" alt=""><br>下面是主要的一些成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幕数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> *当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> *当为0时：代表当时的table还没有被初始化</span></span><br><span class="line"><span class="comment"> *当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">private transient volatile int sizeCtl;</span></span><br></pre></td></tr></table></figure></p><p><code>Node</code>是ConcurrentHashMap存储结构的基本单元,实际上是一个<code>链表</code>，只允许查询，不允许修改set<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TreeNode</code>是为了实现红黑树而创建的类，与HashMap类似,当链表的节点数<code>大于8</code>时会转换成红黑树的结构，过TreeNode作为存储结构代替Node来转换成黑红树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">     * starting at given root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一个类<code>TreeBin</code>,用于存储TreeNode，和对TreeNode进行操作</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap函数的构造方法为空，初始化操作没有在这里实现，而是在put实现</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">//两次hash，减少hash冲突，可以均匀分布</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//对这个table进行迭代</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//如果i位置没有数据，就直接无锁插入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//如果在进行扩容，则先进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//表示该节点是链表结构</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;  <span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树结构</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//红黑树结构旋转插入</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//如果链表的长度大于8时就会进行红黑树的转换</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);<span class="comment">//统计size，并且检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h = spread(key.hashCode()); //计算两次hash</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;//读取首节点的Node元素</span><br><span class="line">        if ((eh = e.hash) == h) &#123; //如果该节点就是首节点就返回</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span><br><span class="line">        //查找，查找到就返回</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        while ((e = e.next) != null) &#123;//既不是首节点也不是ForwardingNode，那就往下遍历</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a; <span class="comment">//变化的数量</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.8版本中，对于size的计算，在扩容和addCount()方法就已经有处理了</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(五) — Lock</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E2%80%94%20Lock/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E2%80%94%20Lock/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Lock是用来控制多个线程访问共享资源的方式，于synchronized的功能类似，但是在Lock的<code>获取，释放，超时和可中断</code>的功能上具有更加灵活的可操作性。比如以下的一些特定</p><ul><li>尝试非阻塞获取锁</li><li>能被中断地获取锁</li><li>超时获取锁</li></ul><p>Lock是一个接口,定义了锁获取和释放的一些基本操作<br><img src="/media/15740434164198.jpg" alt="-w290"></p><ul><li>lock():获取锁，调用该方法当前线程将会获得锁，获得锁之后，从该方法返回</li><li>lockInterruptible():中断地获取锁，即在锁获取中可以中断当前线程</li><li>tryLock():尝试非堵塞获取锁,获取到则返回ture，否则返回false</li><li>tryLock(long,TimeUnit):超时获取锁</li><li>unLock():释放锁</li><li>newCondition():获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait()方法，调用后，当前线程将释放锁</li></ul><h1 id="二、AQS"><a href="#二、AQS" class="headerlink" title="二、AQS"></a>二、AQS</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>AQS全称<code>AbstractQueuedSynchronizer</code>(队列同步器),用于构建锁或者其他同步组件的基础框架</p><p>AQS内部维护了一个<code>(FIFO的双向队列)</code>同步队列来完成同步状态的管理<br>当前线程获取同步状态失败时，同步器会将当前线程和等待状态等信息构造成一个<code>节点(Node)</code>,加入同步队列。<br>同时<code>阻塞</code>当前线程，当同步状态释放时，会把<code>首节点</code>中的线程唤醒，使其<code>再次尝试获取</code>同步状态。<br>首节点获取成功后，会继续唤醒<code>后继节点</code>尝试获取同步状态</p><h3 id="Node的信息"><a href="#Node的信息" class="headerlink" title="Node的信息"></a>Node的信息</h3><table><thead><tr><th>属性类型和名称</th><th>描述</th></tr></thead><tbody><tr><td>int waitStatus</td><td>等待状态 <br> CANCELLED 1 取消等待 <br> SIGNAL -1 当前节点线程释放同步状或取消后,通知后继节点 <br> CONDITION -2 等待在Condition中 <br> PROPAGATE -3 下一次共享式同步状态获取将无条件地传播下去 <br> INITIAL 0 初始状态</td></tr><tr><td>Node pre</td><td>前驱节点，尾插</td></tr><tr><td>Node next</td><td>后继节点</td></tr><tr><td>Node nextWaiter</td><td>等待队列中的后继节点</td></tr><tr><td>thread Thread</td><td>获取同步状态的线程</td></tr></tbody></table><h3 id="可重写方法"><a href="#可重写方法" class="headerlink" title="可重写方法"></a>可重写方法</h3><p>AQS是一个抽象类，支持独占式和共享式地获取状态。抽象类中支持重写的方法有</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>protected boolean tryAcquire(int arg)</td><td>独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后用CAS设置同步状态</td></tr><tr><td>protected boolean tryRelease(int arg)</td><td>独占式释放同步状态,等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td>protected int tryAcquireShared(int arg)</td><td>共享式获取同步状态,返回大于等于0的值,表示获取成功，反之，获取失败</td></tr><tr><td>protected boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td></tr><tr><td>protected boolean isHeldExclusively()</td><td>当前同步器是否在独占模式下被线程占用,一般该方法表示是否被当前线程独占</td></tr></tbody></table><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>AQS简化了锁的实现方式，屏蔽了<code>同步状态管理，线程排队，等待和唤醒</code>这些底层操作,并提供了一些模板方法</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，如果当前线程获取状态成功，则返回。否则，进入同步队列等待，该方法会调用重写的tryAcquire(int arg)</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>与acquire(int arg)相同,多了响应中断</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>在acquireInterruptibly(int arg)基础上加了超时限制，</td></tr><tr><td>void acquireShared(int arg)</td><td>共享式的获取同步状态</td></tr><tr><td>void acquireSharedinterruptibly(int arg)</td><td>于acquireShared(int arg)相同，多了响应中断</td></tr><tr><td>tryAcquireSharedNanos</td><td>acquireSharedinterruptibly(int arg)基础上加了超时限制</td></tr><tr><td>boolean release(int arg)</td><td>独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td>boolean releaseShared(int arg)</td><td>共享式的释放同步状态</td></tr><tr><td>Collection<thread>getQueuedThreads()</thread></td><td>获取等待在同步队列上的线程集合</td></tr></tbody></table><p>模板方法基本上分为<code>三类</code></p><ul><li>独占式获取于释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>AQS内部也提供了三个方法对同步状态进行更改</p><ul><li>getState():获取当前同步状态</li><li>setState(int newState):设置当前同步状态</li><li>compareAndSetState(int expect,int update):使用CAS设置当前状态，保证原子性</li></ul><h2 id="2、独占式同步状态"><a href="#2、独占式同步状态" class="headerlink" title="2、独占式同步状态"></a>2、独占式同步状态</h2><p>通过调用<code>acquire</code>方法可以获取同步状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//调用自定义的方法获取同步状态</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//获取失败构造节点进入同步队列</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是，构造节点进入同步队列相关的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试在尾部添加新节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自旋，直到节点添加成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是队列通过自旋尝试获取同步状态的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//只有前驱节点是头结点可以获取同步状态</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就是释放了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒新的头节点的后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小结</p><ol><li>acquire调用尝试获取同步状态,成功则返回，不成功则进入addWaiter同步队列自旋判断自身前继节点是否头结点</li><li>如果是,acquireQueued尝试获取同步状态，移除队列，获取成功并执行相应逻辑后,设置为新的头节点</li><li>通过release唤醒后继结点进行自旋获取同步状态</li></ol><h2 id="3、共享式同步状态"><a href="#3、共享式同步状态" class="headerlink" title="3、共享式同步状态"></a>3、共享式同步状态</h2><p>共享式和独占式区别在于在<code>同一时刻</code>是否能有<code>多个线程</code>获取到同步状态<br>比如文件的读可以同时进行，写需要独占</p><p>当共享式访问资源时，其他共享式的访问都会被允许，而独占式访问会被阻塞<br>独占式访问资源时,同一时刻其他访问会被堵塞</p><p>通过<code>acquireShared</code>可以共享地获取同步状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">//调用重写的tryAcquireShared获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋获取</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">//获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是释放共享式的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>释放同步状态后，唤醒后继节点，这里与独占式的区别是，tryReleaseShared必须确认同步状态线程安全释放(自旋CAS)</p><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p>ReentrantLock支持重进入的锁，表示该锁能支持<code>一个线程对资源重复加锁</code>。同时还支持公平与非公平的选择<br>这里的公平指的是，在绝对时间上，先进行获取锁请求的一定先被满足，反之是不公平<br>事实上公平的锁往往没有非公平的效率高(线程切换).公平锁主要功能是减少<code>饥饿</code>发生的概率，等待越久的请求越是优先满足</p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被阻塞,需要解决两个问题</p><ul><li>线程再次获取锁<br>识别获取锁的线程是否为当前占据锁的线程</li><li>锁的最终释放<br>线程重复获取了多少次锁，就得有多少次释放，获取自增，释放自减，为0时表示锁已成功释放</li></ul><h1 id="四、ReentrantReadWriteLock"><a href="#四、ReentrantReadWriteLock" class="headerlink" title="四、ReentrantReadWriteLock"></a>四、ReentrantReadWriteLock</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ReentrantReadWriteLock是读写锁，维护了一个<code>读锁</code>和一个<code>写锁</code>,读锁可以允许多个线程访问，写锁阻塞访问<br>读写锁有以下特性</p><ul><li>保证写操作对读操作的可见性,如果存在读锁，则写锁不能被获取</li><li>有公平锁和非公平锁之分</li><li>支持重入,读锁获取了，还可以再次获取。写锁获取了，读写锁都可以再次获取</li><li>支持锁降级，同一个线程中，在没有释放写锁的情况下，可以申请读锁</li></ul><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><p>读写锁也是基于AQS实现的，但是只有一个整形变量，所以，读写锁以按位切割的方式把变量分成了两个部分<br><code>高16位表示读，低16位表示写</code></p><h1 id="五、工具"><a href="#五、工具" class="headerlink" title="五、工具"></a>五、工具</h1><h2 id="1、LockSupport"><a href="#1、LockSupport" class="headerlink" title="1、LockSupport"></a>1、LockSupport</h2><p>当需要阻塞或唤醒一个线程的时候，需要LockSupport，LockSupport定义了一组公共静态方法，提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>void park()</td><td>阻塞当前线程，如果调用unpark(Thread thread)方法或当前线程被中断,才能从park()</td></tr><tr><td>void parkNanos(long nanos)</td><td>在park()基础上增加了超时返回</td></tr><tr><td>void parkUntil(long deadline)</td><td>阻塞当前线程指导，deadline,毫秒</td></tr><tr><td>void unpack(Thread thread)</td><td>唤醒指定线程</td></tr></tbody></table><h2 id="2、Condition"><a href="#2、Condition" class="headerlink" title="2、Condition"></a>2、Condition</h2><p>Condition跟Lock配合可以实现<code>等待/通知模式</code>,比Object自带的有一些加强<br>使用上比较简单，调用Lock的<code>newCondition</code>即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();<span class="comment">//释放锁并等待</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();<span class="comment">//通知当前线程从await返回,并且返回前获取了锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(四) — synchronized</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20%E2%80%94%20synchronized/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20%E2%80%94%20synchronized/</url>
      <content type="html"><![CDATA[<p><code>synchronized</code>的作用是保证方法或代码在运时，同一时刻只有一个方法可以进到<code>临界区</code>,同时还可以保证共享变量的内存可见性</p><p><code>synchronized</code>可修饰的对象有</p><ul><li>代码块synchronized(){}，范围是<code>大括号{}</code>括起来的部分,作用对象是小括号里的对象</li><li>方法，范围是<code>整个方法</code>,作用对象是调用这个方法的对象</li><li>静态方法,范围是<code>整个静态方法</code>,作用对象是这个类的所有对象</li><li>类，作用范围是<code>synchronized</code>后面括号部分，作用对象是类的所有对象</li></ul><h2 id="底层语义原理"><a href="#底层语义原理" class="headerlink" title="底层语义原理"></a>底层语义原理</h2><p>Java虚拟机中的同步基于<code>进入和退出monitor</code>对象实现,显式同步和隐式同步都是 (monitorenter和monitorexit指令)</p><p>而同步方法是由方法调用指令，读取运行时<code>常量池</code>中方法的<code>ACC_SYNCHRONIZED</code>标志来隐式实现的。</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在JVM中，对象在内存中的布局分为三块区域<code>对象头、实例数据、填充数据</code><br><img src="/media/15719044553160.jpg" alt=""></p><ul><li>实例变量:存放<code>类的属性</code>数据信息，包括父类的属性信息，数组还包括数组长度，按<code>4字节对齐</code></li><li>填充数据:由于虚拟机要求对象的起始地址必须是<code>8字节的倍数</code>,所以就有了填充,为了字节对齐</li></ul><p>JVM中采用<code>2个字</code>存储对象头(数组是<code>3个</code>,多一个记录数组长度)</p><h2 id="1、结构"><a href="#1、结构" class="headerlink" title="1、结构"></a>1、结构</h2><p>其主要结构是由<code>Mark Word</code>和<code>Class Metadata Address</code>组成</p><table><thead><tr><th>虚拟机位数</th><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的HashCode、锁信息或分代年龄或GC标志</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，确认该对象是哪个类的实例</td></tr></tbody></table><h2 id="2、Mark-Word"><a href="#2、Mark-Word" class="headerlink" title="2、Mark Word"></a>2、Mark Word</h2><p>各种锁状态下Mark Word存储情况</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit 是否是偏向锁</th><th>2bit 锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID(23bit) Epoch(2bit)</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向锁记录的指针</td><td>对象分代年龄</td><td>0</td><td>00</td></tr><tr><td>重量级锁</td><td>指向重量级锁的指针</td><td>对象分代年龄</td><td>0</td><td>10</td></tr><tr><td>GC标记</td><td>空</td><td>对象分代年龄</td><td>1</td><td>11</td></tr></tbody></table><p>synchronized在JDK1.6优化之后才出现<code>偏向锁和轻量级锁</code></p><hr><h1 id="synchronized锁升级原理"><a href="#synchronized锁升级原理" class="headerlink" title="synchronized锁升级原理"></a>synchronized锁升级原理</h1><h2 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h2><p>偏向锁的意思是如果一个线程获取了一个偏向锁,在接下来的一段时间没有其他线程来竞争，那么持有偏向锁的线程再次进入同步代码时，<code>不再需要抢占锁和释放锁的操作</code></p><p>适合<code>一个线程</code>的场景</p><p>-XX:BiasedLockingStartupDelay=0 可以设置偏向锁启动的延迟<br>-XX:UseBiasedLocking=false 如果确认通常是竞争状态，可关闭偏向锁，默认会进入轻量级锁</p><h3 id="偏向锁获取方式"><a href="#偏向锁获取方式" class="headerlink" title="偏向锁获取方式"></a>偏向锁获取方式</h3><ol><li>首先判断目标对象的对象头，根据<code>标识和epoch</code>判断是否处于可偏向状态</li><li>是的话，通过CAS将自己的线程ID复制到对象头的Mark Work,继续执行</li><li>不是的话，判断自己的线程ID跟对象头Mark Work中的是否相等，相等证明已获得,继续执行不用进行竞争和释放操作</li><li>如果不相等，需要撤销偏向锁，升级轻量级锁</li></ol><h2 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h2><p>当偏向锁撤销，有两种情况 </p><ol><li>线程已经退出同步代码,接下来就是撤销偏向锁,升级为轻量级锁</li><li>线程正在执行同步代码，原来的线程会继续持有锁并且升级为轻量级锁</li></ol><p>适合追求相应速度，同步块执行速度快</p><h3 id="轻量级锁获取方式"><a href="#轻量级锁获取方式" class="headerlink" title="轻量级锁获取方式"></a>轻量级锁获取方式</h3><ol><li>JVM会在当前的线程<code>栈帧</code>中创建一个用于存储锁记录的空间</li><li>将对象头的Mark Work的记录复制到锁记录中</li><li>线程尝试用CAS将对象头Mark Work替换为指向所记录空间的指针</li><li>替换成功,则当前线程获取轻量级锁</li><li>替换失败，则存在其他线程竞争，CAS若干次失败后，会升级成重量级锁</li></ol><h2 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h2><p>因为CAS消耗资源，一旦升级成重量级锁，就不会降级，其他线程访问就会出现堵塞的状态</p><p>适合吞吐量高，同步块执行时间长</p><p>重量级锁依赖对象内部的monitor锁实现，而monitor又依赖操作系统的MutexLock(互斥锁)<br>重量级锁开销比较大的原因是，阻塞和唤醒一个线程，都需要通过操作系统完成，从用户态转换到内核态相对耗时 </p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(三) — volatile</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%20%E2%80%94%20volatile/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%20%E2%80%94%20volatile/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Java允许线程<code>访问共享变量</code>，为了确保共享变量能被准确和一直地更新，线程应该通过<code>排他锁</code>获得这个变量，所以就有了<code>volatile</code><br>如果一个字段被声明为<code>volatile</code>,那么Java线程内存模型会确保，所有线程看到这个变量的值都是一致的</p><p>简而言之，volatile有以下特性</p><ul><li>可见性:对一个volatile变量的读，总是能看到任意线程对这个volatile变量<code>最后的写</code></li><li>原子性:对任意单个volatile变量的读/写具有原子性，但是类似i++这种操作没有</li></ul><p>但是volatile是无法完全保证原子性，可以采用方法有</p><ol><li>synchronized关键字</li><li>Lock</li><li>AtomicInteger等原子操作类</li></ol><h1 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>当线程执行这条语句时</p><ol><li>复制一份到高速缓存</li><li>执行完+1操作后的值，写入高速缓存</li><li>最后再把高速缓存中的值刷新到主内存中</li></ol><p>在单核CPU中是没问题的，但是多核CPU就不一样了<br>线程A和线程B有可能<code>同时读取</code>一份到高速缓存，然后<code>分别操作和写入</code>到主内存中<br>期望结果是2，但是最后出来的是1</p><p>被<code>volatile</code>关键字修饰的变量之后，在汇编代码中，会多出一个<code>Lock前缀指令</code><br><code>Lock前缀指令</code>在多核处理器中会发生两件事情</p><ul><li>将当前CPU的缓存行数据写到<code>系统内存</code></li><li>其他CPU如果缓存了该内存地址的数据，会因为缓存一致性协议(MESI,嗅探技术)而被设置为无效</li></ul><blockquote><p>缓存行： CPU Cache中的最小单位</p></blockquote><p>当其他CPU对这个数据进行修改操作时，会<code>重新</code>从系统内存中把数据<code>读取</code>到自己的缓存中</p><h1 id="三、内存语义"><a href="#三、内存语义" class="headerlink" title="三、内存语义"></a>三、内存语义</h1><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：　　</p><ol><li>一个线程<code>修改了某个变量</code>的值，这新值对其他线程来说是<code>立即可见</code>的。</li><li><code>禁止</code>进行指令重排序。</li></ol><blockquote><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>指编译器和处理器为了优化程序性能而堆指令序列进行重新排序的一种手段 </p><ul><li>编译器优化重排序。编译器在<code>不改变单线程程序语义</code>的前提下，可以重新安排语句的执行顺序</li><li>指令集并行重排序。如果不存在<code>数据依赖性</code>,处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序。由于处理器使用<code>缓存和读/写缓存区</code>，使得<code>加载和存储操作</code>看上去是乱序执行</li></ul></blockquote><p>而为了实现volatile的内存语义，JMM会对重排序进行<code>限制</code>,在内存中，这个限制就是<code>内存屏障</code></p><blockquote><p>内存屏障:一组处理器指令，用于实现对内存操作的顺序限制</p></blockquote><h1 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h1><ol><li>对变量的写操作不依赖当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol><p>这些条件表明，可以被写入 volatile 变量的这些有效值<code>独立于任何程序的状态</code>，包括变量的当前状态。</p><p>状态标记量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>double check<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(二) — Thread类</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E2%80%94%20Thread%E7%B1%BB/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E2%80%94%20Thread%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Java中，自带对多线程技术的支持，实现多线程编程的方式主要有两种</p><ul><li>继承<code>Thread类</code></li><li>实现<code>Runnable接口</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><p>从源码中可以看出，实际上Thread也是实现了Runnable接口，如果为了支持<code>多继承</code>可以使用实现Runnable接口这种方式，两者没有本质上的区别</p><h2 id="1、继承Thread类"><a href="#1、继承Thread类" class="headerlink" title="1、继承Thread类"></a>1、继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"I am Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        WKThread wkThread=<span class="keyword">new</span> WKThread();</span><br><span class="line">        wkThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类中的<code>start()</code>方法通知<code>线程规划器</code>通知线程已就绪，等待调用线程对象的<code>run()</code>方法,也就是等待系统分配资源调用。这样的是异步调用。<br>如果线程对象不是异步，而是同步，那么会由<code>main主线程</code>来调用run()方法，也就是必须等待run()方法完成才可执行后面的代码</p><h2 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WKRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> WKRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理与上面相同</p><blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>需要注意的是，使用线程的话，推荐使用<code>线程池</code>的方式去创建，而不是直接new</p></blockquote><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="1、Thread类的一些API"><a href="#1、Thread类的一些API" class="headerlink" title="1、Thread类的一些API"></a>1、Thread类的一些API</h2><h3 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread"></a>currentThread</h3><p><code>currentThread</code>方法可以返回当前代码段被哪个线程调用的Thread对象信息<br>比如获取线程的<code>name</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName();</span><br></pre></td></tr></table></figure><h3 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h3><p>isAlive用于判断当前线程<code>是否处于活动状态</code></p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>可以让当前线程，即<code>this.currentThread()</code>返回的线程，<code>暂停执行</code>指定毫秒数</p><h3 id="getId"><a href="#getId" class="headerlink" title="getId"></a>getId</h3><p>获取线程的<code>唯一标识</code></p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><code>yield</code>方法是放弃当前的CPU资源，将它让给其他的任务去占用CPU的时间，但是放弃的时间不确定，可能刚刚放弃又获得</p><h2 id="2、停止线程"><a href="#2、停止线程" class="headerlink" title="2、停止线程"></a>2、停止线程</h2><p>一般来说会使用<code>interrupt()</code>方法去停止一个线程，但是并不会马上停止，只是在当前线程打一个标记</p><blockquote><p>过期的方法，stop,suspend,resume,都不能使用</p></blockquote><p>有两个方法可以判断线程是否处于中断状态</p><ul><li>interrupted:判断当前线程是否处于中断状态，并且<code>清除</code>停止状态</li><li>isInterrupted:判断线程是否处于中断状态</li></ul><h3 id="抛出异常停止"><a href="#抛出异常停止" class="headerlink" title="抛出异常停止"></a>抛出异常停止</h3><p>如果需要马上停止一个线程，可以使用<code>抛出异常</code>的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am Thread "</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="return停止"><a href="#return停止" class="headerlink" title="return停止"></a>return停止</h3><p>当然也可以使用<code>return</code>，但是最好方案还是抛出异常，因为这样可以把线程停止的事件往上传播<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I am Thread "</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是在sleep状态下停止某一个线程，会进入catch语句，并且清除停止状态值</p><h1 id="三、线程优先级"><a href="#三、线程优先级" class="headerlink" title="三、线程优先级"></a>三、线程优先级</h1><p>操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是优先级高<br>但是高优先级也不一定会比低优先级的先运行，存在一定的<code>随机性</code></p><p>在Java中使用<code>setPriority</code>方法来设置线程的优先级，并且分为<code>1~10</code>级，而且有几个内置常量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>线程优先级是有<code>继承性的</code>,即如果A线程启动B线程，那么B线程将拥有跟A线程一样的优先级</p><h1 id="四、守护线程"><a href="#四、守护线程" class="headerlink" title="四、守护线程"></a>四、守护线程</h1><p>守护线程Daemon的作用是为其他线程服务,经典的例子就是GC，如果非守护线程不存在，守护线程也将结束</p><h1 id="五、线程间的通信"><a href="#五、线程间的通信" class="headerlink" title="五、线程间的通信"></a>五、线程间的通信</h1><h2 id="1、等待和通知机制"><a href="#1、等待和通知机制" class="headerlink" title="1、等待和通知机制"></a>1、等待和通知机制</h2><p>等待和通知机制有三个重要方法,调用之前都必须获取对象级别的锁</p><ul><li>wait:使调用该方法的线程释放共享资源的锁，然后从运行状态进入到等待队列，等待唤醒</li><li>notify:随机唤醒等待队列中等待<code>同一资源</code>的<code>一个</code>线程,使该线程进入可运行状态</li><li>notifyAll:唤醒等待队列中等待<code>同一资源</code>的<code>所有</code>线程,进入可运行状态</li></ul><p>要注意的是notify所在的同步块要运行完之后才会释放锁，然后才到wait所在的代码获取锁</p><h2 id="2、管道输入-输出流"><a href="#2、管道输入-输出流" class="headerlink" title="2、管道输入/输出流"></a>2、管道输入/输出流</h2><p>管道输入/输出流主要用于线程之间的数据传输，而传输的媒介为内存,包括四种类</p><ul><li>PipedOutputStream和PipedInputStream,面向字节</li><li>PipedReader和PipedWriter,面向字符</li></ul><h2 id="3、join方法"><a href="#3、join方法" class="headerlink" title="3、join方法"></a>3、join方法</h2><p>如果一个线程A执行了线程B的join方法，那么含义是，当前线程A等待线程B终止后才从B.join返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);<span class="comment">//使用wait方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);<span class="comment">//使用wait方法</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join的内部其实也是使用了wait方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line">  ...</span><br><span class="line">  thread_main_inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>-&gt;exit(<span class="keyword">false</span>);</span><br><span class="line">  delete <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">  <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">  <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">  <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">  <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">"java thread object must exist"</span>);</span><br><span class="line">  <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">  <span class="comment">// to complete once we've done the notify_all below</span></span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  lock.notify_all(thread);</span><br><span class="line">  <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join之后的唤醒在native层</p><h2 id="4、ThreadLocal"><a href="#4、ThreadLocal" class="headerlink" title="4、ThreadLocal"></a>4、ThreadLocal</h2><p>ThreadLocal是当前线程自己绑定的值,数据结构是<code>key-value</code>的形式.ThreadLocal通常被private static修饰，线程结束后，ThreadLocal对应的实例副本也被回收</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>ThreadLocal内部事实上是维护了一个叫<code>ThreadLocalMap</code>的类<br>而ThreadLocalMap就是一个<code>Entry</code>的数组，<code>key值永远是ThreadLocal对象</code></p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>从set的代码中可以看出，当发生hash冲突时，ThreadLocalMap会进行重新hash</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);<span class="comment">//清除空key的entry，防止内存泄露</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();<span class="comment">//hash冲突，重新哈希</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 还有一个重点内容是Entry是弱引用的形式的如果ThreadLocal对应的线程一直运行那么，Entry对象中的value就有可能一直得不到回收，出现内存泄露，所以set方法中会清除空key的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal使用完之后，调用<code>remove</code>是个好习惯</p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal可以让子线程获得父线程的值</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java多线程(一) — 基本概念</title>
      <link href="/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/11/06/Java/Thread/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="一、线程的基本概念"><a href="#一、线程的基本概念" class="headerlink" title="一、线程的基本概念"></a>一、线程的基本概念</h1><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li>并发是相对一个CPU,分时间片执行任务,同一<code>时间间隔</code>事件</li><li>并行是相对多个CPU,分别同时执行任务,同一<code>时间点</code>事件</li></ul><h2 id="并行和串行"><a href="#并行和串行" class="headerlink" title="并行和串行"></a>并行和串行</h2><ul><li>串行是执行完一个任务再去执行下一个</li><li>并行是多个任务同时执行</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul><li>同步是<code>顺序进行</code>，需要进行等待，协调</li><li>异步在等待某一个任务执行过程中继续执行自己的任务,线程是实现异步的一个方式</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程是程序设计的<code>逻辑概念</code>，指的是在进程中并发运行的一段<code>代码</code>，实现多个线程间切换执行</p><h1 id="二、Java线程的状态"><a href="#二、Java线程的状态" class="headerlink" title="二、Java线程的状态"></a>二、Java线程的状态</h1><p>在Java类库,<code>Thread类</code>中有一个<code>State的枚举类</code>列出了线程的<code>6个状态</code></p><ul><li>初始(NEW)：<code>新创建</code>了一个线程对象，但还没有调用start()方法。</li><li><p>可运行(RUNNABLE)：Java线程中将<code>就绪（ready）</code>和<code>运行中（running）</code>两种状态笼统地称为”运行”。<br>调用了start()方法。线程位于<code>可运行线程池</code>中,<code>等待被线程调度</code>选中，此时处于<code>就绪状态（ready）</code>。就绪状态的线程在<code>获得CPU时间片后</code>变为运行中状态（running）。</p></li><li><p>阻塞(BLOCKED)：表示线程<code>阻塞于锁</code>。</p></li><li><p>等待(WAITING)：进入该状态的线程需要等待其他线程<code>做出一些特定动作</code>（通知或中断）。</p></li><li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后<code>自行返回</code>。</p></li><li><p>终止(TERMINATED)：表示该线程已经<code>执行完毕</code>。</p></li></ul><h1 id="三、并发编程需要注意的地方"><a href="#三、并发编程需要注意的地方" class="headerlink" title="三、并发编程需要注意的地方"></a>三、并发编程需要注意的地方</h1><p>并行并发不一定就比串行快，因为线程的创建和上下文切换也需要开销</p><ul><li>lmbench3可以测量上下文切换的时长</li><li>vmstat可以测量上下文切换的次数</li></ul><p>减少上下文切换的方法</p><ul><li>无锁并发编程:使用一些方法来避免用锁</li><li>CAS:使用Atomic包的CAS算法更新数据，不用加锁</li><li>避免使用不必要的线程</li><li>协程:单线程实现多任务调度</li></ul><h2 id="1、-减少waiting线"><a href="#1、-减少waiting线" class="headerlink" title="1、 减少waiting线"></a>1、 减少waiting线</h2><ol><li>使用jstack工具dump出对应进程的线程信息</li><li>查看哪些线程waiting比较多</li><li>根据线程对应的程序调整</li></ol><h2 id="2、避免死锁的方法"><a href="#2、避免死锁的方法" class="headerlink" title="2、避免死锁的方法"></a>2、避免死锁的方法</h2><ul><li>避免一个线程获取多个锁</li><li>避免一个线程在锁内获取多个资源</li><li>尝试使用定时锁</li><li>数据库锁，加锁解锁都必须在同一个数据库连接</li></ul><h2 id="3、各种操作的一些资源利用"><a href="#3、各种操作的一些资源利用" class="headerlink" title="3、各种操作的一些资源利用"></a>3、各种操作的一些资源利用</h2><p>下载文件</p><ul><li>带宽</li><li>硬盘读写速度</li></ul><p>数据库操作</p><ul><li>数据库连接数</li></ul><h2 id="4、线程安全"><a href="#4、线程安全" class="headerlink" title="4、线程安全"></a>4、线程安全</h2><p>当<code>多个线程</code>访问一个类时，如果<code>不考虑</code>这些线程在运行时环境下的<code>调度和交替执行</code>，并且<code>不需要额外</code>的同步及在调用方代码不必作其他的协调，这个类的行为仍是正确的，那么称这个类是<code>线程安全</code>的</p><p>并发编程中两个关键问题：线程之间如何通信和线程之间如何同步<br>通信机制有两种：共享内存和消息传递</p><p>而Java的方法用的是共享内存模型，Java线程间的通信总是隐式进行。</p><p><a href="https://zhuanlan.zhihu.com/p/34678757" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34678757</a></p><p><a href="https://blog.csdn.net/SEU_Calvin/article/details/52411531" target="_blank" rel="noopener">https://blog.csdn.net/SEU_Calvin/article/details/52411531</a></p><p>原子性操作原理</p>]]></content>
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(五) — LinkedList</title>
      <link href="/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%BA%94)%20%E2%80%94%20LinkedList/"/>
      <url>/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%BA%94)%20%E2%80%94%20LinkedList/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>LinkedList内部是由<code>双向链表</code>实现的,特点是</p><ol><li>线程不安全</li><li>允许元素为null<br>当然也有链表的特点，<code>增删</code>只需要移动指针，时间效率较高。不需扩容，空间效率比ArrayList高。<br>访问元素时，需要定位节点，时间效率低。</li></ol><h1 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把传入参数的所有元素添加到集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点信息(可以看出是双向链表)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//元素值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后置节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前置节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、操作方法"><a href="#三、操作方法" class="headerlink" title="三、操作方法"></a>三、操作方法</h1><h2 id="1、增"><a href="#1、增" class="headerlink" title="1、增"></a>1、增</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//在尾部添加一个节点</span></span><br><span class="line">     linkLast(e);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//记录原尾结点</span></span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="comment">//新建一个节点</span></span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//更新尾部节点</span></span><br><span class="line">     last = newNode;</span><br><span class="line">     <span class="comment">//如果本身为空链表就把新节点设为头节点</span></span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="comment">//如果不是就链接新节点</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;</span><br><span class="line">     <span class="comment">//大小增加</span></span><br><span class="line">     size++;</span><br><span class="line">     <span class="comment">//修改次数添加</span></span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//指定下标添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//检查是否越界</span></span><br><span class="line">     checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (index == size)</span><br><span class="line">         <span class="comment">//尾部插入</span></span><br><span class="line">         linkLast(element);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//从中间插入</span></span><br><span class="line">         linkBefore(element, node(index));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert succ != null;</span></span><br><span class="line">     <span class="comment">//保存后置节点的前置节点</span></span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">     <span class="comment">//构建新节点</span></span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">     <span class="comment">//把新节点作为原succ节点的前置节点</span></span><br><span class="line">     succ.prev = newNode;</span><br><span class="line">     <span class="comment">//表示succ是原头结点，</span></span><br><span class="line">     <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">//更新头结点</span></span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//否则修改前置节点的后置节点为新节点</span></span><br><span class="line">         pred.next = newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2、删"><a href="#2、删" class="headerlink" title="2、删"></a>2、删</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//把节点从链表删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">//保存节点的值，前置后置节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置为空，证明是头节点，直接把后置节点设为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    <span class="comment">//否则就把前置节点的后置节点，设置为后置节点，并把节点的前置节点置空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置为空，证明是尾节点，直接把尾节点设置为前置节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    <span class="comment">//否则把前置节点设置为，后置节点的前置节点,并把节点的后置节点置空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把当前节点值置空</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历寻找传入的节点值对应的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、改"><a href="#3、改" class="headerlink" title="3、改"></a>3、改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">//检查越界[0,size)</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);<span class="comment">//取出对应的Node</span></span><br><span class="line">    E oldVal = x.item;<span class="comment">//保存旧值 供返回</span></span><br><span class="line">    x.item = element;<span class="comment">//用新值覆盖旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;<span class="comment">//返回旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、查"><a href="#4、查" class="headerlink" title="4、查"></a>4、查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     checkElementIndex(index);<span class="comment">//判断是否越界 [0,size)</span></span><br><span class="line">     <span class="keyword">return</span> node(index).item; <span class="comment">//调用node()方法 取出 Node节点，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历寻找对应节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历寻找对应值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//如果目标对象是null</span></span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">////遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Deque"><a href="#三、Deque" class="headerlink" title="三、Deque"></a>三、Deque</h2><p>LinkedList实现了<code>Deque</code>接口，并且重写了相关方法<br><img src="/media/15731822363181.jpg" alt=""><br>所以也可以作为<code>栈、队列和双端队列</code>来使用</p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(四) — ArrayList</title>
      <link href="/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E5%9B%9B)%20%E2%80%94%20ArrayList/"/>
      <url>/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E5%9B%9B)%20%E2%80%94%20ArrayList/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>ArrayList是一个<code>动态数组</code>,特点是</p><ol><li>线程不安全</li><li>允许元素为null<br>实现了<code>RandomAccess</code>接口拥有<code>随机快速访问</code>的能力</li></ol><p>当然因为底层是数组，所以也拥有数组的优缺点，连续的内存，读写时间效率高，空间效率低<br>因为是数组，所以<code>扩容操作</code>也是性能消耗大的地方。<code>主要</code>关心的也是扩容操作</p><h1 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认构造函数的空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//存放集合元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//当前元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入默认容量的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入容量大于0，直接创建数组</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">//如果传入容量等于0，把空数组赋值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        <span class="comment">//如果小于0，直接抛出异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造方法创建空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据集合元素创建数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果数组元素不为0,开始复制</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果c.toArray出错，没有返回Object[]</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">//利用Arrays.copyOf 来复制集合c中的元素到elementData数组中</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    <span class="comment">//如果数组元素为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//复制空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法走完之后，数组的<code>size</code>和<code>elementData</code>就有了<br>构造方法中的一些工具方法很值得注意一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection.toArray()</span><br><span class="line">Arrays.copyOf(elementData, size, Object[].class)</span><br><span class="line">System.arraycopy</span><br></pre></td></tr></table></figure></p><h1 id="三、操作API"><a href="#三、操作API" class="headerlink" title="三、操作API"></a>三、操作API</h1><h2 id="1、增"><a href="#1、增" class="headerlink" title="1、增"></a>1、增</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加之前，判断是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//在数组后面添加一个元素，并且size++</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//越界判断</span></span><br><span class="line">         rangeCheckForAdd(index);</span><br><span class="line">         ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">         System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">         elementData[index] = element;</span><br><span class="line">         size++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断数组是否为默认空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//拿到扩容容量</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果确定要扩容，会修改modCount </span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// 判断要扩大的容量是否比当前大</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//默认扩大原来的一半</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果不够，就扩容为目标容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加过程</p><ol><li>判断是否越界，判断是否需要扩容</li><li>如果需要扩容，修改modCount</li><li>默认扩大<code>原来的一半</code>,如果不够，就扩容为目标容量</li><li>复制数组</li></ol><h2 id="2、删"><a href="#2、删" class="headerlink" title="2、删"></a>2、删</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//结构改变了，修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将后面的元素往前移</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//把最后一个元素置空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除该元素在数组中第一次出现的index</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                <span class="comment">//根据index删除</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;<span class="comment">//w 代表批量删除后 数组还剩多少元素</span></span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历判断当前数组有没有要删除的集合</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="comment">//没有就保存</span></span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//出现异常的情况</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            <span class="comment">//把出现异常后数组全部复制到数组</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把后面的元素置空</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回是否有修改</span></span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作会修改<code>modCount</code>,也可以涉及到数组的复制，所以相对低效</p><h2 id="3、改"><a href="#3、改" class="headerlink" title="3、改"></a>3、改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//越界检查</span></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">//取出元素 </span></span><br><span class="line">    elementData[index] = element;<span class="comment">//覆盖元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回元素</span></span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## 4、查 </span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//越界检查</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index); <span class="comment">//下标取数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、clear"><a href="#5、clear" class="headerlink" title="5、clear"></a>5、clear</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改modCount</span></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  <span class="comment">//将所有元素置null</span></span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>; <span class="comment">//修改size </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、contain"><a href="#6、contain" class="headerlink" title="6、contain"></a>6、contain</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、判空"><a href="#7、判空" class="headerlink" title="7、判空"></a>7、判空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、迭代器"><a href="#8、迭代器" class="headerlink" title="8、迭代器"></a>8、迭代器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 游标</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个返回的元素; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//用于判断是否被修改过</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="comment">//判断操作时是否被修改</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//游标+1</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];<span class="comment">//返回元素并设置上一次返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除上次next的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 另外还有<code>writeObject</code>和<code>readObject</code>，这两个序列化和反序列化的方法</p><h1 id="三、Stack和Vector"><a href="#三、Stack和Vector" class="headerlink" title="三、Stack和Vector"></a>三、Stack和Vector</h1><p>这两个已经是比较老的类了，一般都不使用</p><h2 id="1、Vector"><a href="#1、Vector" class="headerlink" title="1、Vector"></a>1、Vector</h2><p>ArrayList和Vector操作逻辑上基本是一样的，内部也是用数组实现，不同的是，Vector的API都用<code>synchronized</code>去修饰，所以它是线程安全的，而且扩容的时候是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br></pre></td></tr></table></figure></p><h2 id="2、Stack"><a href="#2、Stack" class="headerlink" title="2、Stack"></a>2、Stack</h2><p>Stack是继承于Vector实现一个栈</p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(三) — TreeMap</title>
      <link href="/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%89)%20%E2%80%94%20TreeMap/"/>
      <url>/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%89)%20%E2%80%94%20TreeMap/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(二) — LinkedHashMap</title>
      <link href="/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%BA%8C)%20%E2%80%94%20LinkedHashMap/"/>
      <url>/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%BA%8C)%20%E2%80%94%20LinkedHashMap/</url>
      <content type="html"><![CDATA[<h1 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h1><p>LinkHashMap继承自HashMap</p><p>特点</p><ol><li>线程不安全(线程安全可使用<code>ConcurrentHashMap</code>)</li><li>允许单个null的key和多个null的值</li><li>新增<code>遍历有序</code></li></ol><p>存储结构同样是<code>数组+链表+红黑树</code>，为了<code>实现有序</code>,单链表改成了<code>双向链表</code>,<code>Entry</code>继承了<code>HashMap.Node</code>,并且新增了两个参数,记录节点前后的节点信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且还新增了<code>head,tail</code>这两个成员变量记录了链表的头部和尾部<br><code>accessOrder</code>就是控制<code>输出顺序</code>。<code>默认false</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表头部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//链表尾部</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//遍历时的顺序，true 访问顺序 false 插入顺序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></p><p>总的来说，相对HashMap，多了<code>遍历有序</code></p><h1 id="二、-put"><a href="#二、-put" class="headerlink" title="二、 put"></a>二、 put</h1><p>这里没有对put方法进行重写，重写的是构建新节点的的方法<code>newNode()</code>,并通过<code>linkNodeLast</code>将新节点连接到内部双向链表的尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把节点添加到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及HashMap专门留下来的回调方法</p><ul><li>afterNodeAccess </li><li>afterNodeInsertion</li><li>afterNodeRemoval</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//被访问后回调，会将被访问的节点移到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; </span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//回调函数，新节点插入之后回调,根据evict和设定是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;         </span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            K key = first.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，将节点从双向链表中删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; </span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致<code>fail-fast</code>，因为迭代的顺序已经改变。</p>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java集合(一) — HashMap</title>
      <link href="/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%80)%20%E2%80%94%20HashMap/"/>
      <url>/2019/11/06/Java/Collections/Java%E9%9B%86%E5%90%88(%E4%B8%80)%20%E2%80%94%20HashMap/</url>
      <content type="html"><![CDATA[<h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><p>HashMap是一个<code>关联数组、哈希表</code>，其中数组被称为<code>哈希桶</code>，每个<code>桶里放的是单链表或红黑树</code>，每个<code>节点</code>就是哈希表中的<code>元素</code>。</p><p>特点是</p><ol><li>线程不安全(线程安全可使用<code>ConcurrentHashMap</code>)</li><li>遍历无序</li><li>允许单个null的key和多个null的值</li></ol><p><code>JDK1.8后</code>，新增了<code>红黑树</code>，当单个链表的元素达到<code>8</code>，就会转换成红黑树，提高查询和插入的效率，避免链表过长的问题</p><p>需要关注的问题</p><ol><li>hash表，涉及到<code>碰撞解决</code></li><li>数组，涉及到<code>扩容机制</code></li></ol><blockquote><h2 id="Hash知识补充"><a href="#Hash知识补充" class="headerlink" title="Hash知识补充"></a>Hash知识补充</h2><p>Hash就是把任意长度的消息(<code>预映射:pre-image</code>)通过哈希算法压缩成<code>固定长度</code>的消息输出,输出的值就是<code>Hash值</code>。<code>不同的输入</code>可能有<code>同样的输出</code>,所以用Hash值<code>得不到唯一值</code>,同样的输出<br>称为<code>碰撞</code>需要进行<code>碰撞处理</code>:一般有:<br><code>拉链法(open hashing)</code>、<code>开放定址法(closed hashing)</code>、<code>再哈希法</code>、<code>建立公共溢出区</code></p></blockquote><h1 id="二、碰撞解决"><a href="#二、碰撞解决" class="headerlink" title="二、碰撞解决"></a>二、碰撞解决</h1><p>从源码可知，HashMap中非常重要的一个字段， <code>Node[] table</code>，即<code>Hash桶数组</code>，Node的数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//用于定位索引</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">//链表的下一个Node</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Node是HashMap的一个内部类(JDK1.7对应类名Entry)，实现了<code>Map.Entry</code>接口，本质是就是一个<code>键值对</code>。每一个<code>节点存储的就是一个Node</code></p><p>HashMap使用的是Hash表存储，并且使用<code>拉链法</code>解决碰撞。简单来说，就是数组加链表的结合.<br>当数据被Hash后，得到<code>数组下标</code>，把数据放在<code>对应下标元素的链表</code>。如果发生了碰撞，就会把数据插到对应链表的<code>尾部</code>(JDK1.7是插到头部，插到尾部避免了逆序，环形链表,后文会讲到)</p><p> <img src="/media/15692013445358.jpg" alt="-w541"></p><h1 id="三、扩容机制"><a href="#三、扩容机制" class="headerlink" title="三、扩容机制"></a>三、扩容机制</h1><p> 理解扩容机制之前需要看一下几个重要的参数<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容量默认为16,且必须为2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//负载默认因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">int</span> threshold;            </span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    </span><br><span class="line"><span class="comment">//结构变化次数</span></span><br><span class="line"><span class="keyword">int</span> modCount; </span><br><span class="line"><span class="comment">//实际存储的键值对</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>threshold</code>是HashMap所能容纳的最大数据量,计算公式是<code>threshold = length * loadFactor</code><br>当存储个数<code>size</code>大于<code>threshold</code>,容量扩大为<code>原来的两倍</code></p></li><li><p><code>modCount</code>用来记录HashMap<code>内部结构发生变化的次数</code>,主要用于迭代的快速失败.需要注意的是，put键值对的时候，某个key的value<code>被覆盖不属于结构变化</code></p></li><li><p><code>loadFactor 负载因子</code>默认值是<code>0.75</code>,这是对空间和时间成本的一种折中,一般情况下不需要修改,负载因子越大,对空间利用越充分,查询效率也越低,负载因子越小,哈希表的数据越稀疏,对空间浪费也越严重</p></li><li><p><code>DEFAULT_INITIAL_CAPACITY 初始容量</code>为<code>16</code>,且为<code>2的幂</code>,采用这种<code>非常规</code>设计,主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p></li></ul><p>下面来分析一下<code>resize</code>的源码，鉴于红黑树比较复杂，这里先看JDK1.7<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   </span><br><span class="line">     <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     Entry[] oldTable = table;    </span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;        </span><br><span class="line">     <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了 </span></span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; </span><br><span class="line">         <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 </span></span><br><span class="line">         threshold = Integer.MAX_VALUE; </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//！！将数据转移到新的Entry数组里  </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line">   <span class="comment">//HashMap的table属性引用新的Entry数组                        </span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//修改阈值                          </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本质上就是从新创建一个大数组，并且把原来的数据转移过来，下面是转移的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//释放旧Entry数组的对象引用，防止对象游离</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">//标记</span></span><br><span class="line">                 e.next = newTable[i];</span><br><span class="line">                 <span class="comment">//将元素放在数组上 </span></span><br><span class="line">                 newTable[i] = e;</span><br><span class="line">                 <span class="comment">//访问下一个Entry链上的元素      </span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>e的引用复制给了newTable[i],也就是说这里使用了单链表的<code>头插法</code>，而且需要<code>重新计算</code>每个元素的<code>hash值</code>，这两点与JDK1.8有区别,</p><h2 id="1、优化"><a href="#1、优化" class="headerlink" title="1、优化"></a>1、优化</h2><p>下面要分析一下JDK1.8中做的优化,从JDK1.8的代码可以看出,数组的长度扩展为<code>原来的2倍</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure></p><p>所以，元素的位置要么是在<code>原位置</code>，要么是在<code>原位置再移动2次幂</code>的位置，下图就可以看的出来<br><img src="/media/15692961900375.jpg" alt=""><br>a,b分别是扩容前和扩容后，hash1无变化，hash2高位变成了1,所以index也就有了这样的变化<br><img src="/media/15692963388249.jpg" alt=""></p><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是<code>0的话索引没变</code>，是<code>1的话索引变成&quot;原索引+oldCap&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e</span><br></pre></td></tr></table></figure><p>下图为16扩充为32的resize示意图<br><img src="/media/15692963846956.jpg" alt=""></p><p>这样，既<code>省去了重新计算hash值的时间</code>，同时，由于新增的1bit可以认为是<code>随机的</code>，因此resize的过程，<code>均匀地</code>把之前的冲突的节点分散到新的bucket了。</p><p>下面是JDK1.8扩容的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果原容量的两倍小于最大容量，且元容量大于默认容量</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              <span class="comment">//新容量为原容量的两倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//遍历旧数组</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="comment">// 原索引</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、-put"><a href="#四、-put" class="headerlink" title="四、 put"></a>四、 put</h1><p><img src="/media/15692055428965.jpg" alt=""></p><ol><li>如果table为null则创建</li><li>根据hash计算出元素index(<code>length - 1 &amp; hash</code>效果等同于取模,效率提高),并处理null值</li><li>如果key存在,直接覆盖Value</li><li>判断是否为红黑树</li><li>判断是否为链表</li><li>判断是否需要扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//对key进行hash操作</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//1、如果table为null则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">//2、根据hash计算出元素index(效果等同于取模,效率提高),并处理null值</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//3、如果key存在,直接覆盖Value</span></span><br><span class="line">         <span class="keyword">if</span> (p。hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">//4、判断是否为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">//5、判断是否为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//链表大于阈值则转换为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//key存在直接覆盖</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.alue;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">//6、判断是否需要扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="五、JDK1-7的死循环问题"><a href="#五、JDK1-7的死循环问题" class="headerlink" title="五、JDK1.7的死循环问题"></a>五、JDK1.7的死循环问题</h1><p>扩容时，当线程A运行到<code>Entry&lt;K,V&gt; next = e.next</code>被挂起，线程B完成了扩容操作后，会出现<br>主要原因是新链表<code>头插</code>操作,导致<code>逆序</code>,JDK1.8之后改用<code>尾插</code>修复，但是仍然是线程不安全</p><h1 id="六、HashMap与HashTable的区别"><a href="#六、HashMap与HashTable的区别" class="headerlink" title="六、HashMap与HashTable的区别"></a>六、HashMap与HashTable的区别</h1><ul><li>HashTable不允许null作为key或者key，而HashMap允许</li><li>HashTable用synchronized实现了线程安全，HashMap不是线程安全的</li><li>HashTable的enumerator迭代器不是fail-fast的,HashMap的迭代器(Iterator)是fail-fast迭代器</li></ul><p>HashMap 内部使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值。HashTable 是直接使用 key 的 hashCode() 返回值作为 hash 值。</p><p>HashMap默认容量为 2^4 且容量一定是 2^n ; HashTable 默认容量是11,不一定是 2^n</p><p>HashTable 取哈希桶下标是直接用模运算,扩容时新容量是原来的2倍+1。HashMap 在扩容的时候是原来的两倍，且哈希桶的下标使用 &amp;运算代替了取模</p><blockquote><p><code>Java 8系列之重新认识HashMap</code> <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br><code>HashMap在JDK7和JDK8中的区别</code> <a href="https://zhuanlan.zhihu.com/p/59250175" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59250175</a><br><code>Map 综述（一）：彻头彻尾理解 HashMap</code> <a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/62893086</a><br><code>面试必备：HashMap源码解析（JDK8）</code> <a href="https://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="noopener">https://blog.csdn.net/zxt0601/article/details/77413921</a><br><code>解决哈希冲突的常用方法分析</code> <a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">https://www.jianshu.com/p/4d3cb99d7580</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(八) — 注解</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%85%AB)%20%E2%80%94%20%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%85%AB)%20%E2%80%94%20%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>注解可以用于描述类、接口、方法、方法参数、字段、局部变量等,准确来说是一种特殊的注释，但是配合上解析它的代码，想象空间就很大了，有以下</p><ul><li>格式检查</li><li><p>减少配置</p></li><li><p>减少重复工作</p></li></ul><h1 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h1><p>先来引入元注解的概念，<code>元注解</code>就是标注其他注解的注解。用于对其他注解进行限制</p><p>例子:Java内置的方法重写的注解<code>Override</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是Java提供的元注解</p><h2 id="1、-Target"><a href="#1、-Target" class="headerlink" title="1、@Target"></a>1、@Target</h2><p>这个注解用来约束注解可以描述的地方(类、方法等),其中<code>ElementType</code>就是它的取值范围</p><ul><li>TYPE: 类, 接口(包括注解), 或者枚举</li><li>FIELD：成员变量 (包括枚举类的常量)</li><li>METHOD：方法</li><li>PARAMETER：方法参数</li><li>CONSTRUCTOR：构造器</li><li>LOCAL_VARIABLE：局部变量</li><li>ANNOTATION_TYPE：注解</li><li>PACKAGE：包</li><li>TYPE_PARAMETER：类型参数,1.8新增，</li><li>TYPE_USE：类型使用,1.8新增，可以用于声明语句、泛型和强制转换语句中的类型</li></ul><p>默认未指定@Target时，表示任何地方都可以用,如果要使用多个，可以用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value=&#123;TYPE_USE, TYPE_PARAMETER&#125;)</span><br></pre></td></tr></table></figure><p>特别地，1.8新增的两个类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TYPE_PARAMETER 标注在类型参数上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;@<span class="title">Parameter</span> <span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TYPE_USE则可以用于标注任意类型(不包括class)</span></span><br><span class="line"><span class="comment">//用于父类或者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">implements</span> @<span class="title">Rectangular</span> <span class="title">Shape</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="meta">@Path</span> String(<span class="string">"/usr/bin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。</span></span><br><span class="line">String path=(<span class="meta">@Path</span> String)input;</span><br><span class="line"><span class="keyword">if</span>(input <span class="keyword">instanceof</span> <span class="meta">@Path</span> String)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> @Localized IOException.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用于通配符绑定</span></span></span><br><span class="line"><span class="function">List&lt;@ReadOnly ? extends Person&gt;</span></span><br><span class="line"><span class="function">List&lt;? extends @ReadOnly Person&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@NotNull String.class <span class="comment">//非法，不能标注class</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.lang.@NotNull String <span class="comment">//非法，不能标注import</span></span></span><br></pre></td></tr></table></figure></p><h2 id="2、-Retention"><a href="#2、-Retention" class="headerlink" title="2、@Retention"></a>2、@Retention</h2><p><code>@Retention</code>用来约束注解的声明周期</p><ul><li>SOURCE:源码级别，编译过后，注解会被丢弃</li><li>CLASS:类文件级别，注解在Class文件中可用，但是不会被JVM加载</li><li>RUNTIME:运行时级别，注解信息会在运行时保留，可以通过反射机制获取到注解上的信息</li></ul><h2 id="3、-Documented"><a href="#3、-Documented" class="headerlink" title="3、@Documented"></a>3、@Documented</h2><p>被<code>@Documented</code>修饰的元素会生成到<code>javadoc</code>中</p><p>生成命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc Documents.java</span><br></pre></td></tr></table></figure></p><h2 id="4、-Inherited"><a href="#4、-Inherited" class="headerlink" title="4、@Inherited"></a>4、@Inherited</h2><p><code>@Inherited</code>可以让注解被继承,真正的含义是可以让子类Class对象使用<code>getAnnotations()</code>获取父类被@Inherited修饰的注解</p><h2 id="三、注解元素及其数据类型"><a href="#三、注解元素及其数据类型" class="headerlink" title="三、注解元素及其数据类型"></a>三、注解元素及其数据类型</h2><p>像上面提到的<code>@Override</code>注解，内部没有定义其他元素，所以也叫<code>标记注解</code><br>在自定义注解中，一般会包含一些元素来表示某些值，方便注解处理器使用<br>如：自定义一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> IntegerVaule&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了一个int和String的元素</p><p>注解支持的元素类型还有</p><ul><li>基本数据类型</li><li>String</li><li>Class</li><li>Enum</li><li>Annotation</li><li>上述类型的数组</li></ul><p>元素的值必须<code>不为空</code>,也不接受null值，一般都会去定义一些特殊值作为默认值，空字符串或负数</p><p>如果某是元素是唯一的，那么使用时就不用<code>key=value</code>的方式</p><p>如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntegerVaule</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IntegerVaule</span>(value = <span class="number">10000</span>,name = <span class="string">"MONEY"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> money;</span><br></pre></td></tr></table></figure></p><p><code>IntegerVaule</code>反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntegerVaule</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，事实上这是个语法糖，编译之后会转换成接口，并且继承于<code>Annotation</code>,如果内部有其他的元素，会被转换成抽象方法</p><h2 id="四、1-8新增-Repeatable"><a href="#四、1-8新增-Repeatable" class="headerlink" title="四、1.8新增@Repeatable"></a>四、1.8新增@Repeatable</h2><p>在jdk1.8中，新增了<code>@Repeatable</code>这个元注解,主要用途是表示在同一个位置可以使用重复的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//添加可继承元注解</span></span><br><span class="line"><span class="meta">@Repeatable</span>(FilterPaths.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FilterPath &#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体表现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，反射机制也新增了一些API专门处理这个元注解</p><ul><li><code>getDeclaredAnnotationsByType</code>:返回此元素上的所有注解，不包括父类的注解</li><li><code>getAnnotationsByType</code>:如果当前类不存在指定注解，则在父类寻找返回，存在则直接返回子类，以<code>@FilterPath为例</code>，如果没有使用<code>Inherited</code>,也是不能获取父类的</li></ul><p>但是之前的API，<code>getDeclaredAnnotation()和 getAnnotation()</code>是不对<code>@Repeatable</code>处理的,所以无法获取 </p><h2 id="五、注解与反射-RUNTIME"><a href="#五、注解与反射-RUNTIME" class="headerlink" title="五、注解与反射(RUNTIME)"></a>五、注解与反射(RUNTIME)</h2><p>java内部的反射机制提供了<code>AnnotatedElement</code>这个接口及其一系列的API来获取注解上的信息，然后对信息进行处理，当然注解必须是<code>RUNTIME</code>级别的才能用到反射,下面是一些相关的API</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&lt; A extends Annotation&gt;</td><td style="text-align:center">getAnnotation(Class<a> annotationClass)</a></td><td style="text-align:center">返回指定类型的注解</td></tr><tr><td style="text-align:center">Annotation[]</td><td style="text-align:center">getAnnotations()</td><td style="text-align:center">返回此元素上所有注解,包括从父类继承的</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td><td style="text-align:center">判断指定类型的注解存在</td></tr><tr><td style="text-align:center">Annotation[]</td><td style="text-align:center">getDeclaredAnnotations()</td><td style="text-align:center">返回此元素上的所有注解，不包括父类的注解</td></tr></tbody></table><h1 id="六、注解处理器-CLASS"><a href="#六、注解处理器-CLASS" class="headerlink" title="六、注解处理器(CLASS)"></a>六、注解处理器(CLASS)</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Javac编译器的编译过程,大致可分为三个步骤：</p><ul><li>解析与填充符号表过程；</li><li>插入式注解处理器的注解处理过程；</li><li>语义分析与字节码生成过程。<br><img src="/media/15733011935978.jpg" alt=""></li></ul><blockquote><p>注解处理器的注解处理过程：<br>插入式注解处理器可以在编译器时<code>读取、修改、添加抽象语法树中</code>的任意元素。<br>如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程<code>重新处理</code>，直到所有的插入式注解处理器都没有再对语法树进行修改为止。</p></blockquote><p><code>注解处理器</code>可以在第二个阶段处理注解，通过继承AbstractProcessor的方式来实现。</p><h2 id="2、AbstractProcessor类"><a href="#2、AbstractProcessor类" class="headerlink" title="2、AbstractProcessor类"></a>2、AbstractProcessor类</h2><p>继承于<code>AbstractProcessor</code>的类可以实现属于自己的注解处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Types typeUtils;</span><br><span class="line">    <span class="keyword">private</span> Elements elementUtils;</span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line">    <span class="keyword">private</span> Messager messager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        elementUtils = env.getElementUtils();</span><br><span class="line">        filer = env.getFiler();</span><br><span class="line">        typeUtils = env.getTypeUtils();</span><br><span class="line">        messager = env.getMessager();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>init</code>：整个处理器被初始化的时候被调用。</li><li><code>process</code> 在每一次处理的时候被调用，如果处理器对语法树进行了修改，会多次调用</li><li><code>getSupportedAnnotationTypes</code> 返回能处理的注解的全名,1.6有注解SupportedAnnotationTypes</li><li><code>getSupportedSourceVersion</code> 返回能支持的代码版本,1.6之后有注解SupportedSourceVersion</li></ul><p>在<code>init</code>方法的入参有一个<code>ProcessingEnvironment</code>的对象，这里有提供几个工具类</p><ul><li>Elements：一个用来处理Element的工具类</li><li>Types：一个用来处理TypeMirror的工具类</li><li>Filer：这个工具可以支持向当前工程输出新的Java代码</li><li>Messager：可以让Javac编译器输出错误提示</li></ul><p>定义一个注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scaner &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修饰的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scaner</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScaner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scaner</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scaner</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="https://blog.csdn.net/lylwo317/article/details/52163304" target="_blank" rel="noopener">https://blog.csdn.net/lylwo317/article/details/52163304</a></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(七) — 反射</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%83)%20%E2%80%94%20%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%83)%20%E2%80%94%20%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>反射允许<code>运行中</code>的Java程序获取自身的信息,并且可以操作类或者对象的内部属性</p><p>反射主要提供以下功能</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><p>一般来说，反射主要用于框架开发相对较多,理解底层机制有助于丰富编程思想</p><h1 id="二、基本应用"><a href="#二、基本应用" class="headerlink" title="二、基本应用"></a>二、基本应用</h1><h2 id="1、获取Class对象"><a href="#1、获取Class对象" class="headerlink" title="1、获取Class对象"></a>1、获取Class对象</h2><ol><li><p>使用Class类的forName静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure></li><li><p>直接获取某一个对象的Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure></li><li><p>调用对象的getClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str= <span class="string">"string"</span>;</span><br><span class="line">Class&lt;? extends String&gt; strClass = str.getClass();</span><br></pre></td></tr></table></figure></li></ol><h2 id="2、判断是否为某个类的实例"><a href="#2、判断是否为某个类的实例" class="headerlink" title="2、判断是否为某个类的实例"></a>2、判断是否为某个类的实例</h2><p>有两种方法</p><ol><li>使用关键字instance of</li><li>Class对象的<code>isInstance</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3、创建实例"><a href="#3、创建实例" class="headerlink" title="3、创建实例"></a>3、创建实例</h2><p>有两种方法</p><ol><li>使用Class对象的<code>newInstance</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; strClass = String.class;</span><br><span class="line">String s = strClass.newInstance();</span><br></pre></td></tr></table></figure><ol start="2"><li>通过Class对象获取指定的<code>构造器Constructor</code>对象,再使用构造器的newInstance方法创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; strClass = String.class;</span><br><span class="line">Constructor strConstructor = strClass.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure><h2 id="4、获取方法"><a href="#4、获取方法" class="headerlink" title="4、获取方法"></a>4、获取方法</h2><p>通过Class的对象获取，主要有下面几个方法</p><ol><li><code>getDeclaredMethods</code>返回类或者接口声明的所有方法，包括所有修饰符的，不包括继承</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><ol start="2"><li><code>getDeclaredMethod</code>返回类或者接口声明的一个方法，包括所有修饰符的，不包括继承</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>getMethods</code>返回本身和父类所有<code>public</code>的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><ol><li><code>getMethod</code>返回本身或父类的一个public方法，第一个参数为方法名，后面为参数对应的Class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h2 id="5、获取构造器信息"><a href="#5、获取构造器信息" class="headerlink" title="5、获取构造器信息"></a>5、获取构造器信息</h2><p>主要是通过Class对象的<code>getConstructor</code>方法获得Constructor对象，而且Constructor的<code>newInstance</code>方法可以通过传入的参数调用对应构造器进行创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure><h2 id="6、获取类的成员变量信息"><a href="#6、获取类的成员变量信息" class="headerlink" title="6、获取类的成员变量信息"></a>6、获取类的成员变量信息</h2><p>与Method类似</p><p><code>getDeclaredFields</code>:返回类或者接口声明的所有成员变量，包括所有修饰符的，不包括继承<br><code>getDeclaredField</code>:返回类或者接口声明的一个成员变量，包括所有修饰符的，不包括继承<br><code>getFileds</code>:返回本身和父类所有<code>public</code>的成员变量<br><code>getFiled</code>:返回本身或父类的一个public成员变量，第一个参数为方法名，后面为参数对应的Class</p><h2 id="7、调用方法"><a href="#7、调用方法" class="headerlink" title="7、调用方法"></a>7、调用方法</h2><p>通过类获取到方法实例后，就可以使用<code>invoke</code>方法来调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure></p><p>需要点细节深入····</p><h2 id="8、创建数组"><a href="#8、创建数组" class="headerlink" title="8、创建数组"></a>8、创建数组</h2><p>直接通过Array类的newInstance方法创建,通过Array的set去添加内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h1><h1 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h1><p>反射会消耗一定的系统资源，非必要的情况下慎用，<br>并且反射调用方法会忽略权限检查，可能会破坏封装性导致安全问题</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(六) — 泛型</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%85%AD)%20%E2%80%94%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%85%AD)%20%E2%80%94%20%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>“泛型”简单的意思就是泛指的类型(<code>参数化类型</code>)。主要作用是限制只能往集合中添加<code>一种类型</code>的数据，让错误在<code>编译期</code>暴露，避免运行时异常的发生，提升代码的健壮性。</p><h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类定义时只需在类名后面加上<code>类型参数</code>，当然也可以添加多个参数，类似于&lt;T,S&gt;。这样就可以在类里面使用定义的类型参数。</p><h2 id="2、泛型方法"><a href="#2、泛型方法" class="headerlink" title="2、泛型方法"></a>2、泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;I&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法声明的方式就是在权限修饰符和返回值之间加上<code>&lt;I&gt;</code>或者任意其他的标识,而里面的<code>I</code>跟类<code>T</code>就算是用一样的标识，也不会是同一个类型，两者作用域不一样。</p><h2 id="3、泛型接口"><a href="#3、泛型接口" class="headerlink" title="3、泛型接口"></a>3、泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口在实现时，需要将实参传入，并且接口中使用了参数对应的地方类型也要与传入实参一致</p><h1 id="三、类型擦除"><a href="#三、类型擦除" class="headerlink" title="三、类型擦除"></a>三、类型擦除</h1><h2 id="1、描述"><a href="#1、描述" class="headerlink" title="1、描述"></a>1、描述</h2><p>泛型在设计时，为了兼容旧版本，Java使用了<code>类型擦除机制</code>。即泛型的参数类型只存在于编译期，运行期获取不到任何已经声明的类型信息,但是会保证类和参数内部参数类型一致。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class1.equals(class2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>泛型参数会被擦除到它的<code>第一边界</code>,如果没有边界。类型将被<code>擦除到Object</code><br>边界可以有多个，使用<code>extends</code>参数可以给参数类型添加一个边界<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line">    T desc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(T desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.descj = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> extends关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到Color类型。</p><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>在编译过程中，类型变量信息还能获取到，所以<code>set的时可以做类型检查</code>，非法类型不能通过编译<br>为了”还原”返回结果的类型，编译器在<code>get之后添加了类型转换</code></p><h2 id="3、缺陷与补救"><a href="#3、缺陷与补救" class="headerlink" title="3、缺陷与补救"></a>3、缺陷与补救</h2><p>泛型不能显示地运用在运行时类型的操作中，类似于转型、instance of和new，当然也有相应的方法替换</p><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>使用时，把类型参数的Class对象记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        classType=type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classType.isInstance(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GenericType&lt;A&gt; genericType=<span class="keyword">new</span> GenericType&lt;&gt;(A.class);</span><br><span class="line">System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> A()));</span><br><span class="line">System.out.println(genericType.isInstance(<span class="keyword">new</span> B()));</span><br></pre></td></tr></table></figure><h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p>使用工厂模式和泛型方法来创建实例对象。代码变动的话，添加新的工厂即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creater</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    instance=f.create();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer integer=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Creater&lt;Integer&gt; creater=<span class="keyword">new</span> Creater&lt;&gt;();</span><br><span class="line">System.out.println(creater.newInstance(<span class="keyword">new</span> IntegerFactory()));</span><br></pre></td></tr></table></figure><h1 id="四、泛型通配符"><a href="#四、泛型通配符" class="headerlink" title="四、泛型通配符"></a>四、泛型通配符</h1><h2 id="1、上界通配符"><a href="#1、上界通配符" class="headerlink" title="1、上界通配符"></a>1、上界通配符</h2><p><code>&lt;? extends C&gt;</code>这种形式的通配符，可以实现泛型的<code>向上转型</code>,以ArrayList为例，可以包含的元素就是<code>C</code>的一种子类型(包含C),称为<code>子类型边界</code></p><p>其中能使用的方法有<code>contains、indexOf</code>等形参为<code>Object</code>的方法，<br>还有<code>get</code>是可以，但是只能当做是<code>Object</code>处理<br>但是<code>add(T t)</code>就不行,因为不清楚集合里面的元素是什么类型，所以无法加入任何对象</p><h2 id="2、下界通配符"><a href="#2、下界通配符" class="headerlink" title="2、下界通配符"></a>2、下界通配符</h2><p><code>&lt;? super C&gt;</code>这种形式的通配符,以ArrayList为例，可以包含的元素就是<code>C</code>(包含C)的<code>超类型</code>,即从当前类的父类直至Object类,称为<code>超类型边界</code></p><p>而能使用的方法只是<code>add</code>,能插入的元素要么是A，要么是A的父类，<code>如果B和C继承于A,且A有一个父类D,那么D也是A和B的父类</code></p><p>不能<code>get</code>，因为不能确定操作的数据是属于哪种类型,除非拿出来当做<code>Object</code>处理</p><p>结合上下界通配符，可以这样写入元素,来自<code>Collectoins#copy</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; destination, List&lt;? extends T&gt; source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destination.size() &lt; source.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"destination.size() &lt; source.size(): "</span> +</span><br><span class="line">                destination.size() + <span class="string">" &lt; "</span> + source.size());</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;? extends T&gt; srcIt = source.iterator();</span><br><span class="line">    ListIterator&lt;? <span class="keyword">super</span> T&gt; destIt = destination.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (srcIt.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            destIt.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> AssertionError?</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source size "</span> + source.size() +</span><br><span class="line">                    <span class="string">" does not fit into destination"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        destIt.set(srcIt.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。<br>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(五) — 异常</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%BA%94)%20%E2%80%94%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%BA%94)%20%E2%80%94%20%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h1 id="一、异常分类"><a href="#一、异常分类" class="headerlink" title="一、异常分类"></a>一、异常分类</h1><h2 id="1、继承关系分类"><a href="#1、继承关系分类" class="headerlink" title="1、继承关系分类"></a>1、继承关系分类</h2><p><img src="/media/15572859400020.jpg" alt="15572859400020"></p><ul><li><code>Throwable</code>:所有异常的<code>基类</code>,指出了代码中可以用通过异常传播机制传输Java程序任何问题的<code>共性</code></li><li><code>Error</code>:是程序无法处理的错误，JVM出现的问题，例如:VirtualMachineError(JVM运行错误),OutOfMemoryError(内存不足),这些异常发生时,JVM一般会选择线程终止</li><li><code>Exception</code>:程序本身可以处理的错误，Exception还有一个重要的子类<code>RunTimeException</code>,<code>RunTimeException及其子类</code>用来表示<code>JVM常用操作</code>引发的错误(NullPointerException、ArithmeticException)</li></ul><h2 id="2、可查和不可查"><a href="#2、可查和不可查" class="headerlink" title="2、可查和不可查"></a>2、可查和不可查</h2><p>包含Exception和Error在内，Java异常可分为<code>可查异常</code>和<code>不可查异常</code></p><ul><li><code>可查异常</code>:在程序正常运行中允许发生的异常，并且<code>必须进行处理</code>，否则Java编译器不会通过.</li><li><code>不可查异常</code>:包含<code>RunTimeException及其子类</code>和<code>Error</code></li></ul><h2 id="3、运行时和非运行时"><a href="#3、运行时和非运行时" class="headerlink" title="3、运行时和非运行时"></a>3、运行时和非运行时</h2><ul><li><code>运行时异常</code>:都是<code>RunTimeException及其子类</code>,一般都是程序逻辑错误引起的异常，程序中可以选择捕获处理或者不处理，如NullPointerException、IndexOutOfBoundsException</li><li><code>非运行时异常(编译异常)</code>:RunTimeException以外的异常，必须处理的异常，否则编译不通过。如IOException、SQLException</li></ul><h1 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h1><h2 id="1、异常处理机制"><a href="#1、异常处理机制" class="headerlink" title="1、异常处理机制"></a>1、异常处理机制</h2><ul><li><code>抛出异常</code>:当一个方法引发异常时,方法创建异常对象并交付给运行时系统,异常对象中<code>包括异常类型和异常信息</code></li><li><code>捕获异常</code>:在抛出异常后，运行时系统就开始寻找合适的<code>异常处理器(exception handler)</code>,寻找的地方就是依次留在调用<code>方法栈中的方法的集合</code>,从发生异常的方法开始，依次回查栈中的方法，找到合适的异常处理器并执行，如果没找到，则运行时系统终止。同时也意味着Java程序终止</li></ul><h2 id="2、异常的处理方式"><a href="#2、异常的处理方式" class="headerlink" title="2、异常的处理方式"></a>2、异常的处理方式</h2><ul><li>RunTimeException:由运行时系统抛出，可以忽略，</li><li>Error:属于不允许发生情况，所以不捕捉</li><li>可查异常:必须捕捉、或者声明抛出</li></ul><h2 id="3、捕捉处理异常语句"><a href="#3、捕捉处理异常语句" class="headerlink" title="3、捕捉处理异常语句"></a>3、捕捉处理异常语句</h2><p>try-catch-finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try:用于捕捉异常,后接0~n个catch块，如果没有需要加finally</li><li>catch:用于处理捕捉到的异常</li><li>finally:无论是否捕捉到异常,都会执行,<code>如果try或者catch中有返回语句，那么finally会在返回之前执行</code></li></ul><p>以下四种情况finally不会被执行</p><ul><li>finally出现异常</li><li>前面代码使用System.exit()退出程序</li><li>程序所有线程死亡</li><li>关闭CPU</li></ul><h2 id="4、抛出异常-throws"><a href="#4、抛出异常-throws" class="headerlink" title="4、抛出异常 throws"></a>4、抛出异常 throws</h2><p>如果当前方法可能会出现异常而没有能力去处理，可以在方法声明处用<code>throws</code>抛出异常，给上一层处理</p><h3 id="抛出规则"><a href="#抛出规则" class="headerlink" title="抛出规则"></a>抛出规则</h3><ul><li>对于不可查异常，不抛出也能编译通过，但是在运行时会被系统抛出</li><li>可查异常，要么try-catch捕获，要么使用<code>throws</code>声明抛出</li><li>抛出异常之后，方法的调用者才能进行处理，当方法调用者无法处理，应当继续抛出</li></ul>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(四) — 枚举</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%9B%9B)%20%E2%80%94%20%E6%9E%9A%E4%B8%BE/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E5%9B%9B)%20%E2%80%94%20%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<h1 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h1><p>Enum实际上是一种特殊的类，编译后会转换成正常的类，如下简单定义一个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    WHITE,BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译后就会转换成一下的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变成了final类并继承与Enum</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">//前面定义的2种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color WHITE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        WHITE = <span class="keyword">new</span> Color(<span class="string">"WHITE"</span>, <span class="number">0</span>);</span><br><span class="line">        BLACK = <span class="keyword">new</span> Color(<span class="string">"BLACK"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</span><br><span class="line">            WHITE, BLACK</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Color[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(Color, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、常见方法"><a href="#二、常见方法" class="headerlink" title="二、常见方法"></a>二、常见方法</h1><table><thead><tr><th style="text-align:center">返回类型</th><th style="text-align:center">方法名称</th><th style="text-align:center">方法说明</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">compareTo(E o)</td><td style="text-align:center">比较此枚举与指定对象的顺序</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">equals(Object other)</td><td style="text-align:center">当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td style="text-align:center">Class&lt;?&gt;</td><td style="text-align:center">getDeclaringClass()</td><td style="text-align:center">返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">name()</td><td style="text-align:center">返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">ordinal()</td><td style="text-align:center">返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">toString()</td><td style="text-align:center">返回枚举常量的名称，它包含在声明中</td></tr><tr><td style="text-align:center">static&lt;T extends Enum<t>&gt; T</t></td><td style="text-align:center">static valueOf(Class<t> enumType, String name)</t></td><td style="text-align:center">返回带指定名称的指定枚举类型的枚举常量</td></tr></tbody></table><p>值得注意的是Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的</p><h1 id="三、进阶用法"><a href="#三、进阶用法" class="headerlink" title="三、进阶用法"></a>三、进阶用法</h1><h2 id="1、结合抽象方法"><a href="#1、结合抽象方法" class="headerlink" title="1、结合抽象方法"></a>1、结合抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    WHITE&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是白色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,BLACK &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是黑色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        String color = Color.WHITE.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、结合接口"><a href="#2、结合接口" class="headerlink" title="2、结合接口"></a>2、结合接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> DeepColor implements Color&#123;</span><br><span class="line">        DEEP_BLUE,DEEP_GREEN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> LightColor implements Color&#123;</span><br><span class="line">       LIGHT_BLUE,LIGHT_GREEN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argr[])</span></span>&#123;</span><br><span class="line">        Color color = Color.DeepColor.DEEP_BLUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、辅助类"><a href="#四、辅助类" class="headerlink" title="四、辅助类"></a>四、辅助类</h1><h2 id="1、EnumMap"><a href="#1、EnumMap" class="headerlink" title="1、EnumMap"></a>1、EnumMap</h2><p>key为Enum类型的Map</p><h2 id="2、EnumSet"><a href="#2、EnumSet" class="headerlink" title="2、EnumSet"></a>2、EnumSet</h2><p>元素只能为Enum的Set</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(三) — 字符串</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%89)%20%E2%80%94%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%89)%20%E2%80%94%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="一、String的不可变性"><a href="#一、String的不可变性" class="headerlink" title="一、String的不可变性"></a>一、String的不可变性</h1><p>咱们先来看一下String类中一些关键的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    /` The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    </span><br><span class="line">    /` Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>从上面代码中,首先知道的是String实际上内部维护的是<code>char数组</code>。这个数组和String一样，都用<code>final</code>修饰，证明String是不可变的和不可被继承的。也就是说,一旦String对象被创建，那么内部的<code>成员变量的值</code>包括<code>基本数据类型</code>都不能被改变,不能指向其他对象，指向的<code>对象的状态</code>也不能被改变。</p><p>那么这样设计的好处有什么呢?原因有以下</p><ol><li>只有当String是不可变时，<code>String常量池</code>才有可能实现,并且为heap节省了空间</li><li><code>网络安全</code>,否则黑客可以改变String指向的对象的值而造成安全漏洞问题</li><li><code>线程安全</code>,可以被多个线程共享</li><li><code>性能</code>,因为String不可变，所以String创建时的<code>hashcode也具有唯一性</code>，作为Map的键时比其他键对象快</li></ol><h1 id="二、常量池"><a href="#二、常量池" class="headerlink" title="二、常量池"></a>二、常量池</h1><blockquote><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，即<code>String Constant Pool(字符串常量池)</code></p></blockquote><p><code>常量池底层</code>方法是 <code>String#intern()</code> 使用StringTable数据结构保存字符串引用。StringTable是一个固定大小的Hashtable，默认大小是1009。基本逻辑与Java中<code>HashMap</code>相同，也使用拉链法解决碰撞问题。既然是拉链法，那么如果放进的String非常多，就会加剧碰撞，导致链表非常长。最坏情况下， <code>String#intern()</code> 的性能由O(1)退化到O(n)。</p><blockquote><p>深入解析String#intern<br><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote><p>在<code>JDK6</code>的版本中，String Pool使用固定容量的<code>HashMap</code>实现并存储在<code>永久代</code>中的，后面变为可配置，因为永久带内存有限，所以在<code>JDK7</code>开始就移动到<code>heap(堆内存)</code>中,这就意味着你可以通过调整堆大小来调整应用程序,通过<code>JVM参数-XX:StringTableSize</code>可以调整String常量池的大小(质数),同样的Size，处理的量越大就越慢，不同的Size，越大性能越好</p><hr><p>创建字符串对象的方式有两种</p><ol><li>通过字面常量赋值</li><li>通过new关键字新建字符串对象</li></ol><p>这两种方式在性能和内存占用上存在差别，下面来看一下这两种方式还有其他的一些情况下JVM中发生了什么</p><h2 id="1、字面常量赋值"><a href="#1、字面常量赋值" class="headerlink" title="1、字面常量赋值"></a>1、字面常量赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"ab"</span>+<span class="string">"c"</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>常量折叠:这里穿插一个概念，由于编译期的优化，对于用”+”连接的字面常量会在编译器直接并起来.比如上例的<br>String s2 =”ab”+”c”;会在编译器被优化成 String s2 = “abc”;</p></blockquote><p>采用字面常量去创建一个字符串时，JVM会在运行时常量池寻找有没有该字符串，有则直接返回常量池中的引用，没有就直接在常量池中创建该字符串，然后返回引用。所以上例的<code>s1和s2</code>指向的都是同一个对象，用 <code>==</code> 比较就会返回<code>true</code>,我们也可以通过<code>字节码</code>来进一步确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt; </span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当调用<code>ldc #2</code>,如果 <code>#2</code> 的symbol还没解析，则会调用C++底层的 <code>StringTable::intern</code> 方法生成char数组，并将引用保存在 <code>StringTable和常量池中</code>，当下次调用 <code>ldc #2</code>,通过将常量池中 <code>#2</code>对应的字符串推送到栈顶获取到 <code>&quot;abc&quot;</code>，避免再次到StringTable中查找。<code>astore_1</code> 将 <code>&quot;abc&quot;</code> 保存到 <code>局部变量</code></p><h2 id="2、使用new关键字新建"><a href="#2、使用new关键字新建" class="headerlink" title="2、使用new关键字新建"></a>2、使用new关键字新建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们来分析一下发生了什么<br>①因为”abc”是用<code>字面常量</code>定义了，所以JVM会在运行时常量池中寻找，有则进入②，没有则创建然后进入<br>②由于使用了<code>new</code>，所以JVM会在 <code>heap(堆)</code> 中创建一个内容相同的String对象，然后返回堆中String对象的引用</p><p>下面是new String(“abc”)字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 ldc #3 &lt;abc&gt;  </span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>所以<code>s3</code>指向的是<code>堆</code>中的对象，<code>s4</code>指向的是<code>常量池</code>中的对象,虽然内容相同，但是<code>==</code>比较的是对象，所以为<code>false</code></p><h2 id="3、使用变量连接的情况"><a href="#3、使用变量连接的情况" class="headerlink" title="3、使用变量连接的情况"></a>3、使用变量连接的情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"ab"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>重点在s6,因为s5是一个变量，即使我们知道这个值，但是JVM仍然认为这是一个变量，所以在<code>编译期</code>，这个值是<code>未知</code>的。在运行期，JVM就在 <code>heap(堆)</code> 中创建了一个内容为”abc”的对象并返回给s6<br>而”ab”和”c”是以字面常量的形式定义的，所以会在常量池中出现.</p><p>下面是字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;ab&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> 3 new #3 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> 7 invokespecial #4 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">14 ldc #6 &lt;c&gt;</span><br><span class="line">16 invokevirtual #5 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 invokevirtual #7 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>从字节码中也可以看出来，字符串变量的<code>连接</code>动作，在编译期会被转化成<code>StringBuilder的append操作</code></p><h2 id="4、使用final关键字修饰String"><a href="#4、使用final关键字修饰String" class="headerlink" title="4、使用final关键字修饰String"></a>4、使用final关键字修饰String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String s7 = <span class="string">"ab"</span>;</span><br><span class="line">String s8 = s7 + <span class="string">"c"</span>;</span><br></pre></td></tr></table></figure><p>在这种情况下,<code>final</code>修饰的s7被视为一个常量,所以常量池里会有”ab”,s7在编译期已经是确定了，所以s7+”c”连接后的字符串s8会在常量池中出现，也就是”abc”</p><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;ab&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #3 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><h1 id="三、StringBuilder和StringBuffer"><a href="#三、StringBuilder和StringBuffer" class="headerlink" title="三、StringBuilder和StringBuffer"></a>三、StringBuilder和StringBuffer</h1><ol><li>String是字符串 <code>常量</code>，而 StringBuilder和StringBuffer都是字符串 <code>变量</code></li><li>StringBuilder是 <code>线程不安全</code> 的，而StringBuffer是 <code>线程安全</code> 的(append方法使用了synchronized修饰)，所以StringBuilder的效率比StringBuffer高</li><li>String每次修改操作都要在堆内存中new一个对象，而StringBuffer和StringBuilder不用，并且提供了一定的缓存功能，默认<code>16个字节数组</code>的大小。扩容就<code>原来的大小 x 2 + 2</code>,可以考虑初始化StringBuilder的大小来提高代码的效率。</li></ol><h1 id="四、一些题目"><a href="#四、一些题目" class="headerlink" title="四、一些题目"></a>四、一些题目</h1><p>下面程序运行的结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer(s1);</span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">//false String的equals有对参数进行instance of String判断</span></span><br><span class="line"></span><br><span class="line">StringBuffer s3 = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s3.equals(<span class="string">"abc"</span>));  <span class="comment">//StringBuffer没有重写equals方法，实际上是 == 比较对象,StringBuilder也是</span></span><br><span class="line">System.out.println(s3.toString().equals(<span class="string">"abc"</span>)); <span class="comment">//true 比较的是值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">0</span>));   <span class="comment">//true,如果subString的index是0，直接返回对象</span></span><br><span class="line">System.out.println(<span class="string">"abc"</span>==s4.subString(<span class="number">1</span>));   <span class="comment">//false,不为0就new一个sub之后的对象返回</span></span><br></pre></td></tr></table></figure></p><p>除此之外,<code>toLowerCase</code>和<code>toUpperCase</code>都是new一个对象返回</p><hr><p>下面语句一共创建了多少个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure></p><p>这是一道有歧义的题，因为没有说明时机，实际上可以问涉及到几个，答案是<code>两个</code>,一个是在类加载过程中在常量池里面创建的”abc”对象，另外一个是运行期间创建在堆内存的”abc”对象。</p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(二) — 基本数据类型.md</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%BA%8C)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%BA%8C)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h2><p>以下是八大基本数据类型大小、取值、默认值、对应包装类信息</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">大小</th><th style="text-align:center">封装类</th><th style="text-align:center">默认值</th><th style="text-align:center">可表示数据范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Byte</td><td style="text-align:center">0</td><td style="text-align:center">-128~127(2^7)</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Short</td><td style="text-align:center">0</td><td style="text-align:center">-32768~32767(2^15)</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Integer</td><td style="text-align:center">0</td><td style="text-align:center">-2147483648 ~ 2147483647(2^31)</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Long</td><td style="text-align:center">0L</td><td style="text-align:center">-9223372036854775808 ~ 9223372036854775807 (2^63)</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">java.lang.Float</td><td style="text-align:center">0F</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">java.lang.Double</td><td style="text-align:center">0D</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">java.lang.Character</td><td style="text-align:center">空</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">8</td><td style="text-align:center">java.lang.Boolean</td><td style="text-align:center">false</td><td style="text-align:center">true或false</td></tr></tbody></table><blockquote><p>包装类有对应最小值、最大值和大小的常量,如:<br><code>Integer.MIN_VALUE</code><br><code>Integer.MAX_VALUE</code><br><code>Integer.SIZE</code></p></blockquote><p>进一步可以分为以下<code>四类</code></p><ul><li>整型：byte(字节型)、short(短整型)、int(整型)、long(长整型)</li><li>浮点型：float(单精度浮点型)、double(双精度浮点型) </li><li>逻辑型：boolean(布尔型)</li><li>字符型：char(字符型)</li></ul><h2 id="二、数据类型转换"><a href="#二、数据类型转换" class="headerlink" title="二、数据类型转换"></a>二、数据类型转换</h2><p>根据<code>取值范围的大小</code>将数据类型排序,数据类型的转换也跟这个排序有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">short</span> -&gt; <span class="keyword">int</span> -&gt; <span class="keyword">long</span> -&gt; <span class="keyword">float</span> -&gt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>数据类型之间的转换分为两种<code>自动转换</code>和 <code>强制转换</code></p><h3 id="1、自动转换"><a href="#1、自动转换" class="headerlink" title="1、自动转换"></a>1、自动转换</h3><p>在表达式中,当较”小”的数据与较”大”的数据一起进行运算时，系统会自动将”小”的数据转换成”大”的数据再进行运算<br>在调用方式时,如果<code>实参比形参&quot;小&quot;</code>,也会将”小”的数据转换成”大”的数据</p><p>在表达式中，数据类型会出现<code>自动提升</code>，规则如下</p><ol><li>所有的byte,short,char的值将被提升为int</li><li>如果有一个操作数是long，计算结果是long</li><li>如果有一个操作数是float，计算结果是float</li><li>如果有一个操作数是double，计算结果是double</li></ol><h3 id="2、强制转换"><a href="#2、强制转换" class="headerlink" title="2、强制转换"></a>2、强制转换</h3><p>将”大”数据转换成”小”数据时，就需要强制转换,并且会损失精度</p><h2 id="三、包装类"><a href="#三、包装类" class="headerlink" title="三、包装类"></a>三、包装类</h2><p>java为每个基本数据类型都提供了包装类，包装类的默认值是null，并且内部提供了一些相关的操作方法。基本类型如int,直接在<code>栈中分配空间</code>,存储数值<br>包装类是对象，需要在<code>堆内存中分配空间</code>,栈中存放着对应的堆空间地址</p><p>在JDK1.5以后，提供了<code>自动装箱</code>和<code>自动拆箱</code>功能这样的”语法糖”</p><h3 id="1、自动装箱"><a href="#1、自动装箱" class="headerlink" title="1、自动装箱"></a>1、自动装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自动装箱</span></span><br><span class="line">Integer i = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//转换成了</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//所以,如果给i赋值null，再赋值给基本数据类型，就会导致NullPointerException</span></span><br></pre></td></tr></table></figure><p>从字节码看出也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> iconst_1</span><br><span class="line"> 6 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">9</span> astore_2</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="2、自动拆箱"><a href="#2、自动拆箱" class="headerlink" title="2、自动拆箱"></a>2、自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自动拆箱, 在表达式中只要有一个不是包装类型的都会自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="comment">//后面一句转换成了</span></span><br><span class="line"><span class="keyword">int</span> j = i.intValue();</span><br></pre></td></tr></table></figure><p>下面是字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> aload_1</span><br><span class="line"> 6 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"> <span class="number">9</span> istore_2</span><br><span class="line"><span class="number">10</span> aload_1</span><br><span class="line">11 invokevirtual #3 &lt;java/lang/Integer.intValue&gt;</span><br><span class="line"><span class="number">14</span> istore_3</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>由此也可以看出，自动拆装箱属于<code>编译特性</code></p><h3 id="3、缓存池"><a href="#3、缓存池" class="headerlink" title="3、缓存池"></a>3、缓存池</h3><p>在包装类中,为了<code>避免频繁地创建和销毁对象</code>，就有缓存池的出现，下面是各个包装类对应缓存池的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>根据代码可以得知包装类的缓存池规则</p><ul><li><code>Byte</code>都是用缓存池里面的值</li><li><code>Short、Integer、Long</code>会缓存 <code>-128~127</code></li><li><code>Float和Double</code>则直接返回，因为精度数不能每次都一样，所以缓存没有意义</li><li><code>Character</code>则是缓存 <code>&lt;=127</code></li><li><code>Boolean</code>,只有两个值，直接就用常量的形式表示出来</li></ul><h2 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h2><ul><li>double和float，不能完全表示精度。如 : 3 x 0.1 = 0.3 ,这样会是<code>false</code>,所以在进行带精度计算时，需要用到<code>BigDecimal</code></li><li>switch中只能用byte、char、short、int，JDK1.7后可用String</li><li>Java中的数值运算最低要求是int类型，如果参与运算的变量类型都没有超过int类型，则它们都会被自动升级为int类型再进行运算，所以它们运算后的结果类型也是int类型</li><li>两边都是包装类的<code>equals</code>比较值，<code>==</code> 比较引用，其中一边是表达式的，<code>==</code> 就是比较值</li><li>char存储的是<code>unicode编码字符</code>，汉字也是unicode所以可以存储，但是一些生僻字不在unicode编码字符集中就不能显示(<a href="https://blog.csdn.net/BuquTianya/article/details/80685437" target="_blank" rel="noopener">拓展资料</a>)</li></ul><h2 id="五、题目"><a href="#五、题目" class="headerlink" title="五、题目"></a>五、题目</h2><p>下面语句做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>; <span class="comment">//valueOf()自动装箱成Integer类型</span></span><br><span class="line">i+=<span class="number">1</span>;<span class="comment">//先是将Integer类型的i自动拆箱成int，完成加法运算后再自动装箱成Integer</span></span><br></pre></td></tr></table></figure></p><hr><p>下面程序语句有什么问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;  <span class="comment">//编译不通过、需要强转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s2 =<span class="number">1</span>;</span><br><span class="line">s2 += <span class="number">1</span>;  <span class="comment">//正常编译,自动做了类型转换</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//NullPointException</span></span><br></pre></td></tr></table></figure></p><hr><p>下面程序的运行结果是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//false 比较了对象</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">//true 缓存了-128~127</span></span><br><span class="line"></span><br><span class="line">Float f1 = <span class="number">1f</span>;</span><br><span class="line">Float f2 = <span class="number">1f</span>;</span><br><span class="line">System.out.println(f1 == f2) <span class="comment">//false 始终new新对象</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java基础(一) — 语法</title>
      <link href="/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/11/04/Java/Basic/Java%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>继承性是类的一种层次模型，提供了明确表述<code>共性</code>的方法,对象的新类在类中继承派生。类可以从他的基类<code>继承</code>方法和实例变量，并且类可以<code>修改或者增加</code>新的方法使之更适合特殊的需要</p><p><code>关键字:extends、class</code></p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性是对象在<code>不同时刻</code>表现出来的多种状态,是一种<code>编译时期状态</code>和<code>运行时期状态</code>不一致的现象，多态包括<code>参数多态</code>和<code>包含多态</code></p><p><code>关键字:interface</code></p><h3 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h3><p>抽象是指对一类事物的高度提炼以得到的<code>共性</code>部分,抽象不需要了解全部细节，只是一种通用的描述<code>约束</code>,抽象可以是<code>过程抽象</code>或者<code>数据抽象</code></p><p><code>关键字:abstract</code></p><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>封装性是把过程和数据保卫起来使得数据的访问只能通过已定义的接口，保证了对象被访问只能通过已定义的接口，保证了对象被访问的<code>隐私性和可靠性</code></p><blockquote><p>面向对象的特性:更多的实践使用就是设计模式</p></blockquote><h2 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h2><p>编写 Java 程序时，应注意以下几点：</p><ul><li>大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</li><li>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</li><li>主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。</li></ul><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 <code>Java 标识符</code>，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h1 id="三、对象与类"><a href="#三、对象与类" class="headerlink" title="三、对象与类"></a>三、对象与类</h1><h2 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h2><p>类是描述一类对象的行为和状态,可以看作是创建对象的模板,如下是类的基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">  String breed;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String color;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">barking</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类可以包含一下类型的变量</p><ul><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><h2 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h2><p>每个类都有<code>构造方法</code>。如果没有<code>显式</code>地为类定义构造方法，Java编译器将会为该类<code>提供一个默认构造方法</code>。<br>在创建一个对象的时候，<code>至少</code>要调用一个构造方法。构造方法的名称必须与<code>类同名</code>，一个类可以有<code>多个</code>构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><p>对象是类的一个实例，有状态和行为。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步</p><ul><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字new来创建一个对象。</li><li>初始化：使用new创建对象时，会调用构造方法初始化对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">"小狗的名字是 : "</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出<code>小狗的名字是 : tommy</code></p><h2 id="4、源文件声明规则"><a href="#4、源文件声明规则" class="headerlink" title="4、源文件声明规则"></a>4、源文件声明规则</h2><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和public类的类名保持一致。</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><p><code>包</code>主要用来对类和接口进行分类<br><code>Import</code>语句就是用来提供一个合理的路径，使得编译器可以找到某个类</p><h1 id="四、基础修饰符"><a href="#四、基础修饰符" class="headerlink" title="四、基础修饰符"></a>四、基础修饰符</h1><h2 id="1、权限修饰符"><a href="#1、权限修饰符" class="headerlink" title="1、权限修饰符"></a>1、权限修饰符</h2><ul><li><code>private</code>:只能在定义它们的类中使用，在其他类中不能调用。</li><li><code>缺省(default)</code>:只能在定义它们的类中，以及同包的类中被调用</li><li><code>protected</code>:能在同包的类中被调用。不同包的类想调用它们，这个类必须是定义它们的类的子类</li><li><code>public</code>:可以在任何一个类中被调用</li></ul><h2 id="2、final"><a href="#2、final" class="headerlink" title="2、final"></a>2、final</h2><p>①<code>类</code>被声明为final则不能再派生出新的类,所以一个类不能既被声明为abstract又被声明为final</p><p>②<code>变量</code>被声明为final,必须在声明时初始化，且只能读取不能修改</p><p>③<code>方法</code>被声明为final,不能被<code>重载</code></p><blockquote><p>一般会使用final和static组合来定义常量</p></blockquote><h2 id="3、static"><a href="#3、static" class="headerlink" title="3、static"></a>3、static</h2><p><code>static</code>可以用来修饰的类成员变量、成员方法、代码块,将独立于对象</p><ol><li>被修饰的元素只要类被加载了就可以通过类名访问(当然，只要权限也可以通过对象访问)</li><li><code>静态方法</code>不能访问类的非静态方法和成员变量</li><li><code>静态成员变量</code>会被所有的对象<code>共享</code></li><li><code>静态代码块</code>会在类初始化的时候被运行一次，可以放置一些只运行一次的初始化操作</li></ol><h2 id="4、this和super"><a href="#4、this和super" class="headerlink" title="4、this和super"></a>4、this和super</h2><p><code>this</code>为当前类的引用对象，应用场景</p><ul><li>构造方法:通过this的调用同类中指定参数类型的构造方法<code>this(参数列表)</code>,只能用在构造方法体的第一行</li><li>变量:当成员变量与局部变量重名，使用this特指<code>成员变量</code></li><li>方法:在方法中引用该方法所属类的当前对象，注意不能用于static方法(this对象级别，static类级别)</li></ul><hr><p><code>super</code>为父类存储空间标识</p><ul><li>构造方法:在子类构造方法中调用父类构造方法<code>super(参数列表)</code>,同样只能在构造方法体的第一行</li></ul><h2 id="5、instance-of"><a href="#5、instance-of" class="headerlink" title="5、instance of"></a>5、instance of</h2><p>instance of运算符是用来在运行时指出对象是否是特定类的一个实例</p><h1 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h1><p>广泛意义上的内部类一般来说包括这四种：<code>成员内部类、局部内部类、匿名内部类和静态内部类。</code>，内部类实际上也是一种类，语法糖</p><h2 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h2><p>成员内部类，位于另一个类的内部，类似于成员变量这样的作用域<br>下面的<code>Draw</code>就是<code>成员内部类</code>,相对来说<code>Circle</code>就是外部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成员内部类可以<code>无条件访问外部类的所有</code>成员属性和成员方法（包括private成员和静态成员）。</p><p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生<code>隐藏现象</code>，即<code>默</code>认情况下访问的是<code>成员内部类的成员</code>。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure></p><p>如果在外部类内要访问内部类，必须要<code>new</code></p><p>成员内部类是<code>依附</code>外部类而存在的，也就是说，如果要在外部类以外创建成员内部类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner inner = outter.new Inner();</span><br></pre></td></tr></table></figure></p><p>并且成员内部类还可以使用任何权限修饰符修饰，并起到相应的作用</p><p>成员内部类可以<code>无条件访问外部类</code>的原因，通过反编译，可以看到内部类的<code>构造方法持有外部类的引用</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outter$Inner(Outter);</span><br></pre></td></tr></table></figure></p><h2 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h2><p><code>局部内部类</code>是定义在<code>一个方法或者一个作用域</code>里面的类，它和成员内部类的区别在于局部内部类的访问<code>仅限于方法内或者该作用域内</code>,类似于一个<code>局部变量</code>,不能有权限修饰符或者static<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h2><p>大部分匿名内部类用于<code>接口回调</code>,类似于按钮监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnScan.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>匿名内部类在编译的时候由系统起类似<code>Outter$1.class</code>这样的名</p><p>局部内部类和匿名内部类<code>只能访问局部final变量</code>的原因<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，Java采用了<code>复制</code>的手段来解决。<br>如果run的过程中<code>修改</code>了变量a的值，就会出现<code>数据不一致</code>的问题，所以的局部变量和形参都必须用<code>final</code>进行限定，不允许对变量进行修改</p><h2 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个<code>static</code>关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态内部类是<code>不需要依赖于外部类的</code>，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法</p><h1 id="六、方法的重写和重载"><a href="#六、方法的重写和重载" class="headerlink" title="六、方法的重写和重载"></a>六、方法的重写和重载</h1><h2 id="1、重写"><a href="#1、重写" class="headerlink" title="1、重写"></a>1、重写</h2><p>子类对<code>父类允许访问的方法</code>的方法体进行覆盖并重新实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></span><br><span class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></span><br><span class="line"></span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、重载"><a href="#2、重载" class="headerlink" title="2、重载"></a>2、重载</h2><p>重载是在一个类里面，方法名字相同,而<code>参数的类型和个数</code>不同的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1、变长参数"><a href="#1、变长参数" class="headerlink" title="1、变长参数"></a>1、变长参数</h2><p>在Java方法里，允许存在变长参数，但是一个方法只能有一个变长参数，且是该方法的最后一个参数，使用方法像下面一样，用<code>...</code>表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、自增自减运算符"><a href="#2、自增自减运算符" class="headerlink" title="2、自增自减运算符"></a>2、自增自减运算符</h2><p>这里主要需要注意一个陷阱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>count++是一个有返回值的表达式，<code>返回值</code>是count自加之前的值，具体步骤是</p><ol><li>JVM把count值拷贝到临时变量区(0)</li><li>count值加1,此时count为(1)</li><li>返回临时变量区的值(0)</li><li>此时count被重置为0</li></ol><p>也就是不管count = count++多少次，count的值,都是一样。 </p><p>Java默认的自增自减运算符是线程不安全的，可以通过以下方法进行实现线程安全</p><ol><li>synchronized代码块或者方法</li><li>使用Lock锁</li><li>使用JDK提供的线程安全类<code>AtomicInteger</code>(推荐)</li></ol>]]></content>
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/JVM%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/03/24/Java/JVM/JVM%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<h1 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h1><p>主流的实现中使用的都是<code>可达性分析(Reachability Analysis)</code></p><p>基本思想是,以一系列称为<code>GC Roots</code>的对象作为起始点,从这些节点往下开始搜索，搜索所走过的路称为<code>引用链</code>,当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用</p><p>在Java语言中,可作为GC Roots的对象包括</p><ol><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol><p>即使通过可达性分析算法中<code>不可达的对象</code>，并非”非死不可”。<br>真正要宣告一个对象死亡，至少要经历两次标记过程</p><p>通过可达性分析被发现不可达后就会被标记，并且进行一次筛选<br>筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，判断条件如下</p><ol><li>当对象没有覆盖finalize方法</li><li>已经被虚拟机执行过了</li></ol><p>这两种情况都没有必要执行</p><p>如果对象被判断有必要执行，那么这个对象就会被放置到一个<code>F-Queue</code>中，并且由虚拟机创建一个低优先级的Finalizer执行。注意这里只会是触发，不会等待运行结束。</p><p>如果在finalize过程中与引用链中的对上建立了联系，那么这个对象就不会被回收。<br>反之则会被第二次标记，进行回收</p><p>需要注意的是，任何对象的<code>finalize</code>方法只会被执行一次，面对下一次回收就不会被执行了</p><h2 id="回收方法区-永久代"><a href="#回收方法区-永久代" class="headerlink" title="回收方法区(永久代)"></a>回收方法区(永久代)</h2><p>永久代的垃圾回收主要回收两部分</p><ol><li>废弃常量</li><li>无用的类</li></ol><p>废弃常量，以常量池中的字面量为例，<br>比如字符串“abc”,如果当前系统中没有任何一个String对象是”abc”,那就会被清出常量池</p><p>要清出无用的类需要满足下面3个条件</p><ol><li>该类所有的实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问</li></ol><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>分为”标记”和”清除”两个阶段。首先标记处所有需要回收的对象，标记完成后统一回收所有被标记的对象，标记的算法就是之前说的可达性算法。</p><p>这是最基础的收集算法,因为后续的算法都是基于这种思路并且对其不足进行优化，主要的不足有两个</p><ol><li>效率<br>标记和清除两个过程的效率都不高</li><li>空间<br>标记清除之后会产生大量不连续的内存碎片。空间碎片太多会到导致后面需要分配大对象时，无法获得连续的内存而不得触发另一次垃圾回收</li></ol><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题而出现，它将可用内存按容量划分为<code>相等大小的两块</code>，每次只使用其中一块，当着一块用完了，就把存活的对象复制到另一快，然后把使用过的内存空间一次清理</p><p>目前的商业虚拟机都采用的这种手机算法来回收新生代<br>将内存分为一块较大的<code>Eden空间和两块小的Survivor</code>,每次使用Eden和其中一块Survivor<br>当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一个Survivor，最后清理Eden和之前的Survivor，Eden和Survivor的比例是8:1<br>因为无法保证回收时存活的对象少于10%，Survivor的空间不足时，需要依赖其他的内存进行<code>分配担保</code><br>那么这些对象将直接通过分配担保机制进入老年代。<del>~</del>to be continue</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时，需要较多的复制操作，效率会变低。<br>另外，如果不想浪费50%的空间，就需要额外的空间做分配担保，应对对象100%存活率的极端<br>标记还是使用可达性算法，整理是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>一般是把Java堆分为新生代和老年代<br>新生代，每次垃圾手机时都发现有大批对象死去，只有少量存活，那就复制<code>复制算法</code><br>老年代，因为存活率高，没有额外的空间分配担保，必须使用<code>标记清理或标记整理算法</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/03/24/Java/JVM/HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h1><p>在可达性分析中，可作为GC Roots的节点主要在<code>全局性的引用(常量或类静态属性)与执行上下文(栈帧中的局部变量表)</code>中<br>但是现在应用仅仅方法区就数百兆，要逐个检查完，那么必然消耗很多时间。</p><p>而且在这个工作还需要进行GC停顿，因为这项分析工作必须能<code>保持一致性</code>，就是不可以在分析过程中对象的关系还在变化</p><p>目前主流的Java虚拟机使用的都是准确式GC，也就是当执行系统停顿下来后，虚拟机有办法直接得知哪些方法存放着这些对象引用，hotspot中使用一组称为<code>OopMap</code>的数据结构来达到这个目的。<br>在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就直接知道这些信息了。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>需要关注的一个点事，如果为每一条指令都生成对应的OopMap，会需要大量的额外空间,但是hotspot很显然并没有这样做，只是在<code>特定的位置</code>记录了这些信息，而这些位置称为安全点。即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p><p>安全点选定的标准是，<code>是否具有让程序长时间运行的特征</code></p><p>另外一个需要考虑的问题，如何在GC发生时让所有线程，都跑到最近的安全点上再停顿下来，两种方案</p><ol><li>抢先式中断<br>GC发生时，把所有的线程中断，如果现有的线程中断不在安全点上，就恢复线程让它跑到安全点上(弃用)</li><li>主动式中断<br>设置一个标志，各个线程在执行时主动去轮询这个标志，发现中断标志就自挂东南枝。<br>实际情况会有线程处于block或sleep的状态,无法走到中断标志，这时候就需要<code>安全区域</code></li></ol><p>安全区域指的是，在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的，</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/03/24/Java/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><h5 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h5><p>当虚拟机遇到一条new指令时(克隆，反序列化)，首先检查这个<code>指令的参数是否能在常量池</code>中定位到一个<code>类的符号引用</code>,检查有没有被加载,解析和初始化过，如果没有，在执行相应的类加载的过程（疑问）</p><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><p>接下来虚拟机会为新生对象<code>分配内存</code>，分配的方式有两种</p><ol><li>指针碰撞<br>内存规整，用指针分开已用内存和空闲内存</li><li>空闲列表<br>内存不规整，维护一个列表记录空闲的内存</li></ol><p>防止并发</p><blockquote><p>虚拟机会使用CAS配上失败重试的方式保持更新的原子性</p></blockquote><p>还有另外一种方法，在每个线程的Java栈中分配一小块内存，称为<code>本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</code>，哪个线程需要分配内存，就在TLAB上分配，内存用完了,同步锁定<br>是否使用TLAB，可以通过 <code>-XX:+/-UserTLAB</code>参数设定</p><p>分配完成之后，分配到的内存空间都会被<code>初始化为零</code>,并且为<code>对象头赋值</code>,从虚拟机的层面来说已经创建完成了</p><p>接下来执行<code>&lt;init&gt;</code>方法，按照程序员的意愿进行初始化</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在内存中存储的布局可以分为3块区域:<code>对象头、实例数据、对齐填充</code></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头分两部分信息</p><ol><li>对象自身的运行时数据(Mark Word)<br>Hash码,GC分代年龄，锁状态标志，线程持有的锁，偏向锁线程ID，偏向时戳</li><li>类型指针，指向它的类元数据的指针</li></ol><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储着程序代码中定义的各种类型的字段内容,包括父类的。</p><p>存储顺序收到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java中定义的顺序影响<br>hotspot默认是longs/doubles,ints,shorts/chars,bytes/boolean,oops(Ordinary Object Pointers),也就是宽度的字段会分配到一起，在满足这个条件的情况下，父类定义的变量会在子类之前</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>这部分不是不然存在的，也没有特殊含义，起到占位符的作用，对象大小必须为8字节的倍数，不够就补齐</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过什么方式去定位<br>实际上主流的方式有两种</p><ol><li><p>使用句柄<br>这种方式会在Java堆中划分出一块内存作为句柄池,栈中的引用指向的就是对象的句柄地址<br>而句柄中包含了对象实例数据与类型数据各自的地址信息<br><img src="/media/15722712326856.jpg" alt=""></p></li><li><p>直接指针访问<br>这种方式存储的直接就是对象地址<br><img src="/media/15722712075007.jpg" alt=""></p></li></ol><p>两种方式各有优势，使用句柄访问好处是对象被移动的时候，只需要修改句柄的实例数据指针<br>直接指针访问最大的好处就是速度快</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java项目基础模板</title>
      <link href="/2019/03/24/Java/JVM/Java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/03/24/Java/JVM/Java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>功能</p><ol><li>鉴权</li><li>全局异常处理</li></ol><p>一、代码辅助类</p><ol><li>lombok 代码简化</li><li>freemaker 生成代码引擎</li></ol><p>二、监控类</p><ol><li>log4j 日志输出</li></ol>]]></content>
      
      <categories>
          
          <category> Java项目 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/03/24/Java/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>最原始的收集器，用于新生代,单线程,没有线程交互的开销<br>对于用在Client模式下的虚拟机是一个很好的选择</p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>这个实际上就是Serial收集器的多线程版本<br>对于用在Server模式下的虚拟机的首选<br>而且除了Serial收集器以外，只有ParNew能于CMS收集器(并发收集器)配合工作</p><blockquote><p>并行:指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态<br>并发:指用户线程与垃圾收集线程同时执行(不一定并行，可能交替执行),用户线程在继续运行，而垃圾收集程序运行于另一个CPU上</p></blockquote><h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>使用复制算法的新生代收集器,并行多线程<br>这个收集器关注点是达到一个可控制的<code>吞吐量</code></p><blockquote><p>吞吐量:CPU用于运行用户代码的时间与CPU总消耗时间的比值<br>即,吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote><p>停顿时间越短越适合需要与用户交互的程序<br>高吞吐量则可以高效率地利用CPU时间，尽快完成运算任务</p><p>提供了两个参数用于精确控制吞吐量</p><ol><li>最大垃圾收集停顿时间-XX:MaxGCPauseMillis</li><li>设置吞吐量大小-XX:GCTimeRatio</li></ol><p>停顿时间越少，吞吐量就越少</p><p><code>-XX:UseAdaptiveSizePolicy</code>是一个开关参数<br>会动态调整新生代的大小Eden与Survivor的比例，晋升老年代对象的年龄-XX:PretenureSizeThreshold,达到最合适的停顿时间或最大吞吐量,称为GC自适应的调节策略</p><h1 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h1><p>这是Serial收集器的老年代版本，单线程，使用”标记-整理”算法<br>主要也是给Client模式下的虚拟机使用</p><h1 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h1><p>Parallel Scavenge的老年代版本，使用多线程和”标记-整理”算法</p><blockquote><p>注意吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old </p></blockquote><h1 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h1><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器<br>重视服务的相应速度，希望系统停顿时间最短，给用户带来较好的体验，CMS就非常符合这类应用</p><p>CMS是基于”标记-清除”算法实现的,运作过程分为4个步骤</p><ol><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ol><p>CMS的缺点,</p><ol><li><code>对CPU资源非常敏感</code>，事实上并发设计的程序对CPU资源都比较敏感，并发虽然不会导致用户线程停顿，但是会因为占用了一些CPU资源而导致程序变慢，总吞吐量会降低。   <code>CMS默认启动的回收线程数是(CPU数量+3)/4</code>,也就是当CPU在4个以上时，将占用25%的CPU资源。CPU数越少，影响越大。于是出现了<code>增量式并发收集器/i-CMS</code>,也就是让GC线程和用户线程交替运行，尽量较少GC线程的独占资源的时间，垃圾回收时间会更长，但是对用户程序的影响就会显得少一些,速度下降没那么明显,但是效果一般</li><li>无法处理<code>浮动垃圾</code>。浮动垃圾就是GC过程中用户线程并发产生的垃圾，当次不能处理，只能留到下次。也是由于在垃圾收集阶段用户信息还需要运行，那么就需要预留空间给用户线程使用,因此不能等老年代几乎被塞满了再收集。参数<code>-XX:CMSInitiatingOccupancyFraction</code>调高可以降低内存回收次数获得更好的性能。过高的话，内存无法满足程序运行，就会取用Serial Old</li><li>标记-清除算法带来的碎片。CMS提供了-XX:UserCMSCompactAtFullCollection开关(默认开启),在CMS要Full GC的时候做碎片整理，碎片整理是无法并发的，所以停顿时间会加长，-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，再执行一次压缩的(默认0，每次进入Full GC都进行碎片整理)</li></ol><h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>与其他收集器相比,G1具备如下特点。</p><ol><li>并发与并行:能通过多个CPU来缩短停顿时间,并且能通过并发的方式让Java程序继续执行</li><li>分代收集:G1不需要其他收集器配合就能独立管理整个GC堆</li><li>空间整合</li><li>可预测的停顿</li></ol><p>Java对的内存布局与其他收集器有很大的差别<br>它将<code>整个</code>Java堆划分为多个<code>大小相等的独立区域</code>，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分区域的集合</p><p>可预测的停顿时间模型是因为可以避免对这个Java堆进行垃圾收集，G1会跟踪分析回收价值最大的一个Region，维护一个优先列表，按优先级回收</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2019/03/24/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h1><p>Class文件是一组以<code>8位字节为基础单位的二进制流</code>,各个数据紧凑地排列，中间没有任何分割符，需要占用8位以上的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储</p><p>Class文件格式采用类似于C语言结构体的伪结构存储数据，且只有两种数据类型<code>无符号数</code>和<code>表</code><br>无符号数属于基本数据类型，使用u1,u2,u4,u8分别代表1一个字节，2个字节，4个字节，8个字节的无符号数<br><code>无符号数</code>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值<br><code>表</code>是由多个无符号数或者其他表作为数据项构成的复合数据类型,表是由<code>_info</code>结尾,用于描述有层次关系的符合结构数据，整个Class文件本质上就是一张表<br><img src="/media/15725148670004.jpg" alt=""></p><h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><p>每个Class文件的头4个字节称为魔数字，唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件,用作身份识别。他的值为<code>0xCAFEBABE</code>，魔数的4个字节存储的Class文件的版本号，第5和第6个字节是次版本号，第7和第8个字节是主版本号,Java的版本号是从45开始的</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着主版本号的是常量池入口，这个可以理解为Class文件的资源仓库,于其他项目关联最大，并且占用空间最大。<br>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值<br>常量池第0项空出来的，目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的含义。Class文件结构中只有这个是从1开始计数的</p><p>常量池中主要存放两大类常量</p><ol><li>字面量(Literal)</li><li>符号引用(Symbolic References)<br>字面量接近Java语言常量的概念，符号引用属于编译原理方面的概念,包含了下面三类常量</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol><p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址中。</p><p>常量池的14种表类型,它们有一个共同特点，开始的第一位是一个u1类型的标志位tag，表示属于哪种常量类型。<br><img src="/media/15725694254619.jpg" alt=""></p><p>各个常量表的字段及其表示含义<br><img src="/media/15725697493569.jpg" alt=""><br><img src="/media/15725697573646.jpg" alt=""></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>接下来就是访问标志<br><img src="/media/15725698605350.jpg" alt=""></p><h2 id="类索引、父类索引与接口索引"><a href="#类索引、父类索引与接口索引" class="headerlink" title="类索引、父类索引与接口索引"></a>类索引、父类索引与接口索引</h2><p>类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合。Class文件中由这三项数据来确定这个类的继承关系。<br>类索引用于确定这个类的全限定名<br>父类索引用于确定这个类的父类的全限定名</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述<code>接口或类</code>中声明的变量。字段包括类级变量以及实例级变量</p><p>字段表结构<br><img src="/media/15726572673399.jpg" alt=""></p><p>字段访问标志<br><img src="/media/15726572833906.jpg" alt=""></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p><img src="/media/15726573982729.jpg" alt=""></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/24/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>从被加载到虚拟机内存中开始到卸载出内存为止，生命周期包括<code>七个阶段</code></p><ol><li>加载(loading)</li><li>验证(Verification)</li><li>准备(Preparation)</li><li>解析(Resolution)</li><li>初始化(Initialization)</li><li>使用(Using)</li><li>卸载(Unloading)</li></ol><p>其中验证、准备、解析三部分称为<code>连接</code></p><p>为了支持Java语言的<code>运行时绑定</code>，某些情况下<code>解析阶段</code>会在初始化之后开始</p><p>虚拟机规范严格规定，出来下列五种情况，虚拟机必须对类进行初始化</p><ol><li>遇到new、getstatic、putstatic和invokestatic这4条字节码指令时</li><li>使用java.lang.reflect包的方法对类进行反射调用时</li><li>初始化一个类时，发现父类没有初始化,先初始化父类</li><li>虚拟机启动时,用户需要制定一个要执行的主类</li><li>MethodHandle实例解析出REF_getStatic,REF_putStatic,REF_invokeStatic方法句柄，对应的类未初始化</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>类和数组类加载</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了确保Class文件的字节流包含的信息符合当前虚拟机的要求<br>验证阶段大致上会完成下面4个阶段的检验动作</p><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/24/Java/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2019/03/24/Java/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较<code>小</code>的内存空间， 在虚拟机的概念模型中，字节码解释器工作时就是通过这个计数器的值<code>选取下一条需要执行的字节码指令</code>，分支、循环、跳转、异常处理、线程恢复等</p><p>因为Java虚拟机的多线程机制是<code>轮流切换</code>的,因此为了线程切换后能<code>恢复到正常的执行位置</code>,每条线程都有<code>独立的程序计数器</code>并且互相不影响,这块内存称为<code>线程私有</code></p><p>如果线程执行的是<code>Java方法</code>,那么计数器记录的是正在执行的虚拟机字节码指令的地址<br>如果正在执行的是<code>Native方法</code>,那么计数器值为空</p><p>程序计数器这个内存区域是在Java虚拟机规范中<code>唯一没有规定OutOfMemoryError</code>情况的区域</p><hr><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样,Java虚拟机栈也是<code>私有的</code>, 生命周期与线程相同<br>虚拟机栈描述的是Java方法执行的内存区域，每个<code>方法在执行时</code>都会`创建一个栈帧,用于存储</p><ol><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li><li>附加信息<br><img src="/media/15721709440647.jpg" alt="-w621"></li></ol><p>方法从<code>开始调用到执行完成</code>，对应着一个栈帧在虚拟机栈中<code>入栈到出栈</code>的过程</p><p>Java虚拟机规范中,对这个区域规定了两种<code>异常</code>情况</p><ol><li>StackOverFlowError<br>线程请求的栈深度大于虚拟机允许的深度</li><li>OutOfMemoryError<br>如果虚拟机可以动态拓展，拓展无法申请到足够的内存</li></ol><p>市面上流行的栈的说法指的只是<code>虚拟机栈的局部变量表</code></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放<code>方法参数和方法内部定义的局部变量</code>。</p><p>在Java程序编译为Class文件时,就在<code>方法的Code属性中的max_locals</code>数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p><p>局部变量表的容量以<code>变量槽为最小单位</code>，每个变量槽都可以存储32位长度的内存空间,其中<code>long和double占用2个局部变量空间</code>,其余数据类型占用1个</p><p><code>复用</code>,方法体中定义的变量，其<code>作用域并不一定会覆盖</code>整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用<br>优点：节省栈帧空间<br>缺点：影响垃圾回收</p><p>所以变量在对应的作用域执行完后,变量要注意置null</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>与局部变量表一样，操作数栈的<code>最大深度</code>也在编译的时候写入到<code>方法的Code属性的max_stacks数据项</code>中。</p><p>单位占用上与局部变量表一样</p><p>当一个方法刚刚<code>开始</code>执行时，其操作数栈是<code>空</code>的，随着方法执行和字节码指令的执行，会从<code>局部变量表或对象实例的字段中复制常量或变量</code>写入到操作数栈，再随着计算的进行将<code>栈中元素出栈到局部变量表或者返回给方法调用者</code>，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>在一个class文件中，一个方法要<code>调用其他方法</code>，需要将这些方法的<code>符号引用转化为其在内存地址中的直接引用</code>，而符号引用存在于<code>方法区中的运行时常量池</code>。</p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<code>动态连接(Dynamic Linking)。</code></p><p>这些符号引用一部分会在<code>类加载阶段或者第一次使用时就直接转化为直接引用</code>，这类转化称为<code>静态解析</code>。另一部分将在每次<code>运行期间转化为直接引用</code>，这类转化称为<code>动态连接</code></p><h3 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h3><p>当一个方法开始执行时，可能有两种方式退出该方法：</p><ol><li>正常完成出口</li><li>异常完成出口</li></ol><p><code>正常完成出口</code>:是指方法正常完成并退出，如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该<code>方法返回的字节码指令</code>确定。</p><p><code>异常完成出口</code>:是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p><p>无论方法采用何种方式退出，在方法<code>退出后都需要返回到方法被调用的位置</code>，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。</p><p>方法退出过程实际上就等同于把<code>当前栈帧出栈</code>，因此退出可以执行的操作有：</p><ol><li>恢复上层方法的局部变量表和操作数栈，</li><li>把返回值(如果有的话)压入调用者的操作数栈中，</li><li>调整PC计数器的值以指向方法调用指令后的下一条指令。</li></ol><p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过<code>异常处理器表</code>确定的，栈帧中一般不会保存此部分信息。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈类似作用的栈，不同的是本地方法栈执行的是<code>Native方法</code>,虚拟机栈执行Java方法(字节码)<br>规定的异常情况也一样,包括<code>StackOverFlowError和OutOfMemoryError</code></p><hr><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的，被所有线程共享。<br>在虚拟机启动时创建，此内存区域<code>唯一存在</code>的目的就是<code>存放对象实例</code>,Java虚拟机规范的描述是<code>所有的对象实例以及数组都要在堆上分配</code><br>随着JIT的发展，栈上分配、标量替换等优化，对象实例也<code>不是</code>绝对会在堆上</p><p>Java堆是垃圾收集器管理的主要区域(也叫GC堆,Collected Heap).<br>从内存回收角度来看因为收集器基本采用<code>分代收集算法</code>，所以分为<code>新生代和老年代</code><br>再细致的有<code>Eden空间,From Survivor空间,To Survivor空间等</code><br><code>线程共享</code>的Java堆中可能划分出多个<code>线程私有的分配缓冲区(Thread Local Allocation Buffer)</code></p><p>存储的依然都是对象实例，进一步划分的目的是为了更好地回收内存，更快地分配内存</p><p>Java虚拟机规定,Java堆<code>物理上不需要连续</code>，逻辑上连续即可<br>并且可以固定固定大小或者可拓展(-Xmx和-Xms)<br>当堆中没有内存并且无法拓展，将抛出<code>OutOfMemoryError</code></p><p>详细的回收与分配细节-&gt;</p><hr><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Java虚拟机规范把方法区归为<code>堆的一个逻辑部分</code>,但它有一个别名叫<code>Non-Heap</code>(非堆),区别于Java堆</p><p>与Java堆一样，是<code>线程共享</code>的内存区域<br>用于存储已经被虚拟机加载的</p><ol><li>类信息(版本、字段、方法、接口)</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ol><p>Java虚拟机规范中，除了和Java堆一样不需要连续的内存和可固定大小或者可拓展外，可以选择不实现垃圾回收,但是事实上还是有必要去实现。曾经的HotSpot虚拟机未对此区域进行回收导致了内存泄露</p><p>当方法区无法满足内存分配时，将抛出<code>OutOfMemoryError</code></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是<code>方法区的一部分</code>, 用于存放编译器产生的各种<code>字面量和符号引用</code>,在类加载后进入方法区的运行时常量池。</p><p>Java虚拟机对Class文件每一部分的格式都有严格的规定，每一个字节用于存储那种数据都必须符合规范才能被虚拟机认可，装载并运行。但是对于<code>运行时常量池，就没有做任何的细节要求</code>。</p><p>运行时常量池对Class文件常量池另外一个重要特征就是具备<code>动态性</code><br>也就是运行期间也可以把新的常量放入常量池中，比如说<code>String.intern()</code></p><p>既然运行时常量池是方法区一部分,无法满足内存分配时，将抛出<code>OutOfMemoryError</code></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>这个部分不是Java虚拟机运行时数据区的一部分，也没有在Java虚拟机规范中定义，但是也被频繁地使用</p><p>在JDK1.4中引入了NIO，引入了基于通道和缓冲区的I/O方式<br>它可以通过Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作,提高性能，避免Java堆和Native来回切换</p>]]></content>
      
      
    </entry>
    
  
  
</search>
